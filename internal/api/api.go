// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/go-chi/chi/v5"
)

// Defines values for ApprovementRule.
const (
	ApprovementRuleAllOf ApprovementRule = "AllOf"

	ApprovementRuleAnyOf ApprovementRule = "AnyOf"
)

// Defines values for ApproverType.
const (
	ApproverTypeFromSchema ApproverType = "fromSchema"

	ApproverTypeGroup ApproverType = "group"

	ApproverTypeHead ApproverType = "head"

	ApproverTypeUser ApproverType = "user"
)

// Defines values for BooleanOperandDataType.
const (
	BooleanOperandDataTypeBoolean BooleanOperandDataType = "boolean"

	BooleanOperandDataTypeInteger BooleanOperandDataType = "integer"

	BooleanOperandDataTypeString BooleanOperandDataType = "string"
)

// Defines values for BooleanOperandOperandType.
const (
	BooleanOperandOperandTypeValueOperand BooleanOperandOperandType = "valueOperand"

	BooleanOperandOperandTypeVariableOperand BooleanOperandOperandType = "variableOperand"
)

// Defines values for ConditionGroupLogicalOperator.
const (
	ConditionGroupLogicalOperatorAnd ConditionGroupLogicalOperator = "and"

	ConditionGroupLogicalOperatorOr ConditionGroupLogicalOperator = "or"
)

// Defines values for DateOperandDataType.
const (
	DateOperandDataTypeDate DateOperandDataType = "date"

	DateOperandDataTypeString DateOperandDataType = "string"
)

// Defines values for DateOperandOperandType.
const (
	DateOperandOperandTypeValueOperand DateOperandOperandType = "valueOperand"

	DateOperandOperandTypeVariableOperand DateOperandOperandType = "variableOperand"
)

// Defines values for EndSystemSettingsMethod.
const (
	EndSystemSettingsMethodPOST EndSystemSettingsMethod = "POST"
)

// Defines values for ExecutionParamsType.
const (
	ExecutionParamsTypeFromSchema ExecutionParamsType = "from_schema"

	ExecutionParamsTypeGroup ExecutionParamsType = "group"

	ExecutionParamsTypeUser ExecutionParamsType = "user"
)

// Defines values for ExternalSystemSubscriptionParamsMethod.
const (
	ExternalSystemSubscriptionParamsMethodPOST ExternalSystemSubscriptionParamsMethod = "POST"
)

// Defines values for FormAccessType.
const (
	FormAccessTypeNone FormAccessType = "None"

	FormAccessTypeRead FormAccessType = "Read"

	FormAccessTypeReadWrite FormAccessType = "ReadWrite"
)

// Defines values for FormExecutorType.
const (
	FormExecutorTypeAutoFill FormExecutorType = "auto_fill"

	FormExecutorTypeFromSchema FormExecutorType = "from_schema"

	FormExecutorTypeGroup FormExecutorType = "group"

	FormExecutorTypeInitiator FormExecutorType = "initiator"

	FormExecutorTypeUser FormExecutorType = "user"
)

// Defines values for FunctionParamsType.
const (
	FunctionParamsTypeApprover FunctionParamsType = "approver"

	FunctionParamsTypeExecutableFunction FunctionParamsType = "executable_function"

	FunctionParamsTypeExecution FunctionParamsType = "execution"

	FunctionParamsTypeForm FunctionParamsType = "form"

	FunctionParamsTypeIf FunctionParamsType = "if"

	FunctionParamsTypeNotification FunctionParamsType = "notification"

	FunctionParamsTypePlaceholder FunctionParamsType = "placeholder"

	FunctionParamsTypeServicedeskApplication FunctionParamsType = "servicedesk_application"

	FunctionParamsTypeSign FunctionParamsType = "sign"

	FunctionParamsTypeTimer FunctionParamsType = "timer"
)

// Defines values for IntegerOperandDataType.
const (
	IntegerOperandDataTypeBoolean IntegerOperandDataType = "boolean"

	IntegerOperandDataTypeInteger IntegerOperandDataType = "integer"

	IntegerOperandDataTypeNumber IntegerOperandDataType = "number"
)

// Defines values for IntegerOperandOperandType.
const (
	IntegerOperandOperandTypeValueOperand IntegerOperandOperandType = "valueOperand"

	IntegerOperandOperandTypeVariableOperand IntegerOperandOperandType = "variableOperand"
)

// Defines values for JSONSchemaType.
const (
	JSONSchemaTypeObject JSONSchemaType = "object"
)

// Defines values for MonitoringHistoryStatus.
const (
	MonitoringHistoryStatusFinished MonitoringHistoryStatus = "finished"

	MonitoringHistoryStatusRunning MonitoringHistoryStatus = "running"
)

// Defines values for MonitoringTableTaskStatus.
const (
	MonitoringTableTaskStatusВРаботе MonitoringTableTaskStatus = "В работе"

	MonitoringTableTaskStatusЗавершен MonitoringTableTaskStatus = "Завершен"

	MonitoringTableTaskStatusНеизвестныйСтатус MonitoringTableTaskStatus = "Неизвестный статус"

	MonitoringTableTaskStatusОстановлен MonitoringTableTaskStatus = "Остановлен"
)

// Defines values for NodeEvent.
const (
	NodeEventEnd NodeEvent = "end"

	NodeEventStart NodeEvent = "start"
)

// Defines values for NumberOperandDataType.
const (
	NumberOperandDataTypeInteger NumberOperandDataType = "integer"

	NumberOperandDataTypeNumber NumberOperandDataType = "number"

	NumberOperandDataTypeString NumberOperandDataType = "string"
)

// Defines values for NumberOperandOperandType.
const (
	NumberOperandOperandTypeValueOperand NumberOperandOperandType = "valueOperand"

	NumberOperandOperandTypeVariableOperand NumberOperandOperandType = "variableOperand"
)

// Defines values for RequestExecutionInfoType.
const (
	RequestExecutionInfoTypeAnswer RequestExecutionInfoType = "answer"

	RequestExecutionInfoTypeQuestion RequestExecutionInfoType = "question"
)

// Defines values for SignatureCarrier.
const (
	SignatureCarrierAll SignatureCarrier = "all"

	SignatureCarrierCloud SignatureCarrier = "cloud"

	SignatureCarrierToken SignatureCarrier = "token"
)

// Defines values for SignatureType.
const (
	SignatureTypePep SignatureType = "pep"

	SignatureTypeUkep SignatureType = "ukep"

	SignatureTypeUnep SignatureType = "unep"
)

// Defines values for SignerType.
const (
	SignerTypeFromSchema SignerType = "fromSchema"

	SignerTypeGroup SignerType = "group"

	SignerTypeUser SignerType = "user"
)

// Defines values for SigningRule.
const (
	SigningRuleAllOf SigningRule = "AllOf"

	SigningRuleAnyOf SigningRule = "AnyOf"
)

// Defines values for SocketActionType.
const (
	SocketActionTypeOther SocketActionType = "other"

	SocketActionTypePrimary SocketActionType = "primary"

	SocketActionTypeSecondary SocketActionType = "secondary"
)

// Defines values for StepStatus.
const (
	StepStatusFinished StepStatus = "finished"

	StepStatusIdle StepStatus = "idle"

	StepStatusReady StepStatus = "ready"

	StepStatusRunning StepStatus = "running"
)

// Defines values for StringOperandDataType.
const (
	StringOperandDataTypeBoolean StringOperandDataType = "boolean"

	StringOperandDataTypeDate StringOperandDataType = "date"

	StringOperandDataTypeInteger StringOperandDataType = "integer"

	StringOperandDataTypeNumber StringOperandDataType = "number"

	StringOperandDataTypeString StringOperandDataType = "string"
)

// Defines values for StringOperandOperandType.
const (
	StringOperandOperandTypeValueOperand StringOperandOperandType = "valueOperand"

	StringOperandOperandTypeVariableOperand StringOperandOperandType = "variableOperand"
)

// Defines values for TaskUpdateAction.
const (
	TaskUpdateActionAddApprovers TaskUpdateAction = "add_approvers"

	TaskUpdateActionAdditionalApprovement TaskUpdateAction = "additional_approvement"

	TaskUpdateActionApprovement TaskUpdateAction = "approvement"

	TaskUpdateActionApproverSendEditApp TaskUpdateAction = "approver_send_edit_app"

	TaskUpdateActionCancelApp TaskUpdateAction = "cancel_app"

	TaskUpdateActionChangeExecutor TaskUpdateAction = "change_executor"

	TaskUpdateActionExecution TaskUpdateAction = "execution"

	TaskUpdateActionExecutorSendEditApp TaskUpdateAction = "executor_send_edit_app"

	TaskUpdateActionExecutorStartWork TaskUpdateAction = "executor_start_work"

	TaskUpdateActionFillForm TaskUpdateAction = "fill_form"

	TaskUpdateActionFormExecutorStartWork TaskUpdateAction = "form_executor_start_work"

	TaskUpdateActionRequestAddInfo TaskUpdateAction = "request_add_info"

	TaskUpdateActionRequestExecutionInfo TaskUpdateAction = "request_execution_info"

	TaskUpdateActionSign TaskUpdateAction = "sign"
)

// Defines values for WorkType.
const (
	WorkTypeN125 WorkType = "12/5"

	WorkTypeN247 WorkType = "24/7"

	WorkTypeN85 WorkType = "8/5"
)

// Defines values for AdditionalApproverDecision.
const (
	AdditionalApproverDecisionApproved AdditionalApproverDecision = "approved"

	AdditionalApproverDecisionRejected AdditionalApproverDecision = "rejected"
)

// Defines values for ApproverDecision.
const (
	ApproverDecisionApprove ApproverDecision = "approve"

	ApproverDecisionConfirm ApproverDecision = "confirm"

	ApproverDecisionInformed ApproverDecision = "informed"

	ApproverDecisionReject ApproverDecision = "reject"

	ApproverDecisionSign ApproverDecision = "sign"

	ApproverDecisionSignUkep ApproverDecision = "sign_ukep"

	ApproverDecisionViewed ApproverDecision = "viewed"
)

// Defines values for BlockType.
const (
	BlockTypeGo BlockType = "go"

	BlockTypePython3 BlockType = "python3"

	BlockTypeScenario BlockType = "scenario"
)

// Defines values for CompareBooleanOperator.
const (
	CompareBooleanOperatorНеПустое CompareBooleanOperator = "Не Пустое"

	CompareBooleanOperatorНеРавно CompareBooleanOperator = "Не равно"

	CompareBooleanOperatorПустое CompareBooleanOperator = "Пустое"

	CompareBooleanOperatorРавно CompareBooleanOperator = "Равно"
)

// Defines values for CompareDateOperator.
const (
	CompareDateOperatorБольше CompareDateOperator = "Больше"

	CompareDateOperatorБольшеИлиРавно CompareDateOperator = "Больше или равно"

	CompareDateOperatorМеньше CompareDateOperator = "Меньше"

	CompareDateOperatorМеньшеИлиРавно CompareDateOperator = "Меньше или равно"

	CompareDateOperatorНеПустое CompareDateOperator = "Не Пустое"

	CompareDateOperatorНеРавно CompareDateOperator = "Не равно"

	CompareDateOperatorПустое CompareDateOperator = "Пустое"

	CompareDateOperatorРавно CompareDateOperator = "Равно"
)

// Defines values for CompareIntegerOperator.
const (
	CompareIntegerOperatorБольше CompareIntegerOperator = "Больше"

	CompareIntegerOperatorБольшеИлиРавно CompareIntegerOperator = "Больше или равно"

	CompareIntegerOperatorМеньше CompareIntegerOperator = "Меньше"

	CompareIntegerOperatorМеньшеИлиРавно CompareIntegerOperator = "Меньше или равно"

	CompareIntegerOperatorНеПустое CompareIntegerOperator = "Не Пустое"

	CompareIntegerOperatorНеРавно CompareIntegerOperator = "Не равно"

	CompareIntegerOperatorПустое CompareIntegerOperator = "Пустое"

	CompareIntegerOperatorРавно CompareIntegerOperator = "Равно"
)

// Defines values for CompareNumberOperator.
const (
	CompareNumberOperatorБольше CompareNumberOperator = "Больше"

	CompareNumberOperatorБольшеИлиРавно CompareNumberOperator = "Больше или равно"

	CompareNumberOperatorМеньше CompareNumberOperator = "Меньше"

	CompareNumberOperatorМеньшеИлиРавно CompareNumberOperator = "Меньше или равно"

	CompareNumberOperatorНеПустое CompareNumberOperator = "Не Пустое"

	CompareNumberOperatorНеРавно CompareNumberOperator = "Не равно"

	CompareNumberOperatorПустое CompareNumberOperator = "Пустое"

	CompareNumberOperatorРавно CompareNumberOperator = "Равно"
)

// Defines values for CompareStringOperator.
const (
	CompareStringOperatorНеПустое CompareStringOperator = "Не Пустое"

	CompareStringOperatorНеРавно CompareStringOperator = "Не равно"

	CompareStringOperatorНеСодержит CompareStringOperator = "Не Содержит"

	CompareStringOperatorПустое CompareStringOperator = "Пустое"

	CompareStringOperatorРавно CompareStringOperator = "Равно"

	CompareStringOperatorСодержит CompareStringOperator = "Содержит"
)

// Defines values for EriusTaskResponseStatus.
const (
	EriusTaskResponseStatusCreated EriusTaskResponseStatus = "created"

	EriusTaskResponseStatusError EriusTaskResponseStatus = "error"

	EriusTaskResponseStatusFinished EriusTaskResponseStatus = "finished"

	EriusTaskResponseStatusRun EriusTaskResponseStatus = "run"

	EriusTaskResponseStatusStopped EriusTaskResponseStatus = "stopped"
)

// Defines values for ExecutionDecision.
const (
	ExecutionDecisionExecuted ExecutionDecision = "executed"

	ExecutionDecisionRejected ExecutionDecision = "rejected"
)

// Defines values for ScenarioStatus.
const (
	ScenarioStatusN1 ScenarioStatus = 1

	ScenarioStatusN2 ScenarioStatus = 2

	ScenarioStatusN3 ScenarioStatus = 3

	ScenarioStatusN4 ScenarioStatus = 4

	ScenarioStatusN5 ScenarioStatus = 5
)

// Defines values for SignDecision.
const (
	SignDecisionError SignDecision = "error"

	SignDecisionRejected SignDecision = "rejected"

	SignDecisionSigned SignDecision = "signed"
)

// Defines values for TaskHumanStatus.
const (
	TaskHumanStatusApproveConfirm TaskHumanStatus = "approve-confirm"

	TaskHumanStatusApproveConfirmed TaskHumanStatus = "approve-confirmed"

	TaskHumanStatusApproveInform TaskHumanStatus = "approve-inform"

	TaskHumanStatusApproveInformed TaskHumanStatus = "approve-informed"

	TaskHumanStatusApproveSign TaskHumanStatus = "approve-sign"

	TaskHumanStatusApproveSignUkep TaskHumanStatus = "approve-sign_ukep"

	TaskHumanStatusApproveSigned TaskHumanStatus = "approve-signed"

	TaskHumanStatusApproveView TaskHumanStatus = "approve-view"

	TaskHumanStatusApproveViewed TaskHumanStatus = "approve-viewed"

	TaskHumanStatusApproved TaskHumanStatus = "approved"

	TaskHumanStatusApprovement TaskHumanStatus = "approvement"

	TaskHumanStatusApprovementReject TaskHumanStatus = "approvement-reject"

	TaskHumanStatusCancel TaskHumanStatus = "cancel"

	TaskHumanStatusDone TaskHumanStatus = "done"

	TaskHumanStatusExecutorReject TaskHumanStatus = "executor-reject"

	TaskHumanStatusNew TaskHumanStatus = "new"

	TaskHumanStatusProcessing TaskHumanStatus = "processing"

	TaskHumanStatusRevoke TaskHumanStatus = "revoke"

	TaskHumanStatusWait TaskHumanStatus = "wait"
)

// Add Approver params
type AddApproversParams struct {
	// logins of additional approvers
	AdditionalApprovers []string     `json:"additionalApprovers"`
	Attachments         []Attachment `json:"attachments"`

	// Question from approver
	Question string `json:"question"`
}

// Approver update params
type AdditionalApproverUpdateParams struct {
	Attachments []Attachment `json:"attachments"`

	// Comment from approver
	Comment string `json:"comment"`

	// Approver decision:
	//  * approved - Согласовать
	//  * rejected - Отклонить
	Decision AdditionalApproverDecision `json:"decision"`
}

// AllUsageResponse defines model for AllUsageResponse.
type AllUsageResponse struct {
	Pipelines AllUsageResponse_Pipelines `json:"pipelines"`
}

// AllUsageResponse_Pipelines defines model for AllUsageResponse.Pipelines.
type AllUsageResponse_Pipelines struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// Разрешить системе запуск заявки от третьего лица
type AllowRunAsOthers bool

// ApproveActionNamesResponse defines model for ApproveActionNamesResponse.
type ApproveActionNamesResponse struct {
	// approve action id
	Id string `json:"id"`

	// approve action title
	Title string `json:"title"`
}

// ApproveStatusesResponse defines model for ApproveStatusesResponse.
type ApproveStatusesResponse struct {
	// approve status id
	Id string `json:"id"`

	// approve status title
	Title string `json:"title"`
}

// Count of approvers which will participate in approvement will depends of approvement type. 'Any of' will check only first approvement action, when 'all of' will be waiting for all approvers or auto actions.
type ApprovementRule string

// Approver params
type ApproverParams struct {
	// Approvement status
	ApproveStatusName string `json:"approve_status_name"`

	// Count of approvers which will participate in approvement will depends of approvement type. 'Any of' will check only first approvement action, when 'all of' will be waiting for all approvers or auto actions.
	ApprovementRule *ApprovementRule `json:"approvementRule,omitempty"`

	// Approver value (depends on type)
	Approver string `json:"approver"`

	// Approvers group id in SD
	ApproversGroupId string `json:"approvers_group_id"`

	// Path to approvers group id
	ApproversGroupIdPath *string `json:"approvers_group_id_path,omitempty"`

	// Approvers group name in SD
	ApproversGroupName string `json:"approvers_group_name"`

	// Auto action to do (from action list)
	AutoAction *string `json:"auto_action,omitempty"`

	// Is rework SLA active
	CheckReworkSla bool `json:"check_rework_sla"`

	// Is active SLA
	CheckSla bool `json:"check_sla"`

	// List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// Show action edit application in SD
	IsEditable         bool `json:"is_editable"`
	RepeatPrevDecision bool `json:"repeat_prev_decision"`

	// Approvement rework SLA (in working hours)
	ReworkSla int `json:"rework_sla"`

	// Approvement SLA (in working hours)
	Sla int `json:"sla"`

	// Approver type:
	//   * user - Single user
	//   * group - Approver group ID
	//   * head - Receiver's head
	//   * FromSchema - Selected by initiator
	Type ApproverType `json:"type"`

	// Рабочий режим
	WorkType *WorkType `json:"work_type,omitempty"`
}

// Approver type:
//   - user - Single user
//   - group - Approver group ID
//   - head - Receiver's head
//   - FromSchema - Selected by initiator
type ApproverType string

// Approver update params
type ApproverUpdateParams struct {
	Attachments []Attachment `json:"attachments"`

	// Comment from approver
	Comment string `json:"comment"`

	// Approver decision:
	//  * approve - Согласовать
	//  * reject - Отклонить
	//  * viewed - Ознакомлен
	//  * informed - Проинформирован
	//  * sign - Подписать
	//  * confirm - Утвердить
	//  * sign_ukep - Подписать УКЭП
	Decision ApproverDecision `json:"decision"`
}

// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
type ArrayItems struct {
	Format *string `json:"format,omitempty"`

	// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
	Items *ArrayItems `json:"items,omitempty"`

	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Properties *JSONSchemaProperties `json:"properties,omitempty"`

	// Тип элементов массива
	Type string `json:"type"`
}

// Attachment defines model for Attachment.
type Attachment struct {
	// Ссылка на файл в сторонней системе
	ExternalLink *string `json:"external_link,omitempty"`

	// Id файла в file registry
	FileId *string `json:"file_id,omitempty"`
}

// BlockContextResponse defines model for BlockContextResponse.
type BlockContextResponse struct {
	// Ноды
	Blocks *BlockContextResponse_Blocks `json:"blocks,omitempty"`
}

// Ноды
type BlockContextResponse_Blocks struct {
	AdditionalProperties map[string]MonitoringBlockOutput `json:"-"`
}

// Basic boolean operand, can provide working compare types for this type
type BooleanOperand struct {
	DataType    BooleanOperandDataType    `json:"dataType"`
	OperandType BooleanOperandOperandType `json:"operandType"`
}

// BooleanOperandDataType defines model for BooleanOperand.DataType.
type BooleanOperandDataType string

// BooleanOperandOperandType defines model for BooleanOperand.OperandType.
type BooleanOperandOperandType string

// CancelAppParams defines model for CancelAppParams.
type CancelAppParams struct {
	Comment string `json:"comment"`
}

// Compare operands using operator
type Condition struct {
	// Operand for comparison
	LeftOperand Operand     `json:"leftOperand"`
	Operator    interface{} `json:"operator"`

	// Operand for comparison
	RightOperand Operand `json:"rightOperand"`
}

// Group with conditions
type ConditionGroup struct {
	Conditions      []Condition                   `json:"conditions"`
	Id              string                        `json:"id"`
	LogicalOperator ConditionGroupLogicalOperator `json:"logicalOperator"`
	Name            *string                       `json:"name,omitempty"`
}

// ConditionGroupLogicalOperator defines model for ConditionGroup.LogicalOperator.
type ConditionGroupLogicalOperator string

// Condition params
type ConditionParams struct {
	// Groups with conditions
	ConditionGroups *[]ConditionGroup `json:"conditionGroups,omitempty"`
}

// CountTasks defines model for CountTasks.
type CountTasks struct {
	Active      int `json:"active"`
	Approve     int `json:"approve"`
	Execute     int `json:"execute"`
	FormExecute int `json:"form_execute"`
	Sign        int `json:"sign"`
}

// Created defines model for Created.
type Created struct {
	End   int `json:"end"`
	Start int `json:"start"`
}

// Basic date operand, can provide working compare types for this type
type DateOperand struct {
	DataType    DateOperandDataType    `json:"dataType"`
	OperandType DateOperandOperandType `json:"operandType"`
}

// DateOperandDataType defines model for DateOperand.DataType.
type DateOperandDataType string

// DateOperandOperandType defines model for DateOperand.OperandType.
type DateOperandOperandType string

// DebugResult defines model for DebugResult.
type DebugResult struct {
	BlockName   string   `json:"block_name"`
	BreakPoints []string `json:"break_points"`

	// todo define values
	Status string    `json:"status"`
	Task   EriusTask `json:"task"`
}

// DebugRunRequest defines model for DebugRunRequest.
type DebugRunRequest struct {
	Action      string   `json:"action"`
	BreakPoints []string `json:"break_points"`
	WorkNumber  string   `json:"work_number"`
}

// EndSystemSettings defines model for EndSystemSettings.
type EndSystemSettings struct {
	URL            string                  `json:"URL"`
	Method         EndSystemSettingsMethod `json:"method"`
	MicroserviceId string                  `json:"microservice_id"`
}

// EndSystemSettingsMethod defines model for EndSystemSettings.Method.
type EndSystemSettingsMethod string

// EriusFunc defines model for EriusFunc.
type EriusFunc struct {
	// Block type (language)
	BlockType  BlockType               `json:"block_type"`
	Input      *[]EriusFunctionValue   `json:"input,omitempty"`
	Next       EriusFunc_Next          `json:"next"`
	Output     *JSONSchema             `json:"output,omitempty"`
	ParamType  *string                 `json:"param_type,omitempty"`
	Params     *map[string]interface{} `json:"params,omitempty"`
	ShortTitle *string                 `json:"short_title,omitempty"`
	Sockets    *[]Socket               `json:"sockets,omitempty"`
	Title      string                  `json:"title"`
	True       *int                    `json:"true,omitempty"`
	TypeId     string                  `json:"type_id"`
	X          *int                    `json:"x,omitempty"`
}

// EriusFunc_Next defines model for EriusFunc.Next.
type EriusFunc_Next struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// EriusFunctionList defines model for EriusFunctionList.
type EriusFunctionList struct {
	// Block modules
	Funcs []FunctionModel `json:"funcs"`

	// Block shapes
	Shapes []ShapeEntity `json:"shapes"`
}

// EriusFunctionValue defines model for EriusFunctionValue.
type EriusFunctionValue struct {
	Format string `json:"format"`
	Global string `json:"global"`
	Name   string `json:"name"`
	Type   string `json:"type"`
}

// A single scenario with all content
type EriusScenario struct {
	ApprovedAt      *string               `json:"approved_at,omitempty"`
	Author          string                `json:"author"`
	Comment         string                `json:"comment"`
	CommentRejected string                `json:"comment_rejected"`
	CreatedAt       *string               `json:"created_at,omitempty"`
	HasDraft        *bool                 `json:"hasDraft,omitempty"`
	Id              string                `json:"id"`
	Input           *[]EriusFunctionValue `json:"input,omitempty"`
	Name            string                `json:"name"`
	Output          *[]EriusFunctionValue `json:"output,omitempty"`
	Pipeline        Pipeline              `json:"pipeline"`

	// 1 - Draft, 2 - Approved, 3 - Deleted, 4 - Rejected, 5 - On Approve
	Status    int            `json:"status"`
	Tags      []EriusTagInfo `json:"tags"`
	VersionId string         `json:"version_id"`
}

// EriusScenarioInfo defines model for EriusScenarioInfo.
type EriusScenarioInfo struct {
	ApprovedAt      *string `json:"approved_at,omitempty"`
	Approver        string  `json:"approver"`
	Author          string  `json:"author"`
	Comment         string  `json:"comment"`
	CommentRejected string  `json:"comment_rejected"`
	CreatedAt       string  `json:"created_at"`
	Id              string  `json:"id"`
	LastRun         *string `json:"last_run,omitempty"`
	LastRunStatus   *string `json:"last_run_status,omitempty"`
	Name            string  `json:"name"`

	// Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status    ScenarioStatus `json:"status"`
	Tags      []EriusTagInfo `json:"tags"`
	VersionId string         `json:"version_id"`
}

// EriusScenarioList defines model for EriusScenarioList.
type EriusScenarioList []EriusScenarioInfo

// EriusTagInfo defines model for EriusTagInfo.
type EriusTagInfo struct {
	Color    string `json:"color"`
	Id       string `json:"id"`
	IsMarker bool   `json:"isMarker"`
	Name     string `json:"name"`

	// 1 - Created, 3 - Deleted
	Status int `json:"status"`
}

// EriusTask defines model for EriusTask.
type EriusTask struct {
	AttachmentsCount *int    `json:"attachments_count,omitempty"`
	Author           string  `json:"author"`
	BlueprintId      string  `json:"blueprint_id"`
	Comment          *string `json:"comment,omitempty"`
	Debug            bool    `json:"debug"`
	Description      string  `json:"description"`

	// Task human readable status
	HumanStatus   TaskHumanStatus        `json:"human_status"`
	Id            string                 `json:"id"`
	LastChangedAt string                 `json:"last_changed_at"`
	Name          string                 `json:"name"`
	Parameters    map[string]interface{} `json:"parameters"`
	Rate          *int                   `json:"rate,omitempty"`
	StartedAt     string                 `json:"started_at"`
	Status        string                 `json:"status"`
	Steps         []Step                 `json:"steps"`
	VersionId     string                 `json:"version_id"`
	WorkNumber    string                 `json:"work_number"`
}

// EriusTasks defines model for EriusTasks.
type EriusTasks struct {
	Tasks *[]EriusTask `json:"tasks,omitempty"`
}

// EriusTasksPage defines model for EriusTasksPage.
type EriusTasksPage struct {
	Tasks []EriusTask `json:"tasks"`
	Total int         `json:"total"`
}

// EriusVersionInfo defines model for EriusVersionInfo.
type EriusVersionInfo struct {
	ApprovedAt string  `json:"approved_at"`
	Approver   *string `json:"approver,omitempty"`
	Author     string  `json:"author"`
	CreatedAt  string  `json:"created_at"`

	// If the version is currently used as an actual one
	IsActual bool `json:"is_actual"`

	// Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status    ScenarioStatus `json:"status"`
	UpdatedAt string         `json:"updated_at"`

	// How many times is the version used as a subprocess
	UsageCount int    `json:"usage_count"`
	VersionId  string `json:"version_id"`
}

// Chosen function to be executed
type ExecutableFunctionParams struct {
	// Is active SLA
	CheckSla bool `json:"check_sla"`

	// Constant values for function parameters (key of object is variable name)
	Constants map[string]interface{} `json:"constants"`

	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Mapping JSONSchemaProperties `json:"mapping"`

	// Function name
	Name string `json:"name"`

	// in seconds
	Sla int `json:"sla"`

	// Used function version
	Version string `json:"version"`

	// Days to wait correct answer
	WaitCorrectRes int `json:"waitCorrectRes"`
}

// Execution params
type ExecutionParams struct {
	// Is rework SLA active
	CheckReworkSla bool `json:"check_rework_sla"`

	// Is active SLA
	CheckSla bool `json:"check_sla"`

	// Executor value (depends on type)
	Executors string `json:"executors"`

	// Executors group id in SD
	ExecutorsGroupId string `json:"executors_group_id"`

	// Path to executors group id
	ExecutorsGroupIdPath *string `json:"executors_group_id_path,omitempty"`

	// Executors group name in SD
	ExecutorsGroupName string `json:"executors_group_name"`

	// List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// Show action edit application in SD
	IsEditable bool `json:"is_editable"`

	// auto apply prev decision
	RepeatPrevDecision bool `json:"repeat_prev_decision"`

	// Execution rework SLA (in working hours)
	ReworkSla int `json:"rework_sla"`

	// Execution SLA (in working hours)
	Sla int `json:"sla"`

	// Execution type:
	//  * user - Single user
	//  * group - Execution group ID
	//  * from_schema - Selected by initiator
	Type ExecutionParamsType `json:"type"`

	// flag to use actual executor
	UseActualExecutor bool `json:"use_actual_executor"`

	// Рабочий режим
	WorkType *WorkType `json:"work_type,omitempty"`
}

// Execution type:
//   - user - Single user
//   - group - Execution group ID
//   - from_schema - Selected by initiator
type ExecutionParamsType string

// Executor update params
type ExecutionUpdateParams struct {
	Attachments []Attachment `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// Executor decision:
	//  * executed - executor executed block
	//  * rejected - executor rejected block
	Decision ExecutionDecision `json:"decision"`
}

// Executor change params
type ExecutorChangeParams struct {
	Attachments []Attachment `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// New executor login
	NewExecutorLogin string `json:"newExecutorLogin"`
}

// ExternalSystem defines model for ExternalSystem.
type ExternalSystem struct {
	// Разрешить системе запуск заявки от третьего лица
	AllowRunAsOthers *AllowRunAsOthers `json:"allow_run_as_others,omitempty"`
	InputMapping     *JSONSchema       `json:"input_mapping,omitempty"`
	InputSchema      *JSONSchema       `json:"input_schema,omitempty"`

	// Название системы
	Name           string             `json:"name"`
	OutputMapping  *JSONSchema        `json:"output_mapping,omitempty"`
	OutputSchema   *JSONSchema        `json:"output_schema,omitempty"`
	OutputSettings *EndSystemSettings `json:"output_settings,omitempty"`

	// Id внешней системы
	SystemId string `json:"system_id"`
}

// Id внешней системы
type ExternalSystemId string

// Настройки подписки системы на изменения в заявках
type ExternalSystemSubscriptionParams struct {
	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Mapping JSONSchemaProperties `json:"mapping"`

	// Какой http метод использовать
	Method ExternalSystemSubscriptionParamsMethod `json:"method"`

	// ID микросервиса
	MicroserviceId string `json:"microservice_id"`

	// Ноды и ивенты, на которые нужна подписка
	Nodes              []NodeSubscriptionEvents `json:"nodes"`
	NotificationSchema JSONSchema               `json:"notification_schema"`

	// Путь, по которому надо присылать ивенты
	Path string `json:"path"`

	// ID системы
	SystemId string `json:"system_id"`
}

// Какой http метод использовать
type ExternalSystemSubscriptionParamsMethod string

// Fill form
type FillFormUpdateParams struct {
	ApplicationBody map[string]interface{} `json:"application_body"`

	// Form block id
	BlockId string `json:"block_id"`

	// form data
	Description string `json:"description"`
}

// Form accessibility preferences for certain node
type FormAccessType string

// FormChangelogItem defines model for FormChangelogItem.
type FormChangelogItem struct {
	// Filled form values
	ApplicationBody *map[string]interface{} `json:"application_body,omitempty"`

	// Date of log item creation
	CreatedAt *string `json:"created_at,omitempty"`

	// Compiled field keys and values of form used for notifications
	Description *string `json:"description,omitempty"`

	// Login of form executor
	Executor *string `json:"executor,omitempty"`

	// id of form schema id
	SchemaId *string `json:"schema_id,omitempty"`
}

// Form executor type:
//   - User - Single user
//   - group - Form group ID
//   - Initiator - Process initiator
//   - From_schema - Selected by initiator
//   - Auto_Fill - Auto Fill form by system
type FormExecutorType string

// Form params
type FormParams struct {
	// Is active SLA
	CheckSla bool `json:"check_sla"`

	// Constant values for function parameters (key of object is variable name)
	Constants *map[string]interface{} `json:"constants,omitempty"`

	// Executor value
	Executor *string `json:"executor,omitempty"`

	// Form executor type:
	//   * User - Single user
	//   * group - Form group ID
	//   * Initiator - Process initiator
	//   * From_schema - Selected by initiator
	//   * Auto_Fill - Auto Fill form by system
	FormExecutorType *FormExecutorType `json:"form_executor_type,omitempty"`

	// Form group id in SD
	FormGroupId *string `json:"form_group_id,omitempty"`

	// Path to form group id
	FormGroupIdPath *string `json:"form_group_id_path,omitempty"`

	// Настройки блока при повторном заходе в этот блок
	FormReEnterSettings *FormReEnterSettings `json:"form_re_enter_settings,omitempty"`

	// List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// Hide executor from initiator
	HideExecutorFromInitiator bool `json:"hide_executor_from_initiator"`

	// true - need manual fill when reenter in block
	IsEditable *bool `json:"is_editable,omitempty"`

	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Mapping *JSONSchemaProperties `json:"mapping,omitempty"`

	// form template id
	SchemaId *string `json:"schema_id,omitempty"`

	// form sla
	Sla int `json:"sla"`

	// Рабочий режим
	WorkType *WorkType `json:"work_type,omitempty"`
}

// Настройки блока при повторном заходе в этот блок
type FormReEnterSettings struct {
	// Form executor type:
	//   * User - Single user
	//   * group - Form group ID
	//   * Initiator - Process initiator
	//   * From_schema - Selected by initiator
	//   * Auto_Fill - Auto Fill form by system
	FormExecutorType *FormExecutorType `json:"form_executor_type,omitempty"`

	// path to group id
	GroupPath *string `json:"group_path,omitempty"`

	// Executor login, variable or group id
	Value *string `json:"value,omitempty"`
}

// FormsAccessibility defines model for FormsAccessibility.
type FormsAccessibility struct {
	// Form accessibility preferences for certain node
	AccessType FormAccessType `json:"accessType"`

	// Form short description
	Description *string `json:"description,omitempty"`

	// Form name
	Name string `json:"name"`

	// Form node ID
	NodeId string `json:"node_id"`
}

// Changelog of filled form data
type FormsChangelogResponse []FormChangelogItem

// FunctionModel defines model for FunctionModel.
type FunctionModel struct {
	// Block type (language)
	BlockType BlockType             `json:"block_type"`
	Id        string                `json:"id"`
	Inputs    *[]FunctionValueModel `json:"inputs,omitempty"`
	Outputs   *JSONSchema           `json:"outputs,omitempty"`
	Params    *FunctionParams       `json:"params,omitempty"`
	ShapeType int                   `json:"shape_type"`
	Sockets   []Socket              `json:"sockets"`
	Title     string                `json:"title"`
}

// FunctionParams defines model for FunctionParams.
type FunctionParams struct {
	// Block constant params
	Params *Params `json:"params,omitempty"`

	// Params type
	Type FunctionParamsType `json:"type"`
}

// Params type
type FunctionParamsType string

// FunctionValueModel defines model for FunctionValueModel.
type FunctionValueModel struct {
	Comment *string `json:"comment,omitempty"`
	Name    *string `json:"name,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// Basic integer operand, can provide working compare types for this type
type IntegerOperand struct {
	DataType    IntegerOperandDataType    `json:"dataType"`
	OperandType IntegerOperandOperandType `json:"operandType"`
}

// IntegerOperandDataType defines model for IntegerOperand.DataType.
type IntegerOperandDataType string

// IntegerOperandOperandType defines model for IntegerOperand.OperandType.
type IntegerOperandOperandType string

// JSONSchema defines model for JSONSchema.
type JSONSchema struct {
	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Properties JSONSchemaProperties `json:"properties"`
	Required   *[]string            `json:"required,omitempty"`
	Type       JSONSchemaType       `json:"type"`
}

// JSONSchemaType defines model for JSONSchema.Type.
type JSONSchemaType string

// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
type JSONSchemaProperties struct {
	AdditionalProperties map[string]struct {
		// Default value
		Default *interface{} `json:"default,omitempty"`

		// Description of param
		Description *string `json:"description,omitempty"`

		// Format of param
		Format *string `json:"format,omitempty"`

		// Format of param
		Global *string `json:"global,omitempty"`

		// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
		Items *ArrayItems `json:"items,omitempty"`

		// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
		Properties *JSONSchemaProperties `json:"properties,omitempty"`

		// Required fields for type = object
		Required *[]string `json:"required,omitempty"`

		// Title of param
		Title string `json:"title"`

		// Type of param
		Type string `json:"type"`

		// Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
		Value *string `json:"value,omitempty"`
	} `json:"-"`
}

// MonitoringBlockOutput defines model for MonitoringBlockOutput.
type MonitoringBlockOutput struct {
	// Описание поля
	Description string `json:"description"`

	// Имя поля
	Name string `json:"name"`

	// Тип поля
	Type string `json:"type"`

	// Значение поля
	Value interface{} `json:"value"`
}

// MonitoringBlockParam defines model for MonitoringBlockParam.
type MonitoringBlockParam struct {
	// Описание поля
	Description string `json:"description"`

	// Имя поля
	Name string `json:"name"`

	// Тип поля
	Type string `json:"type"`

	// Значение поля
	Value interface{} `json:"value"`
}

// MonitoringHistory defines model for MonitoringHistory.
type MonitoringHistory struct {
	// Время перехода на конкретный блок
	BlockDateInit *string `json:"block_date_init,omitempty"`

	// Айди ноды в variable_storage
	BlockId string `json:"block_id"`

	// id ноды в заявке
	NodeId string `json:"node_id"`

	// читаемое имя ноды
	RealName string `json:"real_name"`

	// Статус ноды
	Status MonitoringHistoryStatus `json:"status"`
}

// Статус ноды
type MonitoringHistoryStatus string

// MonitoringParamsResponse defines model for MonitoringParamsResponse.
type MonitoringParamsResponse struct {
	FinishedAt *string `json:"finished_at,omitempty"`

	// Входные параметы
	Inputs *MonitoringParamsResponse_Inputs `json:"inputs,omitempty"`

	// Выходные параметы
	Outputs   *MonitoringParamsResponse_Outputs `json:"outputs,omitempty"`
	StartedAt *string                           `json:"started_at,omitempty"`
}

// Входные параметы
type MonitoringParamsResponse_Inputs struct {
	AdditionalProperties map[string]MonitoringBlockParam `json:"-"`
}

// Выходные параметы
type MonitoringParamsResponse_Outputs struct {
	AdditionalProperties map[string]MonitoringBlockParam `json:"-"`
}

// MonitoringScenarioInfo defines model for MonitoringScenarioInfo.
type MonitoringScenarioInfo struct {
	// Автор сценария
	Author string `json:"author"`

	// Время создания сценария
	CreationTime string `json:"creation_time"`

	// Имя сценария
	ScenarioName string `json:"scenario_name"`
}

// MonitoringTableTask defines model for MonitoringTableTask.
type MonitoringTableTask struct {
	FinishedAt string `json:"finished_at"`

	// login of initiator
	Initiator string `json:"initiator"`

	// fullname of the initiator
	InitiatorFullname string `json:"initiator_fullname"`

	// name of the process
	ProcessName string `json:"process_name"`
	StartedAt   string `json:"started_at"`

	// task status
	Status     MonitoringTableTaskStatus `json:"status"`
	WorkNumber string                    `json:"work_number"`
}

// task status
type MonitoringTableTaskStatus string

// MonitoringTask defines model for MonitoringTask.
type MonitoringTask struct {
	History      []MonitoringHistory    `json:"history"`
	ScenarioInfo MonitoringScenarioInfo `json:"scenario_info"`

	// Айди версии сценария для мониторинга
	VersionId string `json:"version_id"`

	// Номер заявки для мониторинга
	WorkNumber string `json:"work_number"`
}

// MonitoringTasksPage defines model for MonitoringTasksPage.
type MonitoringTasksPage struct {
	Tasks []MonitoringTableTask `json:"tasks"`

	// total number of tasks
	Total int `json:"total"`
}

// NameExists defines model for NameExists.
type NameExists struct {
	// Существует ли имя
	Exists bool `json:"exists"`
}

// NodeDecisions defines model for NodeDecisions.
type NodeDecisions struct {
	// Название решения
	Decision string `json:"decision"`

	// Название решения на русском
	Title string `json:"title"`

	// Айди решения нод
	Id string `json:"id"`

	// Тип ноды
	NodeType string `json:"node_type"`
}

// Возможный ивент ноды
type NodeEvent string

// NodeSubscriptionEvents defines model for NodeSubscriptionEvents.
type NodeSubscriptionEvents struct {
	Events *[]NodeEvent `json:"events,omitempty"`

	// ID ноды в процессе
	NodeId string `json:"node_id"`

	// Нужно ли уведомлять о событиях по ноде
	Notify bool `json:"notify"`
}

// Notification params
type NotificationParams struct {
	// Emails to get notifications
	Emails []string `json:"emails"`

	// People to get notifications
	People []string `json:"people"`

	// Notification subject
	Subject string `json:"subject"`

	// Notification body
	Text string `json:"text"`
}

// Basic number operand, can provide working compare types for this type
type NumberOperand struct {
	DataType    NumberOperandDataType    `json:"dataType"`
	OperandType NumberOperandOperandType `json:"operandType"`
}

// NumberOperandDataType defines model for NumberOperand.DataType.
type NumberOperandDataType string

// NumberOperandOperandType defines model for NumberOperand.OperandType.
type NumberOperandOperandType string

// Block constant params
type Params interface{}

// Placeholder block params
type PlaceholderParams struct {
	// New task description
	Description string `json:"description"`

	// New task name
	Name string `json:"name"`
}

// Настройки старта версии пайплайна(процесса)
type ProcessSettings struct {
	EndSchema *JSONSchema `json:"end_schema,omitempty"`

	// Новое имя сценария
	Name string `json:"name"`

	// Срок, в течении которого придет уведомление о том, что пользователь повторно создал заявку. Указывается в часах.
	ResubmissionPeriod int `json:"resubmission_period"`

	// SLA в рабочих часах
	Sla         int         `json:"sla"`
	StartSchema *JSONSchema `json:"start_schema,omitempty"`

	// Id версии процесса
	VersionId string `json:"version_id"`

	// Рабочий режим
	WorkType WorkType `json:"work_type"`
}

// Настройки старта версии пайплайна(процесса)
type ProcessSettingsWithExternalSystems struct {
	// Внешние системы, которые используют данный пайплайн
	ExternalSystems []ExternalSystem `json:"external_systems"`

	// Настройки старта версии пайплайна(процесса)
	ProcessSettings ProcessSettings `json:"process_settings"`

	// Подписки систем на изменения в заявках, заведенных по процессу
	TasksSubscriptions []ExternalSystemSubscriptionParams `json:"tasks_subscriptions"`
}

// RateApplicationRequest defines model for RateApplicationRequest.
type RateApplicationRequest struct {
	Comment *string `json:"comment,omitempty"`
	Rate    *int    `json:"rate,omitempty"`
}

// Type of execution info
type RequestExecutionInfoType string

// Executor request info params
type RequestInfoUpdateParams struct {
	Attachments []Attachment `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// executor login
	ExecutorLogin string `json:"executorLogin"`

	// Type of execution info
	ReqType RequestExecutionInfoType `json:"reqType"`
}

// ResponsePipelineSearch defines model for ResponsePipelineSearch.
type ResponsePipelineSearch struct {
	// list of pipelines
	Items []SearchPipelineItem `json:"items"`
	Total int                  `json:"total"`
}

// RunNewVersionByPrevVersionRequest defines model for RunNewVersionByPrevVersionRequest.
type RunNewVersionByPrevVersionRequest struct {
	ApplicationBody  map[string]interface{}                 `json:"application_body"`
	AttachmentFields []Attachment                           `json:"attachment_fields"`
	Description      string                                 `json:"description"`
	Keys             RunNewVersionByPrevVersionRequest_Keys `json:"keys"`
	WorkNumber       string                                 `json:"work_number"`
}

// RunNewVersionByPrevVersionRequest_Keys defines model for RunNewVersionByPrevVersionRequest.Keys.
type RunNewVersionByPrevVersionRequest_Keys struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RunPipelineBody defines model for RunPipelineBody.
type RunPipelineBody map[string]interface{}

// RunResponse defines model for RunResponse.
type RunResponse struct {
	Errors     []string               `json:"errors"`
	Output     map[string]interface{} `json:"output"`
	PipelineId string                 `json:"pipeline_id"`
	Status     string                 `json:"status"`
	WorkNumber string                 `json:"work_number"`
}

// RunVersionBody defines model for RunVersionBody.
type RunVersionBody map[string]interface{}

// RunVersionsByPipelineIdRequest defines model for RunVersionsByPipelineIdRequest.
type RunVersionsByPipelineIdRequest struct {
	ApplicationBody   map[string]interface{}              `json:"application_body"`
	AttachmentFields  []Attachment                        `json:"attachment_fields"`
	Description       string                              `json:"description"`
	IsTestApplication *bool                               `json:"is_test_application,omitempty"`
	Keys              RunVersionsByPipelineIdRequest_Keys `json:"keys"`
	PipelineId        string                              `json:"pipeline_id"`
}

// RunVersionsByPipelineIdRequest_Keys defines model for RunVersionsByPipelineIdRequest.Keys.
type RunVersionsByPipelineIdRequest_Keys struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ScenarioVersionInfoList defines model for ScenarioVersionInfoList.
type ScenarioVersionInfoList []EriusVersionInfo

// SD Application params
type SdApplicationParams struct {
	// Template application ID
	BlueprintId string `json:"blueprint_id"`
}

// SearchPipelineItem defines model for SearchPipelineItem.
type SearchPipelineItem struct {
	// Имя пайплайна
	Name *string `json:"name,omitempty"`

	// ID пайплайна
	PipelineId *string `json:"pipeline_id,omitempty"`
}

// ShapeEntity defines model for ShapeEntity.
type ShapeEntity struct {
	Icon  string `json:"icon"`
	Id    int    `json:"id"`
	Title string `json:"title"`
}

// Singature params
type SignParams struct {
	// reject after expire sla
	AutoReject *bool `json:"autoReject,omitempty"`

	// Is active SLA
	CheckSLA *bool `json:"checkSLA,omitempty"`

	// List of accessibility properties for forms
	FormsAccessibility []FormsAccessibility `json:"formsAccessibility"`
	SignatureCarrier   *SignatureCarrier    `json:"signatureCarrier,omitempty"`
	SignatureType      SignatureType        `json:"signatureType"`

	// Signer value (depends on type)
	Signer *string `json:"signer,omitempty"`

	// Singer group id in SD
	SignerGroupId *string `json:"signerGroupId,omitempty"`

	// Path to singer group id
	SignerGroupIdPath *string `json:"signerGroupIdPath,omitempty"`

	// Signer group name in SD
	SignerGroupName *string `json:"signerGroupName,omitempty"`

	// Signer type:
	//   * user - Single user
	//   * group - Group ID
	//   * FromSchema - Selected by initiator
	SignerType SignerType `json:"signerType"`

	// Count of singers which will participate in signing will depends of signing type. 'Any of' will check only first sign action, when 'all of' will be waiting for all signers.
	SigningRule *SigningRule `json:"signingRule,omitempty"`

	// Sign SLA (in working hours)
	Sla *int `json:"sla,omitempty"`

	// Рабочий режим
	WorkType *WorkType `json:"workType,omitempty"`
}

// Sign update params
type SignUpdateParams struct {
	Attachments *[]Attachment `json:"attachments,omitempty"`

	// Comment from signer
	Comment *string `json:"comment,omitempty"`

	// Approver decision:
	//  * signed - Согласовано
	//  * rejected - Отклонено
	//  * error - Произошла ошибка
	Decision SignDecision `json:"decision"`
}

// SignatureCarrier defines model for SignatureCarrier.
type SignatureCarrier string

// SignatureType defines model for SignatureType.
type SignatureType string

// Signer type:
//   - user - Single user
//   - group - Group ID
//   - FromSchema - Selected by initiator
type SignerType string

// Count of singers which will participate in signing will depends of signing type. 'Any of' will check only first sign action, when 'all of' will be waiting for all signers.
type SigningRule string

// Socket object
type Socket struct {
	// action type
	ActionType *SocketActionType `json:"actionType,omitempty"`

	// Id of socket
	Id string `json:"id"`

	// IDs of next blocks
	NextBlockIds *[]string `json:"nextBlockIds,omitempty"`

	// User-friendly title of socket for user
	Title *string `json:"title,omitempty"`
}

// action type
type SocketActionType string

// Step defines model for Step.
type Step struct {
	Errors   []string               `json:"errors"`
	HasError bool                   `json:"has_error"`
	Name     string                 `json:"name"`
	State    map[string]interface{} `json:"state"`

	// Task step execution status
	Status  StepStatus             `json:"status"`
	Steps   []string               `json:"steps"`
	Storage map[string]interface{} `json:"storage"`
	Time    string                 `json:"time"`
	Type    string                 `json:"type"`
}

// Task step execution status
type StepStatus string

// Basic string operand, can provide working compare types for this type
type StringOperand struct {
	DataType    StringOperandDataType    `json:"dataType"`
	OperandType StringOperandOperandType `json:"operandType"`
}

// StringOperandDataType defines model for StringOperand.DataType.
type StringOperandDataType string

// StringOperandOperandType defines model for StringOperand.OperandType.
type StringOperandOperandType string

// TaskMeanSolveTime defines model for TaskMeanSolveTime.
type TaskMeanSolveTime struct {
	MeanWorkHours float32 `json:"meanWorkHours"`
}

// TaskStatus defines model for TaskStatus.
type TaskStatus struct {
	FinishedAt time.Time `json:"finished_at"`

	// Task status
	Status string `json:"status"`

	// Task work number
	WorkNumber string `json:"work_number"`
}

// TaskUpdate defines model for TaskUpdate.
type TaskUpdate struct {
	Action TaskUpdateAction `json:"action"`

	// Task update params
	Parameters interface{} `json:"parameters"`
}

// TaskUpdateAction defines model for TaskUpdate.Action.
type TaskUpdateAction string

// TasksStop defines model for TasksStop.
type TasksStop struct {
	// Array of work numbers
	Tasks []string `json:"tasks"`
}

// TasksStopped defines model for TasksStopped.
type TasksStopped struct {
	Tasks []TaskStatus `json:"tasks"`
}

// Timer params
type TimerParams struct {
	// duration for timer
	Duration string `json:"duration"`
}

// UsageResponse defines model for UsageResponse.
type UsageResponse struct {
	// Имя блока
	Name      string   `json:"name"`
	Pipelines []UsedBy `json:"pipelines"`
	Used      bool     `json:"used"`
}

// UsedBy defines model for UsedBy.
type UsedBy struct {
	// ID сценария
	Id string `json:"id"`

	// Имя сценария
	Name string `json:"name"`
}

// Рабочий режим
type WorkType string

// Action defines model for action.
type Action struct {
	// Возможность прикреплять вложение к действию
	AttachmentsEnabled bool `json:"attachments_enabled"`

	// Тип отображаемой кнопки (primary, secondary, other, none)
	ButtonType string `json:"button_type"`

	// Возможность прикреплять комментарий к действию
	CommentEnabled bool `json:"comment_enabled"`

	// UUID действия
	Id string `json:"id"`

	// Дополнительные параметры действия
	Params *Action_Params `json:"params,omitempty"`

	// Человекочитаемое наименование действия
	Title *string `json:"title,omitempty"`
}

// Дополнительные параметры действия
type Action_Params struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Approver decision:
//   - approved - Согласовать
//   - rejected - Отклонить
type AdditionalApproverDecision string

// Approver decision:
//   - approve - Согласовать
//   - reject - Отклонить
//   - viewed - Ознакомлен
//   - informed - Проинформирован
//   - sign - Подписать
//   - confirm - Утвердить
//   - sign_ukep - Подписать УКЭП
type ApproverDecision string

// Block type (language)
type BlockType string

// Used operator to compare bool operands
type CompareBooleanOperator string

// Used operator to compare date operands
type CompareDateOperator string

// Used operator to compare integer operands
type CompareIntegerOperator string

// Used operator to compare number operands
type CompareNumberOperator string

// Used operator to compare string operands
type CompareStringOperator string

// EriusTaskResponse defines model for eriusTaskResponse.
type EriusTaskResponse struct {
	// Логин инициатора
	Author string `json:"author"`

	// Доступные действия
	AvailableActions *[]Action `json:"available_actions,omitempty"`

	// ID шаблона SD, на основании которого запускалась заявка
	BlueprintId string `json:"blueprint_id"`

	// Запускалась ли заявка в режиме отладки
	Debug bool `json:"debug"`

	// Описание заявки (основной текст)
	Description string `json:"description"`

	// Время окончания заявки
	FinishedAt *string `json:"finished_at,omitempty"`

	// Task human readable status
	HumanStatus TaskHumanStatus `json:"human_status"`

	// ID заявки
	Id string `json:"id"`

	// Время последнего изменения
	LastChangedAt string `json:"last_changed_at"`

	// Название заявки
	Name string `json:"name"`

	// Параметры заявки
	Parameters map[string]interface{} `json:"parameters"`

	// Плановая дата завершения процесса
	ProcessDeadline string `json:"process_deadline"`

	// Оценка для выполненной заявки
	Rate int `json:"rate"`

	// Комментарий к оценке
	RateComment string `json:"rate_comment"`

	// Время начала исполнения заявки
	StartedAt string `json:"started_at"`

	// Технический статус заявки
	Status EriusTaskResponseStatus `json:"status"`

	// Комментарий статуса
	StatusComment string             `json:"status_comment"`
	Steps         []TaskResponseStep `json:"steps"`

	// Версия процесса заявки
	VersionId string `json:"version_id"`

	// Номер заявки
	WorkNumber string `json:"work_number"`
}

// Технический статус заявки
type EriusTaskResponseStatus string

// Executor decision:
//   - executed - executor executed block
//   - rejected - executor rejected block
type ExecutionDecision string

// HttpError defines model for httpError.
type HttpError struct {
	Description *string `json:"description,omitempty"`
	Error       *string `json:"error,omitempty"`
	StatusCode  *int    `json:"status_code,omitempty"`
}

// HttpResponse defines model for httpResponse.
type HttpResponse struct {
	Data       *map[string]interface{} `json:"data,omitempty"`
	StatusCode int                     `json:"status_code"`
}

// Operand for comparison
type Operand interface{}

// Pipeline defines model for pipeline.
type Pipeline struct {
	Blocks     Pipeline_Blocks `json:"blocks"`
	Entrypoint string          `json:"entrypoint"`
}

// Pipeline_Blocks defines model for Pipeline.Blocks.
type Pipeline_Blocks struct {
	AdditionalProperties map[string]EriusFunc `json:"-"`
}

// Tag status:
//   - 1 - Draft
//   - 2 - Approved
//   - 3 - Deleted
//   - 4 - Rejected
//   - 5 - On approve
type ScenarioStatus int

// Approver decision:
//   - signed - Согласовано
//   - rejected - Отклонено
//   - error - Произошла ошибка
type SignDecision string

// Task human readable status
type TaskHumanStatus string

// TaskResponseStep defines model for taskResponseStep.
type TaskResponseStep struct {
	// Массив ошибок
	Errors *[]string `json:"errors,omitempty"`

	// Была ли ошибка
	HasError *bool `json:"has_error,omitempty"`

	// Является ли пользователь, запрашивающий заявку, делегатом кого-либо на этом шаге
	IsDelegateOfAnyStepMember *bool `json:"is_delegate_of_any_step_member,omitempty"`

	// Наименование шага
	Name *string `json:"name,omitempty"`

	// Короткое название ноды
	ShortTitle *string `json:"short_title,omitempty"`

	// Объект состояния
	State *map[string]interface{} `json:"state,omitempty"`

	// Статус шага
	Status  *string                 `json:"status,omitempty"`
	Steps   *[]string               `json:"steps,omitempty"`
	Storage *map[string]interface{} `json:"storage,omitempty"`
	Time    *string                 `json:"time,omitempty"`
	Type    *string                 `json:"type,omitempty"`
}

// ValueOperand defines model for valueOperand.
type ValueOperand struct {
	// Embedded fields due to inline allOf schema
	Value string `json:"value"`
	// Embedded fields due to inline allOf schema
}

// VariableOperand defines model for variableOperand.
type VariableOperand struct {
	// Embedded fields due to inline allOf schema
	VariableRef string `json:"variableRef"`
	// Embedded fields due to inline allOf schema
}

// RateApplicationJSONBody defines parameters for RateApplication.
type RateApplicationJSONBody RateApplicationRequest

// StartDebugTaskJSONBody defines parameters for StartDebugTask.
type StartDebugTaskJSONBody DebugRunRequest

// GetFormsChangelogParams defines parameters for GetFormsChangelog.
type GetFormsChangelogParams struct {
	// Work number
	WorkNumber string `json:"work_number"`

	// Id of form block (name)
	BlockId string `json:"block_id"`
}

// GetTasksForMonitoringParams defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParams struct {
	PerPage    *int                                   `json:"per_page,omitempty"`
	Page       *int                                   `json:"page,omitempty"`
	SortColumn *GetTasksForMonitoringParamsSortColumn `json:"sort.column,omitempty"`
	SortOrder  *GetTasksForMonitoringParamsSortOrder  `json:"sort.order,omitempty"`

	// Фильтр по work_number, наименованию процесса, логину инициатора
	Filter *string `json:"filter,omitempty"`

	// Фильтровать по дате, начало периода
	FromDate *string `json:"from_date,omitempty"`

	// Фильтровать по дате, конец периода
	ToDate *string `json:"to_date,omitempty"`

	// Фильтровать по статусу заявки
	Status *[]GetTasksForMonitoringParamsStatus `json:"status,omitempty"`
}

// GetTasksForMonitoringParamsSortColumn defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParamsSortColumn string

// GetTasksForMonitoringParamsSortOrder defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParamsSortOrder string

// GetTasksForMonitoringParamsStatus defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParamsStatus string

// SaveVersionMainSettingsJSONBody defines parameters for SaveVersionMainSettings.
type SaveVersionMainSettingsJSONBody ProcessSettings

// ListPipelinesParams defines parameters for ListPipelines.
type ListPipelinesParams struct {
	// Show my pipelines only
	My *bool `json:"my,omitempty"`

	// Show published pipelines only
	IsPublished *bool `json:"is_published,omitempty"`
	PerPage     *int  `json:"per_page,omitempty"`
	Page        *int  `json:"page,omitempty"`

	// Фильтр по имени pipeline
	Filter *string `json:"filter,omitempty"`
}

// CreatePipelineJSONBody defines parameters for CreatePipeline.
type CreatePipelineJSONBody EriusScenario

// CopyPipelineJSONBody defines parameters for CopyPipeline.
type CopyPipelineJSONBody EriusScenario

// PipelineNameExistsParams defines parameters for PipelineNameExists.
type PipelineNameExistsParams struct {
	// Pipeline Name
	Name string `json:"name"`

	// Check for not deleted pipelines
	CheckNotDeleted bool `json:"checkNotDeleted"`
}

// SearchPipelinesParams defines parameters for SearchPipelines.
type SearchPipelinesParams struct {
	// имя пайплайна
	PipelineName *string `json:"pipelineName,omitempty"`

	// id пайплайна
	PipelineId *string `json:"pipelineId,omitempty"`

	// страница для отображения
	Page *int `json:"page,omitempty"`

	// сколько отображать на одной странице
	PerPage *int `json:"perPage,omitempty"`
}

// EditVersionJSONBody defines parameters for EditVersion.
type EditVersionJSONBody EriusScenario

// CreatePipelineVersionJSONBody defines parameters for CreatePipelineVersion.
type CreatePipelineVersionJSONBody EriusScenario

// SaveVersionSettingsJSONBody defines parameters for SaveVersionSettings.
type SaveVersionSettingsJSONBody ProcessSettings

// SaveVersionSettingsParams defines parameters for SaveVersionSettings.
type SaveVersionSettingsParams struct {
	// Флаг JSON-схемы, которую нужно сохранить
	SchemaFlag *SaveVersionSettingsParamsSchemaFlag `json:"schema_flag,omitempty"`
}

// SaveVersionSettingsParamsSchemaFlag defines parameters for SaveVersionSettings.
type SaveVersionSettingsParamsSchemaFlag string

// SaveVersionTaskSubscriptionSettingsJSONBody defines parameters for SaveVersionTaskSubscriptionSettings.
type SaveVersionTaskSubscriptionSettingsJSONBody []ExternalSystemSubscriptionParams

// AddExternalSystemToVersionJSONBody defines parameters for AddExternalSystemToVersion.
type AddExternalSystemToVersionJSONBody ExternalSystemId

// SaveExternalSystemSettingsJSONBody defines parameters for SaveExternalSystemSettings.
type SaveExternalSystemSettingsJSONBody ExternalSystem

// SaveExternalSystemSettingsParams defines parameters for SaveExternalSystemSettings.
type SaveExternalSystemSettingsParams struct {
	// Флаг JSON-схемы, которую нужно сохранить
	SchemaFlag *SaveExternalSystemSettingsParamsSchemaFlag `json:"schema_flag,omitempty"`
}

// SaveExternalSystemSettingsParamsSchemaFlag defines parameters for SaveExternalSystemSettings.
type SaveExternalSystemSettingsParamsSchemaFlag string

// SaveExternalSystemEndSettingsJSONBody defines parameters for SaveExternalSystemEndSettings.
type SaveExternalSystemEndSettingsJSONBody EndSystemSettings

// AllowRunAsOthersJSONBody defines parameters for AllowRunAsOthers.
type AllowRunAsOthersJSONBody AllowRunAsOthers

// RunNewVersionByPrevVersionJSONBody defines parameters for RunNewVersionByPrevVersion.
type RunNewVersionByPrevVersionJSONBody RunNewVersionByPrevVersionRequest

// RunVersionJSONBody defines parameters for RunVersion.
type RunVersionJSONBody RunVersionBody

// RunVersionsByPipelineIdJSONBody defines parameters for RunVersionsByPipelineId.
type RunVersionsByPipelineIdJSONBody RunVersionsByPipelineIdRequest

// RunPipelineJSONBody defines parameters for RunPipeline.
type RunPipelineJSONBody RunPipelineBody

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody EriusTagInfo

// EditTagJSONBody defines parameters for EditTag.
type EditTagJSONBody EriusTagInfo

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Pipeline name
	Name *string `json:"name,omitempty"`

	// Task IDs
	TaskIDs *[]string `json:"taskIDs,omitempty"`

	// Order
	Order *string `json:"order,omitempty"`

	// Limit
	Limit *int `json:"limit,omitempty"`

	// Offset
	Offset   *int                    `json:"offset,omitempty"`
	Created  *Created                `json:"created,omitempty"`
	Archived *bool                   `json:"archived,omitempty"`
	SelectAs *GetTasksParamsSelectAs `json:"selectAs,omitempty"`

	// get tasks with status wait or done
	ForCarousel *bool `json:"forCarousel,omitempty"`

	// get tasks with different statuses
	Status *[]string `json:"status,omitempty"`

	// receiver login
	Receiver *string `json:"receiver,omitempty"`

	// filter for attachments
	HasAttachments *bool `json:"hasAttachments,omitempty"`

	// filter for initiators
	InitiatorLogins *[]string `json:"initiatorLogins,omitempty"`

	// filter in process by logins
	ProcessingLogins *[]string `json:"processingLogins,omitempty"`

	// filter in process by group ids
	ProcessingGroupIds *[]string `json:"processingGroupIds,omitempty"`

	// filter by processed logins
	ProcessedLogins *[]string `json:"processedLogins,omitempty"`

	// filter by processed group ids
	ProcessedGroupIds *[]string `json:"processedGroupIds,omitempty"`
	SelectFor         *string   `json:"selectFor,omitempty"`

	// filter type assigned
	ExecutorTypeAssigned *GetTasksParamsExecutorTypeAssigned `json:"executorTypeAssigned,omitempty"`

	// signature carrier (used for selectAs = signer_jur)
	SignatureCarrier *GetTasksParamsSignatureCarrier `json:"signatureCarrier,omitempty"`
}

// GetTasksParamsSelectAs defines parameters for GetTasks.
type GetTasksParamsSelectAs string

// GetTasksParamsExecutorTypeAssigned defines parameters for GetTasks.
type GetTasksParamsExecutorTypeAssigned string

// GetTasksParamsSignatureCarrier defines parameters for GetTasks.
type GetTasksParamsSignatureCarrier string

// StopTasksJSONBody defines parameters for StopTasks.
type StopTasksJSONBody TasksStop

// UpdateTaskJSONBody defines parameters for UpdateTask.
type UpdateTaskJSONBody TaskUpdate

// RateApplicationJSONRequestBody defines body for RateApplication for application/json ContentType.
type RateApplicationJSONRequestBody RateApplicationJSONBody

// StartDebugTaskJSONRequestBody defines body for StartDebugTask for application/json ContentType.
type StartDebugTaskJSONRequestBody StartDebugTaskJSONBody

// SaveVersionMainSettingsJSONRequestBody defines body for SaveVersionMainSettings for application/json ContentType.
type SaveVersionMainSettingsJSONRequestBody SaveVersionMainSettingsJSONBody

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody CreatePipelineJSONBody

// CopyPipelineJSONRequestBody defines body for CopyPipeline for application/json ContentType.
type CopyPipelineJSONRequestBody CopyPipelineJSONBody

// EditVersionJSONRequestBody defines body for EditVersion for application/json ContentType.
type EditVersionJSONRequestBody EditVersionJSONBody

// CreatePipelineVersionJSONRequestBody defines body for CreatePipelineVersion for application/json ContentType.
type CreatePipelineVersionJSONRequestBody CreatePipelineVersionJSONBody

// SaveVersionSettingsJSONRequestBody defines body for SaveVersionSettings for application/json ContentType.
type SaveVersionSettingsJSONRequestBody SaveVersionSettingsJSONBody

// SaveVersionTaskSubscriptionSettingsJSONRequestBody defines body for SaveVersionTaskSubscriptionSettings for application/json ContentType.
type SaveVersionTaskSubscriptionSettingsJSONRequestBody SaveVersionTaskSubscriptionSettingsJSONBody

// AddExternalSystemToVersionJSONRequestBody defines body for AddExternalSystemToVersion for application/json ContentType.
type AddExternalSystemToVersionJSONRequestBody AddExternalSystemToVersionJSONBody

// SaveExternalSystemSettingsJSONRequestBody defines body for SaveExternalSystemSettings for application/json ContentType.
type SaveExternalSystemSettingsJSONRequestBody SaveExternalSystemSettingsJSONBody

// SaveExternalSystemEndSettingsJSONRequestBody defines body for SaveExternalSystemEndSettings for application/json ContentType.
type SaveExternalSystemEndSettingsJSONRequestBody SaveExternalSystemEndSettingsJSONBody

// AllowRunAsOthersJSONRequestBody defines body for AllowRunAsOthers for application/json ContentType.
type AllowRunAsOthersJSONRequestBody AllowRunAsOthersJSONBody

// RunNewVersionByPrevVersionJSONRequestBody defines body for RunNewVersionByPrevVersion for application/json ContentType.
type RunNewVersionByPrevVersionJSONRequestBody RunNewVersionByPrevVersionJSONBody

// RunVersionJSONRequestBody defines body for RunVersion for application/json ContentType.
type RunVersionJSONRequestBody RunVersionJSONBody

// RunVersionsByPipelineIdJSONRequestBody defines body for RunVersionsByPipelineId for application/json ContentType.
type RunVersionsByPipelineIdJSONRequestBody RunVersionsByPipelineIdJSONBody

// RunPipelineJSONRequestBody defines body for RunPipeline for application/json ContentType.
type RunPipelineJSONRequestBody RunPipelineJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// EditTagJSONRequestBody defines body for EditTag for application/json ContentType.
type EditTagJSONRequestBody EditTagJSONBody

// StopTasksJSONRequestBody defines body for StopTasks for application/json ContentType.
type StopTasksJSONRequestBody StopTasksJSONBody

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody UpdateTaskJSONBody

// Getter for additional properties for AllUsageResponse_Pipelines. Returns the specified
// element and whether it was found
func (a AllUsageResponse_Pipelines) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AllUsageResponse_Pipelines
func (a *AllUsageResponse_Pipelines) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AllUsageResponse_Pipelines to handle AdditionalProperties
func (a *AllUsageResponse_Pipelines) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AllUsageResponse_Pipelines to handle AdditionalProperties
func (a AllUsageResponse_Pipelines) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for BlockContextResponse_Blocks. Returns the specified
// element and whether it was found
func (a BlockContextResponse_Blocks) Get(fieldName string) (value MonitoringBlockOutput, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for BlockContextResponse_Blocks
func (a *BlockContextResponse_Blocks) Set(fieldName string, value MonitoringBlockOutput) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]MonitoringBlockOutput)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for BlockContextResponse_Blocks to handle AdditionalProperties
func (a *BlockContextResponse_Blocks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]MonitoringBlockOutput)
		for fieldName, fieldBuf := range object {
			var fieldVal MonitoringBlockOutput
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for BlockContextResponse_Blocks to handle AdditionalProperties
func (a BlockContextResponse_Blocks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EriusFunc_Next. Returns the specified
// element and whether it was found
func (a EriusFunc_Next) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EriusFunc_Next
func (a *EriusFunc_Next) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EriusFunc_Next to handle AdditionalProperties
func (a *EriusFunc_Next) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EriusFunc_Next to handle AdditionalProperties
func (a EriusFunc_Next) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JSONSchemaProperties. Returns the specified
// element and whether it was found
func (a JSONSchemaProperties) Get(fieldName string) (value struct {
	// Default value
	Default *interface{} `json:"default,omitempty"`

	// Description of param
	Description *string `json:"description,omitempty"`

	// Format of param
	Format *string `json:"format,omitempty"`

	// Format of param
	Global *string `json:"global,omitempty"`

	// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
	Items *ArrayItems `json:"items,omitempty"`

	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Properties *JSONSchemaProperties `json:"properties,omitempty"`

	// Required fields for type = object
	Required *[]string `json:"required,omitempty"`

	// Title of param
	Title string `json:"title"`

	// Type of param
	Type string `json:"type"`

	// Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
	Value *string `json:"value,omitempty"`
}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JSONSchemaProperties
func (a *JSONSchemaProperties) Set(fieldName string, value struct {
	// Default value
	Default *interface{} `json:"default,omitempty"`

	// Description of param
	Description *string `json:"description,omitempty"`

	// Format of param
	Format *string `json:"format,omitempty"`

	// Format of param
	Global *string `json:"global,omitempty"`

	// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
	Items *ArrayItems `json:"items,omitempty"`

	// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Properties *JSONSchemaProperties `json:"properties,omitempty"`

	// Required fields for type = object
	Required *[]string `json:"required,omitempty"`

	// Title of param
	Title string `json:"title"`

	// Type of param
	Type string `json:"type"`

	// Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
	Value *string `json:"value,omitempty"`
}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]struct {
			// Default value
			Default *interface{} `json:"default,omitempty"`

			// Description of param
			Description *string `json:"description,omitempty"`

			// Format of param
			Format *string `json:"format,omitempty"`

			// Format of param
			Global *string `json:"global,omitempty"`

			// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
			Items *ArrayItems `json:"items,omitempty"`

			// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
			Properties *JSONSchemaProperties `json:"properties,omitempty"`

			// Required fields for type = object
			Required *[]string `json:"required,omitempty"`

			// Title of param
			Title string `json:"title"`

			// Type of param
			Type string `json:"type"`

			// Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
			Value *string `json:"value,omitempty"`
		})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JSONSchemaProperties to handle AdditionalProperties
func (a *JSONSchemaProperties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]struct {
			// Default value
			Default *interface{} `json:"default,omitempty"`

			// Description of param
			Description *string `json:"description,omitempty"`

			// Format of param
			Format *string `json:"format,omitempty"`

			// Format of param
			Global *string `json:"global,omitempty"`

			// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
			Items *ArrayItems `json:"items,omitempty"`

			// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
			Properties *JSONSchemaProperties `json:"properties,omitempty"`

			// Required fields for type = object
			Required *[]string `json:"required,omitempty"`

			// Title of param
			Title string `json:"title"`

			// Type of param
			Type string `json:"type"`

			// Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
			Value *string `json:"value,omitempty"`
		})
		for fieldName, fieldBuf := range object {
			var fieldVal struct {
				// Default value
				Default *interface{} `json:"default,omitempty"`

				// Description of param
				Description *string `json:"description,omitempty"`

				// Format of param
				Format *string `json:"format,omitempty"`

				// Format of param
				Global *string `json:"global,omitempty"`

				// Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
				Items *ArrayItems `json:"items,omitempty"`

				// Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
				Properties *JSONSchemaProperties `json:"properties,omitempty"`

				// Required fields for type = object
				Required *[]string `json:"required,omitempty"`

				// Title of param
				Title string `json:"title"`

				// Type of param
				Type string `json:"type"`

				// Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
				Value *string `json:"value,omitempty"`
			}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JSONSchemaProperties to handle AdditionalProperties
func (a JSONSchemaProperties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MonitoringParamsResponse_Inputs. Returns the specified
// element and whether it was found
func (a MonitoringParamsResponse_Inputs) Get(fieldName string) (value MonitoringBlockParam, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MonitoringParamsResponse_Inputs
func (a *MonitoringParamsResponse_Inputs) Set(fieldName string, value MonitoringBlockParam) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]MonitoringBlockParam)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MonitoringParamsResponse_Inputs to handle AdditionalProperties
func (a *MonitoringParamsResponse_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]MonitoringBlockParam)
		for fieldName, fieldBuf := range object {
			var fieldVal MonitoringBlockParam
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MonitoringParamsResponse_Inputs to handle AdditionalProperties
func (a MonitoringParamsResponse_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MonitoringParamsResponse_Outputs. Returns the specified
// element and whether it was found
func (a MonitoringParamsResponse_Outputs) Get(fieldName string) (value MonitoringBlockParam, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MonitoringParamsResponse_Outputs
func (a *MonitoringParamsResponse_Outputs) Set(fieldName string, value MonitoringBlockParam) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]MonitoringBlockParam)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MonitoringParamsResponse_Outputs to handle AdditionalProperties
func (a *MonitoringParamsResponse_Outputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]MonitoringBlockParam)
		for fieldName, fieldBuf := range object {
			var fieldVal MonitoringBlockParam
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MonitoringParamsResponse_Outputs to handle AdditionalProperties
func (a MonitoringParamsResponse_Outputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunNewVersionByPrevVersionRequest_Keys. Returns the specified
// element and whether it was found
func (a RunNewVersionByPrevVersionRequest_Keys) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunNewVersionByPrevVersionRequest_Keys
func (a *RunNewVersionByPrevVersionRequest_Keys) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunNewVersionByPrevVersionRequest_Keys to handle AdditionalProperties
func (a *RunNewVersionByPrevVersionRequest_Keys) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunNewVersionByPrevVersionRequest_Keys to handle AdditionalProperties
func (a RunNewVersionByPrevVersionRequest_Keys) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunVersionsByPipelineIdRequest_Keys. Returns the specified
// element and whether it was found
func (a RunVersionsByPipelineIdRequest_Keys) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunVersionsByPipelineIdRequest_Keys
func (a *RunVersionsByPipelineIdRequest_Keys) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunVersionsByPipelineIdRequest_Keys to handle AdditionalProperties
func (a *RunVersionsByPipelineIdRequest_Keys) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunVersionsByPipelineIdRequest_Keys to handle AdditionalProperties
func (a RunVersionsByPipelineIdRequest_Keys) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Action_Params. Returns the specified
// element and whether it was found
func (a Action_Params) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Action_Params
func (a *Action_Params) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Action_Params to handle AdditionalProperties
func (a *Action_Params) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Action_Params to handle AdditionalProperties
func (a Action_Params) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Pipeline_Blocks. Returns the specified
// element and whether it was found
func (a Pipeline_Blocks) Get(fieldName string) (value EriusFunc, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Pipeline_Blocks
func (a *Pipeline_Blocks) Set(fieldName string, value EriusFunc) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EriusFunc)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Pipeline_Blocks to handle AdditionalProperties
func (a *Pipeline_Blocks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EriusFunc)
		for fieldName, fieldBuf := range object {
			var fieldVal EriusFunc
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Pipeline_Blocks to handle AdditionalProperties
func (a Pipeline_Blocks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// rate application
	// (POST /application/rate/{workNumber})
	RateApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// Check if any steps breached SLA
	// (GET /cron/sla)
	CheckBreachSLA(w http.ResponseWriter, r *http.Request)
	// Start debug task
	// (POST /debug/run)
	StartDebugTask(w http.ResponseWriter, r *http.Request)
	// Debug task
	// (GET /debug/{workNumber})
	DebugTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get approve action names dictionary
	// (GET /dictionaries/approve-action-names)
	GetApproveActionNames(w http.ResponseWriter, r *http.Request)
	// Get approve statuses dictionary
	// (GET /dictionaries/approve-statuses)
	GetApproveStatuses(w http.ResponseWriter, r *http.Request)
	// Get list of node decisions
	// (GET /dictionaries/get-node-decisions)
	GetNodeDecisions(w http.ResponseWriter, r *http.Request)
	// Get task event json schema
	// (GET /dictionaries/schema/task-event)
	GetTaskEventSchema(w http.ResponseWriter, r *http.Request)
	// Get forms changelog
	// (GET /forms/changelog)
	GetFormsChangelog(w http.ResponseWriter, r *http.Request, params GetFormsChangelogParams)
	// Get list of modules
	// (GET /modules)
	GetModules(w http.ResponseWriter, r *http.Request)
	// Get list of modules usage
	// (GET /modules/usage)
	AllModulesUsage(w http.ResponseWriter, r *http.Request)
	// Usage of module in pipelines
	// (GET /modules/{moduleName}/usage)
	ModuleUsage(w http.ResponseWriter, r *http.Request, moduleName string)
	// Get tasks for monitoring
	// (GET /monitoring/tasks)
	GetTasksForMonitoring(w http.ResponseWriter, r *http.Request, params GetTasksForMonitoringParams)
	// Получение контекста блоков
	// (GET /monitoring/tasks/block/{blockId}/context)
	GetBlockContext(w http.ResponseWriter, r *http.Request, blockId string)
	// Get inputs and outputs of block
	// (GET /monitoring/tasks/block/{blockId}/params)
	GetMonitoringTasksBlockBlockIdParams(w http.ResponseWriter, r *http.Request, blockId string)
	// Get task for monitoring
	// (GET /monitoring/tasks/{workNumber})
	GetMonitoringTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Save process main settings
	// (POST /pipeline/version/{versionID}/settings/main)
	SaveVersionMainSettings(w http.ResponseWriter, r *http.Request, versionID string)
	// Get list of pipelines
	// (GET /pipelines)
	ListPipelines(w http.ResponseWriter, r *http.Request, params ListPipelinesParams)
	// Create pipeline
	// (POST /pipelines)
	CreatePipeline(w http.ResponseWriter, r *http.Request)
	// Creates copy of pipeline
	// (POST /pipelines/copy)
	CopyPipeline(w http.ResponseWriter, r *http.Request)
	// Check if name of pipeline exists
	// (GET /pipelines/name-exists)
	PipelineNameExists(w http.ResponseWriter, r *http.Request, params PipelineNameExistsParams)
	// search list of pipelines
	// (GET /pipelines/search)
	SearchPipelines(w http.ResponseWriter, r *http.Request, params SearchPipelinesParams)
	// Edit Draft
	// (PUT /pipelines/version)
	EditVersion(w http.ResponseWriter, r *http.Request)
	// Delete Version
	// (DELETE /pipelines/version/{ID})
	DeleteVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Get pipeline version
	// (GET /pipelines/version/{ID})
	GetPipelineVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Create pipeline version
	// (POST /pipelines/version/{ID})
	CreatePipelineVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Get process settings with a list of external systems
	// (GET /pipelines/version/{versionID}/settings)
	GetVersionSettings(w http.ResponseWriter, r *http.Request, versionID string)
	// Save process settings(start and end schemas)
	// (POST /pipelines/version/{versionID}/settings)
	SaveVersionSettings(w http.ResponseWriter, r *http.Request, versionID string, params SaveVersionSettingsParams)
	// Save process task subscription settings
	// (POST /pipelines/version/{versionID}/settings/task-subscriptions)
	SaveVersionTaskSubscriptionSettings(w http.ResponseWriter, r *http.Request, versionID string)
	// Add external system to version
	// (POST /pipelines/version/{versionID}/system)
	AddExternalSystemToVersion(w http.ResponseWriter, r *http.Request, versionID string)
	// Remove external system from list
	// (DELETE /pipelines/version/{versionID}/system/{systemID})
	RemoveExternalSystem(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Get external system settings
	// (GET /pipelines/version/{versionID}/system/{systemID})
	GetExternalSystemSettings(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Save external system settings
	// (PUT /pipelines/version/{versionID}/system/{systemID})
	SaveExternalSystemSettings(w http.ResponseWriter, r *http.Request, versionID string, systemID string, params SaveExternalSystemSettingsParams)
	// delete external systems settings for end of process
	// (DELETE /pipelines/version/{versionID}/system/{systemID}/endRoutes)
	DeleteExternalSystemEndSettings(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Save external systems settings for end of process
	// (PUT /pipelines/version/{versionID}/system/{systemID}/endRoutes)
	SaveExternalSystemEndSettings(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Allow the system to launch requests from a 3rd party
	// (POST /pipelines/version/{versionID}/system/{systemID}/runAsOthers)
	AllowRunAsOthers(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Delete Pipeline
	// (DELETE /pipelines/{pipelineID})
	DeletePipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get pipeline
	// (GET /pipelines/{pipelineID})
	GetPipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Pipeline Tags
	// (GET /pipelines/{pipelineID}/tags)
	GetPipelineTags(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Detach Tag
	// (DELETE /pipelines/{pipelineID}/tags/{ID})
	DetachTag(w http.ResponseWriter, r *http.Request, pipelineID string, iD string)
	// Attach Tag
	// (PUT /pipelines/{pipelineID}/tags/{ID})
	AttachTag(w http.ResponseWriter, r *http.Request, pipelineID string, iD string)
	// Get pipeline versions
	// (GET /pipelines/{pipelineID}/versions)
	GetPipelineVersions(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Run Version
	// (POST /run/version/new_version)
	RunNewVersionByPrevVersion(w http.ResponseWriter, r *http.Request)
	// Run Version
	// (POST /run/version/{versionID})
	RunVersion(w http.ResponseWriter, r *http.Request, versionID string)
	// Run Version By pipeline_id
	// (POST /run/versions/pipeline_id)
	RunVersionsByPipelineId(w http.ResponseWriter, r *http.Request)
	// Run Pipeline
	// (POST /run/{pipelineID})
	RunPipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Tags
	// (GET /tags)
	GetTags(w http.ResponseWriter, r *http.Request)
	// Create Tag
	// (POST /tags)
	CreateTag(w http.ResponseWriter, r *http.Request)
	// Edit Tag
	// (PUT /tags)
	EditTag(w http.ResponseWriter, r *http.Request)
	// Remove Tag
	// (DELETE /tags/{ID})
	RemoveTag(w http.ResponseWriter, r *http.Request, iD string)
	// Get Tasks
	// (GET /tasks)
	GetTasks(w http.ResponseWriter, r *http.Request, params GetTasksParams)
	// Update tasks by mails
	// (GET /tasks/by-mails)
	UpdateTasksByMails(w http.ResponseWriter, r *http.Request)
	// Get amount of tasks
	// (GET /tasks/count)
	GetTasksCount(w http.ResponseWriter, r *http.Request)
	// Get last debug task for version
	// (GET /tasks/last-by-version/{versionID})
	LastVersionDebugTask(w http.ResponseWriter, r *http.Request, versionID string)
	// Get Task Mean Solve time
	// (GET /tasks/mean/{pipelineId})
	GetTaskMeanSolveTime(w http.ResponseWriter, r *http.Request, pipelineId string)
	// Get Pipeline Tasks
	// (GET /tasks/pipeline/{pipelineID})
	GetPipelineTasks(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Stop tasks by work number
	// (POST /tasks/stop)
	StopTasks(w http.ResponseWriter, r *http.Request)
	// Get Version Tasks
	// (GET /tasks/version/{versionID})
	GetVersionTasks(w http.ResponseWriter, r *http.Request, versionID string)
	// Get Task
	// (GET /tasks/{workNumber})
	GetTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Update Task
	// (POST /tasks/{workNumber})
	UpdateTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get Task form schema
	// (GET /tasks/{workNumber}/{formID}/schema)
	GetTaskFormSchema(w http.ResponseWriter, r *http.Request, workNumber string, formID string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// RateApplication operation middleware
func (siw *ServerInterfaceWrapper) RateApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RateApplication(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CheckBreachSLA operation middleware
func (siw *ServerInterfaceWrapper) CheckBreachSLA(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckBreachSLA(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StartDebugTask operation middleware
func (siw *ServerInterfaceWrapper) StartDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartDebugTask(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DebugTask operation middleware
func (siw *ServerInterfaceWrapper) DebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DebugTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetApproveActionNames operation middleware
func (siw *ServerInterfaceWrapper) GetApproveActionNames(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApproveActionNames(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetApproveStatuses operation middleware
func (siw *ServerInterfaceWrapper) GetApproveStatuses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApproveStatuses(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetNodeDecisions operation middleware
func (siw *ServerInterfaceWrapper) GetNodeDecisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeDecisions(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskEventSchema operation middleware
func (siw *ServerInterfaceWrapper) GetTaskEventSchema(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskEventSchema(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetFormsChangelog operation middleware
func (siw *ServerInterfaceWrapper) GetFormsChangelog(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFormsChangelogParams

	// ------------- Required query parameter "work_number" -------------
	if paramValue := r.URL.Query().Get("work_number"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "work_number"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "work_number", r.URL.Query(), &params.WorkNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "work_number", Err: err})
		return
	}

	// ------------- Required query parameter "block_id" -------------
	if paramValue := r.URL.Query().Get("block_id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "block_id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "block_id", r.URL.Query(), &params.BlockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "block_id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFormsChangelog(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetModules operation middleware
func (siw *ServerInterfaceWrapper) GetModules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetModules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AllModulesUsage operation middleware
func (siw *ServerInterfaceWrapper) AllModulesUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AllModulesUsage(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ModuleUsage operation middleware
func (siw *ServerInterfaceWrapper) ModuleUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "moduleName" -------------
	var moduleName string

	err = runtime.BindStyledParameter("simple", false, "moduleName", chi.URLParam(r, "moduleName"), &moduleName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "moduleName", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModuleUsage(w, r, moduleName)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasksForMonitoring operation middleware
func (siw *ServerInterfaceWrapper) GetTasksForMonitoring(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksForMonitoringParams

	// ------------- Optional query parameter "per_page" -------------
	if paramValue := r.URL.Query().Get("per_page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "per_page", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "per_page", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------
	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.column" -------------
	if paramValue := r.URL.Query().Get("sort.column"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sort.column", r.URL.Query(), &params.SortColumn)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.column", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.order" -------------
	if paramValue := r.URL.Query().Get("sort.order"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sort.order", r.URL.Query(), &params.SortOrder)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.order", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------
	if paramValue := r.URL.Query().Get("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	// ------------- Optional query parameter "from_date" -------------
	if paramValue := r.URL.Query().Get("from_date"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "from_date", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from_date", Err: err})
		return
	}

	// ------------- Optional query parameter "to_date" -------------
	if paramValue := r.URL.Query().Get("to_date"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "to_date", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to_date", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasksForMonitoring(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBlockContext operation middleware
func (siw *ServerInterfaceWrapper) GetBlockContext(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "blockId" -------------
	var blockId string

	err = runtime.BindStyledParameter("simple", false, "blockId", chi.URLParam(r, "blockId"), &blockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "blockId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBlockContext(w, r, blockId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMonitoringTasksBlockBlockIdParams operation middleware
func (siw *ServerInterfaceWrapper) GetMonitoringTasksBlockBlockIdParams(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "blockId" -------------
	var blockId string

	err = runtime.BindStyledParameter("simple", false, "blockId", chi.URLParam(r, "blockId"), &blockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "blockId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMonitoringTasksBlockBlockIdParams(w, r, blockId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMonitoringTask operation middleware
func (siw *ServerInterfaceWrapper) GetMonitoringTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMonitoringTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SaveVersionMainSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveVersionMainSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveVersionMainSettings(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPipelines operation middleware
func (siw *ServerInterfaceWrapper) ListPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPipelinesParams

	// ------------- Optional query parameter "my" -------------
	if paramValue := r.URL.Query().Get("my"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "my", r.URL.Query(), &params.My)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "my", Err: err})
		return
	}

	// ------------- Optional query parameter "is_published" -------------
	if paramValue := r.URL.Query().Get("is_published"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "is_published", r.URL.Query(), &params.IsPublished)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "is_published", Err: err})
		return
	}

	// ------------- Optional query parameter "per_page" -------------
	if paramValue := r.URL.Query().Get("per_page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "per_page", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "per_page", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------
	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------
	if paramValue := r.URL.Query().Get("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPipelines(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePipeline operation middleware
func (siw *ServerInterfaceWrapper) CreatePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipeline(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CopyPipeline operation middleware
func (siw *ServerInterfaceWrapper) CopyPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyPipeline(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PipelineNameExists operation middleware
func (siw *ServerInterfaceWrapper) PipelineNameExists(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PipelineNameExistsParams

	// ------------- Required query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Required query parameter "checkNotDeleted" -------------
	if paramValue := r.URL.Query().Get("checkNotDeleted"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "checkNotDeleted"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "checkNotDeleted", r.URL.Query(), &params.CheckNotDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "checkNotDeleted", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PipelineNameExists(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SearchPipelines operation middleware
func (siw *ServerInterfaceWrapper) SearchPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchPipelinesParams

	// ------------- Optional query parameter "pipelineName" -------------
	if paramValue := r.URL.Query().Get("pipelineName"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "pipelineName", r.URL.Query(), &params.PipelineName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineName", Err: err})
		return
	}

	// ------------- Optional query parameter "pipelineId" -------------
	if paramValue := r.URL.Query().Get("pipelineId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "pipelineId", r.URL.Query(), &params.PipelineId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineId", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------
	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "perPage" -------------
	if paramValue := r.URL.Query().Get("perPage"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "perPage", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "perPage", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchPipelines(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EditVersion operation middleware
func (siw *ServerInterfaceWrapper) EditVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersion(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersion(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) CreatePipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipelineVersion(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetVersionSettings operation middleware
func (siw *ServerInterfaceWrapper) GetVersionSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionSettings(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SaveVersionSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveVersionSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SaveVersionSettingsParams

	// ------------- Optional query parameter "schema_flag" -------------
	if paramValue := r.URL.Query().Get("schema_flag"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "schema_flag", r.URL.Query(), &params.SchemaFlag)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schema_flag", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveVersionSettings(w, r, versionID, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SaveVersionTaskSubscriptionSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveVersionTaskSubscriptionSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveVersionTaskSubscriptionSettings(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddExternalSystemToVersion operation middleware
func (siw *ServerInterfaceWrapper) AddExternalSystemToVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddExternalSystemToVersion(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RemoveExternalSystem operation middleware
func (siw *ServerInterfaceWrapper) RemoveExternalSystem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameter("simple", false, "systemID", chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveExternalSystem(w, r, versionID, systemID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetExternalSystemSettings operation middleware
func (siw *ServerInterfaceWrapper) GetExternalSystemSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameter("simple", false, "systemID", chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExternalSystemSettings(w, r, versionID, systemID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SaveExternalSystemSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveExternalSystemSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameter("simple", false, "systemID", chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SaveExternalSystemSettingsParams

	// ------------- Optional query parameter "schema_flag" -------------
	if paramValue := r.URL.Query().Get("schema_flag"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "schema_flag", r.URL.Query(), &params.SchemaFlag)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schema_flag", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveExternalSystemSettings(w, r, versionID, systemID, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteExternalSystemEndSettings operation middleware
func (siw *ServerInterfaceWrapper) DeleteExternalSystemEndSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameter("simple", false, "systemID", chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteExternalSystemEndSettings(w, r, versionID, systemID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SaveExternalSystemEndSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveExternalSystemEndSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameter("simple", false, "systemID", chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveExternalSystemEndSettings(w, r, versionID, systemID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AllowRunAsOthers operation middleware
func (siw *ServerInterfaceWrapper) AllowRunAsOthers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameter("simple", false, "systemID", chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AllowRunAsOthers(w, r, versionID, systemID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePipeline operation middleware
func (siw *ServerInterfaceWrapper) DeletePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipeline operation middleware
func (siw *ServerInterfaceWrapper) GetPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineTags operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTags(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachTag operation middleware
func (siw *ServerInterfaceWrapper) DetachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachTag(w, r, pipelineID, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachTag operation middleware
func (siw *ServerInterfaceWrapper) AttachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachTag(w, r, pipelineID, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineVersions operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersions(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunNewVersionByPrevVersion operation middleware
func (siw *ServerInterfaceWrapper) RunNewVersionByPrevVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunNewVersionByPrevVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunVersion operation middleware
func (siw *ServerInterfaceWrapper) RunVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersion(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunVersionsByPipelineId operation middleware
func (siw *ServerInterfaceWrapper) RunVersionsByPipelineId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersionsByPipelineId(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunPipeline operation middleware
func (siw *ServerInterfaceWrapper) RunPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunPipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTags operation middleware
func (siw *ServerInterfaceWrapper) GetTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTags(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EditTag operation middleware
func (siw *ServerInterfaceWrapper) EditTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditTag(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RemoveTag operation middleware
func (siw *ServerInterfaceWrapper) RemoveTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveTag(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasks operation middleware
func (siw *ServerInterfaceWrapper) GetTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams

	// ------------- Optional query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "taskIDs" -------------
	if paramValue := r.URL.Query().Get("taskIDs"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "taskIDs", r.URL.Query(), &params.TaskIDs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taskIDs", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------
	if paramValue := r.URL.Query().Get("order"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "created" -------------
	if paramValue := r.URL.Query().Get("created"); paramValue != "" {

		var value Created
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{ParamName: "created", Err: err})
			return
		}

		params.Created = &value

	}

	// ------------- Optional query parameter "archived" -------------
	if paramValue := r.URL.Query().Get("archived"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "archived", r.URL.Query(), &params.Archived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "archived", Err: err})
		return
	}

	// ------------- Optional query parameter "selectAs" -------------
	if paramValue := r.URL.Query().Get("selectAs"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "selectAs", r.URL.Query(), &params.SelectAs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selectAs", Err: err})
		return
	}

	// ------------- Optional query parameter "forCarousel" -------------
	if paramValue := r.URL.Query().Get("forCarousel"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "forCarousel", r.URL.Query(), &params.ForCarousel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forCarousel", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "receiver" -------------
	if paramValue := r.URL.Query().Get("receiver"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "receiver", r.URL.Query(), &params.Receiver)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "receiver", Err: err})
		return
	}

	// ------------- Optional query parameter "hasAttachments" -------------
	if paramValue := r.URL.Query().Get("hasAttachments"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hasAttachments", r.URL.Query(), &params.HasAttachments)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hasAttachments", Err: err})
		return
	}

	// ------------- Optional query parameter "initiatorLogins" -------------
	if paramValue := r.URL.Query().Get("initiatorLogins"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "initiatorLogins", r.URL.Query(), &params.InitiatorLogins)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "initiatorLogins", Err: err})
		return
	}

	// ------------- Optional query parameter "processingLogins" -------------
	if paramValue := r.URL.Query().Get("processingLogins"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "processingLogins", r.URL.Query(), &params.ProcessingLogins)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "processingLogins", Err: err})
		return
	}

	// ------------- Optional query parameter "processingGroupIds" -------------
	if paramValue := r.URL.Query().Get("processingGroupIds"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "processingGroupIds", r.URL.Query(), &params.ProcessingGroupIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "processingGroupIds", Err: err})
		return
	}

	// ------------- Optional query parameter "processedLogins" -------------
	if paramValue := r.URL.Query().Get("processedLogins"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "processedLogins", r.URL.Query(), &params.ProcessedLogins)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "processedLogins", Err: err})
		return
	}

	// ------------- Optional query parameter "processedGroupIds" -------------
	if paramValue := r.URL.Query().Get("processedGroupIds"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "processedGroupIds", r.URL.Query(), &params.ProcessedGroupIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "processedGroupIds", Err: err})
		return
	}

	// ------------- Optional query parameter "selectFor" -------------
	if paramValue := r.URL.Query().Get("selectFor"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "selectFor", r.URL.Query(), &params.SelectFor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selectFor", Err: err})
		return
	}

	// ------------- Optional query parameter "executorTypeAssigned" -------------
	if paramValue := r.URL.Query().Get("executorTypeAssigned"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "executorTypeAssigned", r.URL.Query(), &params.ExecutorTypeAssigned)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "executorTypeAssigned", Err: err})
		return
	}

	// ------------- Optional query parameter "signatureCarrier" -------------
	if paramValue := r.URL.Query().Get("signatureCarrier"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "signatureCarrier", r.URL.Query(), &params.SignatureCarrier)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "signatureCarrier", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasks(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTasksByMails operation middleware
func (siw *ServerInterfaceWrapper) UpdateTasksByMails(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTasksByMails(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasksCount operation middleware
func (siw *ServerInterfaceWrapper) GetTasksCount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasksCount(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LastVersionDebugTask operation middleware
func (siw *ServerInterfaceWrapper) LastVersionDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LastVersionDebugTask(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskMeanSolveTime operation middleware
func (siw *ServerInterfaceWrapper) GetTaskMeanSolveTime(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineId" -------------
	var pipelineId string

	err = runtime.BindStyledParameter("simple", false, "pipelineId", chi.URLParam(r, "pipelineId"), &pipelineId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskMeanSolveTime(w, r, pipelineId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineTasks operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTasks(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StopTasks operation middleware
func (siw *ServerInterfaceWrapper) StopTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StopTasks(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetVersionTasks operation middleware
func (siw *ServerInterfaceWrapper) GetVersionTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionTasks(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTask operation middleware
func (siw *ServerInterfaceWrapper) GetTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTask operation middleware
func (siw *ServerInterfaceWrapper) UpdateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskFormSchema operation middleware
func (siw *ServerInterfaceWrapper) GetTaskFormSchema(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	// ------------- Path parameter "formID" -------------
	var formID string

	err = runtime.BindStyledParameter("simple", false, "formID", chi.URLParam(r, "formID"), &formID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "formID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskFormSchema(w, r, workNumber, formID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/application/rate/{workNumber}", wrapper.RateApplication)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cron/sla", wrapper.CheckBreachSLA)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/debug/run", wrapper.StartDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/debug/{workNumber}", wrapper.DebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/approve-action-names", wrapper.GetApproveActionNames)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/approve-statuses", wrapper.GetApproveStatuses)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/get-node-decisions", wrapper.GetNodeDecisions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/schema/task-event", wrapper.GetTaskEventSchema)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forms/changelog", wrapper.GetFormsChangelog)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules", wrapper.GetModules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/usage", wrapper.AllModulesUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/{moduleName}/usage", wrapper.ModuleUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks", wrapper.GetTasksForMonitoring)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks/block/{blockId}/context", wrapper.GetBlockContext)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks/block/{blockId}/params", wrapper.GetMonitoringTasksBlockBlockIdParams)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks/{workNumber}", wrapper.GetMonitoringTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipeline/version/{versionID}/settings/main", wrapper.SaveVersionMainSettings)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines", wrapper.ListPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines", wrapper.CreatePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/copy", wrapper.CopyPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/name-exists", wrapper.PipelineNameExists)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/search", wrapper.SearchPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version", wrapper.EditVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{ID}", wrapper.DeleteVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{ID}", wrapper.GetPipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{ID}", wrapper.CreatePipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{versionID}/settings", wrapper.GetVersionSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{versionID}/settings", wrapper.SaveVersionSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{versionID}/settings/task-subscriptions", wrapper.SaveVersionTaskSubscriptionSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{versionID}/system", wrapper.AddExternalSystemToVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}", wrapper.RemoveExternalSystem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}", wrapper.GetExternalSystemSettings)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}", wrapper.SaveExternalSystemSettings)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}/endRoutes", wrapper.DeleteExternalSystemEndSettings)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}/endRoutes", wrapper.SaveExternalSystemEndSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}/runAsOthers", wrapper.AllowRunAsOthers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}", wrapper.DeletePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}", wrapper.GetPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/tags", wrapper.GetPipelineTags)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}/tags/{ID}", wrapper.DetachTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/{pipelineID}/tags/{ID}", wrapper.AttachTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/versions", wrapper.GetPipelineVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/new_version", wrapper.RunNewVersionByPrevVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/{versionID}", wrapper.RunVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/versions/pipeline_id", wrapper.RunVersionsByPipelineId)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/{pipelineID}", wrapper.RunPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/tags", wrapper.EditTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/tags/{ID}", wrapper.RemoveTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks", wrapper.GetTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/by-mails", wrapper.UpdateTasksByMails)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/count", wrapper.GetTasksCount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/last-by-version/{versionID}", wrapper.LastVersionDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/mean/{pipelineId}", wrapper.GetTaskMeanSolveTime)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/pipeline/{pipelineID}", wrapper.GetPipelineTasks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tasks/stop", wrapper.StopTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/version/{versionID}", wrapper.GetVersionTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}", wrapper.GetTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tasks/{workNumber}", wrapper.UpdateTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}/{formID}/schema", wrapper.GetTaskFormSchema)
	})

	return r
}
