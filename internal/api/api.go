// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/go-chi/chi/v5"
)

// Defines values for ApprovementRule.
const (
	ApprovementRuleAllOf ApprovementRule = "AllOf"

	ApprovementRuleAnyOf ApprovementRule = "AnyOf"
)

// Defines values for ApproverType.
const (
	ApproverTypeFromSchema ApproverType = "fromSchema"

	ApproverTypeGroup ApproverType = "group"

	ApproverTypeHead ApproverType = "head"

	ApproverTypeUser ApproverType = "user"
)

// Defines values for BooleanOperandDataType.
const (
	BooleanOperandDataTypeBoolean BooleanOperandDataType = "boolean"

	BooleanOperandDataTypeInteger BooleanOperandDataType = "integer"

	BooleanOperandDataTypeString BooleanOperandDataType = "string"
)

// Defines values for BooleanOperandOperandType.
const (
	BooleanOperandOperandTypeValueOperand BooleanOperandOperandType = "valueOperand"

	BooleanOperandOperandTypeVariableOperand BooleanOperandOperandType = "variableOperand"
)

// Defines values for ConditionGroupLogicalOperator.
const (
	ConditionGroupLogicalOperatorAnd ConditionGroupLogicalOperator = "and"

	ConditionGroupLogicalOperatorOr ConditionGroupLogicalOperator = "or"
)

// Defines values for DateOperandDataType.
const (
	DateOperandDataTypeDate DateOperandDataType = "date"

	DateOperandDataTypeString DateOperandDataType = "string"
)

// Defines values for DateOperandOperandType.
const (
	DateOperandOperandTypeValueOperand DateOperandOperandType = "valueOperand"

	DateOperandOperandTypeVariableOperand DateOperandOperandType = "variableOperand"
)

// Defines values for ExecutionParamsType.
const (
	ExecutionParamsTypeFromSchema ExecutionParamsType = "from_schema"

	ExecutionParamsTypeGroup ExecutionParamsType = "group"

	ExecutionParamsTypeUser ExecutionParamsType = "user"
)

// Defines values for FormAccessType.
const (
	FormAccessTypeNone FormAccessType = "None"

	FormAccessTypeRead FormAccessType = "Read"

	FormAccessTypeReadWrite FormAccessType = "ReadWrite"
)

// Defines values for FormExecutorType.
const (
	FormExecutorTypeFromSchema FormExecutorType = "from_schema"

	FormExecutorTypeInitiator FormExecutorType = "initiator"

	FormExecutorTypeUser FormExecutorType = "user"
)

// Defines values for FunctionParamsType.
const (
	FunctionParamsTypeApprover FunctionParamsType = "approver"

	FunctionParamsTypeExecutableFunction FunctionParamsType = "executable_function"

	FunctionParamsTypeExecution FunctionParamsType = "execution"

	FunctionParamsTypeForm FunctionParamsType = "form"

	FunctionParamsTypeIf FunctionParamsType = "if"

	FunctionParamsTypeNotification FunctionParamsType = "notification"

	FunctionParamsTypeServicedeskApplication FunctionParamsType = "servicedesk_application"
)

// Defines values for IntegerOperandDataType.
const (
	IntegerOperandDataTypeBoolean IntegerOperandDataType = "boolean"

	IntegerOperandDataTypeInteger IntegerOperandDataType = "integer"

	IntegerOperandDataTypeNumber IntegerOperandDataType = "number"
)

// Defines values for IntegerOperandOperandType.
const (
	IntegerOperandOperandTypeValueOperand IntegerOperandOperandType = "valueOperand"

	IntegerOperandOperandTypeVariableOperand IntegerOperandOperandType = "variableOperand"
)

// Defines values for NumberOperandDataType.
const (
	NumberOperandDataTypeInteger NumberOperandDataType = "integer"

	NumberOperandDataTypeNumber NumberOperandDataType = "number"

	NumberOperandDataTypeString NumberOperandDataType = "string"
)

// Defines values for NumberOperandOperandType.
const (
	NumberOperandOperandTypeValueOperand NumberOperandOperandType = "valueOperand"

	NumberOperandOperandTypeVariableOperand NumberOperandOperandType = "variableOperand"
)

// Defines values for RequestExecutionInfoType.
const (
	RequestExecutionInfoTypeAnswer RequestExecutionInfoType = "answer"

	RequestExecutionInfoTypeQuestion RequestExecutionInfoType = "question"
)

// Defines values for SocketActionType.
const (
	SocketActionTypeOther SocketActionType = "other"

	SocketActionTypePrimary SocketActionType = "primary"

	SocketActionTypeSecondary SocketActionType = "secondary"
)

// Defines values for StepStatus.
const (
	StepStatusFinished StepStatus = "finished"

	StepStatusIdle StepStatus = "idle"

	StepStatusReady StepStatus = "ready"

	StepStatusRunning StepStatus = "running"
)

// Defines values for StringOperandDataType.
const (
	StringOperandDataTypeBoolean StringOperandDataType = "boolean"

	StringOperandDataTypeDate StringOperandDataType = "date"

	StringOperandDataTypeInteger StringOperandDataType = "integer"

	StringOperandDataTypeNumber StringOperandDataType = "number"

	StringOperandDataTypeString StringOperandDataType = "string"
)

// Defines values for StringOperandOperandType.
const (
	StringOperandOperandTypeValueOperand StringOperandOperandType = "valueOperand"

	StringOperandOperandTypeVariableOperand StringOperandOperandType = "variableOperand"
)

// Defines values for TaskUpdateAction.
const (
	TaskUpdateActionAddApprovers TaskUpdateAction = "add_approvers"

	TaskUpdateActionAdditionalApprovement TaskUpdateAction = "additional_approvement"

	TaskUpdateActionApprovement TaskUpdateAction = "approvement"

	TaskUpdateActionApproverSendEditApp TaskUpdateAction = "approver_send_edit_app"

	TaskUpdateActionCancelApp TaskUpdateAction = "cancel_app"

	TaskUpdateActionChangeExecutor TaskUpdateAction = "change_executor"

	TaskUpdateActionExecution TaskUpdateAction = "execution"

	TaskUpdateActionExecutorSendEditApp TaskUpdateAction = "executor_send_edit_app"

	TaskUpdateActionExecutorStartWork TaskUpdateAction = "executor_start_work"

	TaskUpdateActionFillForm TaskUpdateAction = "fill_form"

	TaskUpdateActionRequestAddInfo TaskUpdateAction = "request_add_info"

	TaskUpdateActionRequestExecutionInfo TaskUpdateAction = "request_execution_info"
)

// Defines values for AdditionalApproverDecision.
const (
	AdditionalApproverDecisionApproved AdditionalApproverDecision = "approved"

	AdditionalApproverDecisionRejected AdditionalApproverDecision = "rejected"
)

// Defines values for ApproverDecision.
const (
	ApproverDecisionApprove ApproverDecision = "approve"

	ApproverDecisionConfirm ApproverDecision = "confirm"

	ApproverDecisionInformed ApproverDecision = "informed"

	ApproverDecisionReject ApproverDecision = "reject"

	ApproverDecisionSign ApproverDecision = "sign"

	ApproverDecisionViewed ApproverDecision = "viewed"
)

// Defines values for BlockType.
const (
	BlockTypeGo BlockType = "go"

	BlockTypePython3 BlockType = "python3"

	BlockTypeScenario BlockType = "scenario"
)

// Defines values for CompareBooleanOperator.
const (
	CompareBooleanOperatorНеРавно CompareBooleanOperator = "Не равно"

	CompareBooleanOperatorРавно CompareBooleanOperator = "Равно"
)

// Defines values for CompareDateOperator.
const (
	CompareDateOperatorБольше CompareDateOperator = "Больше"

	CompareDateOperatorБольшеИлиРавно CompareDateOperator = "Больше или равно"

	CompareDateOperatorМеньше CompareDateOperator = "Меньше"

	CompareDateOperatorМеньшеИлиРавно CompareDateOperator = "Меньше или равно"

	CompareDateOperatorНеРавно CompareDateOperator = "Не равно"

	CompareDateOperatorРавно CompareDateOperator = "Равно"
)

// Defines values for CompareIntegerOperator.
const (
	CompareIntegerOperatorБольше CompareIntegerOperator = "Больше"

	CompareIntegerOperatorБольшеИлиРавно CompareIntegerOperator = "Больше или равно"

	CompareIntegerOperatorМеньше CompareIntegerOperator = "Меньше"

	CompareIntegerOperatorМеньшеИлиРавно CompareIntegerOperator = "Меньше или равно"

	CompareIntegerOperatorНеРавно CompareIntegerOperator = "Не равно"

	CompareIntegerOperatorРавно CompareIntegerOperator = "Равно"
)

// Defines values for CompareNumberOperator.
const (
	CompareNumberOperatorБольше CompareNumberOperator = "Больше"

	CompareNumberOperatorБольшеИлиРавно CompareNumberOperator = "Больше или равно"

	CompareNumberOperatorМеньше CompareNumberOperator = "Меньше"

	CompareNumberOperatorМеньшеИлиРавно CompareNumberOperator = "Меньше или равно"

	CompareNumberOperatorНеРавно CompareNumberOperator = "Не равно"

	CompareNumberOperatorРавно CompareNumberOperator = "Равно"
)

// Defines values for CompareStringOperator.
const (
	CompareStringOperatorНеРавно CompareStringOperator = "Не равно"

	CompareStringOperatorНеСодержит CompareStringOperator = "Не Содержит"

	CompareStringOperatorРавно CompareStringOperator = "Равно"

	CompareStringOperatorСодержит CompareStringOperator = "Содержит"
)

// Defines values for ExecutionDecision.
const (
	ExecutionDecisionExecuted ExecutionDecision = "executed"

	ExecutionDecisionRejected ExecutionDecision = "rejected"
)

// Defines values for ScenarioStatus.
const (
	ScenarioStatusN1 ScenarioStatus = 1

	ScenarioStatusN2 ScenarioStatus = 2

	ScenarioStatusN3 ScenarioStatus = 3

	ScenarioStatusN4 ScenarioStatus = 4

	ScenarioStatusN5 ScenarioStatus = 5
)

// Defines values for TaskHumanStatus.
const (
	TaskHumanStatusApproved TaskHumanStatus = "approved"

	TaskHumanStatusApprovement TaskHumanStatus = "approvement"

	TaskHumanStatusDone TaskHumanStatus = "done"

	TaskHumanStatusNew TaskHumanStatus = "new"
)

// Add Approver params
type AddApproversParams struct {
	// logins of additional approvers
	AdditionalApprovers []string `json:"additionalApprovers"`
	Attachments         []string `json:"attachments"`

	// Question from approver
	Question string `json:"question"`
}

// Approver update params
type AdditionalApproverUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment from approver
	Comment string `json:"comment"`

	// Approver decision:
	//  * approved - Согласовать
	//  * rejected - Отклонить
	Decision AdditionalApproverDecision `json:"decision"`
}

// AllUsageResponse defines model for AllUsageResponse.
type AllUsageResponse struct {
	Pipelines AllUsageResponse_Pipelines `json:"pipelines"`
}

// AllUsageResponse_Pipelines defines model for AllUsageResponse.Pipelines.
type AllUsageResponse_Pipelines struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// Application defines model for Application.
type Application struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ApproveActionNamesResponse defines model for ApproveActionNamesResponse.
type ApproveActionNamesResponse struct {
	// approve action id
	Id string `json:"id"`

	// approve action title
	Title string `json:"title"`
}

// ApproveStatusesResponse defines model for ApproveStatusesResponse.
type ApproveStatusesResponse struct {
	// approve status id
	Id string `json:"id"`

	// approve status title
	Title string `json:"title"`
}

// Count of approvers which will participate in approvement will depends of approvement type. 'Any of' will check only first approvement action, when 'all of' will be waiting for all approvers or auto actions.
type ApprovementRule string

// Approver params
type ApproverParams struct {
	// Approvement status
	ApproveStatusName string `json:"approve_status_name"`

	// Count of approvers which will participate in approvement will depends of approvement type. 'Any of' will check only first approvement action, when 'all of' will be waiting for all approvers or auto actions.
	ApprovementRule *ApprovementRule `json:"approvementRule,omitempty"`

	// Approver value (depends on type)
	Approver string `json:"approver"`

	// Approvers group id in SD
	ApproversGroupId string `json:"approvers_group_id"`

	// Approvers group name in SD
	ApproversGroupName string `json:"approvers_group_name"`

	// Auto action to do (from action list)
	AutoAction *string `json:"auto_action,omitempty"`

	// Is rework SLA active
	CheckReworkSla bool `json:"check_rework_sla"`

	// Is active SLA
	CheckSla bool `json:"check_sla"`

	// List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// Show action edit application in SD
	IsEditable         bool `json:"is_editable"`
	RepeatPrevDecision bool `json:"repeat_prev_decision"`

	// Approvement rework SLA (in working hours)
	ReworkSla int `json:"rework_sla"`

	// Approvement SLA (in working hours)
	Sla int `json:"sla"`

	// Approver type:
	//   * user - Single user
	//   * group - Approver group ID
	//   * head - Receiver's head
	//   * FromSchema - Selected by initiator
	Type ApproverType `json:"type"`
}

// Approver type:
//   * user - Single user
//   * group - Approver group ID
//   * head - Receiver's head
//   * FromSchema - Selected by initiator
type ApproverType string

// Approver update params
type ApproverUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment from approver
	Comment string `json:"comment"`

	// Approver decision:
	//  * approve - Согласовать
	//  * reject - Отклонить
	//  * viewed - Ознакомлен
	//  * informed - Проинформирован
	//  * sign - Подписать
	//  * confirm - Утвердить
	Decision ApproverDecision `json:"decision"`
}

// Basic boolean operand, can provide working compare types for this type
type BooleanOperand struct {
	DataType    BooleanOperandDataType    `json:"dataType"`
	OperandType BooleanOperandOperandType `json:"operandType"`
}

// BooleanOperandDataType defines model for BooleanOperand.DataType.
type BooleanOperandDataType string

// BooleanOperandOperandType defines model for BooleanOperand.OperandType.
type BooleanOperandOperandType string

// Compare operands using operator
type Condition struct {
	// Operand for comparison
	LeftOperand Operand     `json:"leftOperand"`
	Operator    interface{} `json:"operator"`

	// Operand for comparison
	RightOperand Operand `json:"rightOperand"`
}

// Group with conditions
type ConditionGroup struct {
	Conditions      []Condition                   `json:"conditions"`
	Id              string                        `json:"id"`
	LogicalOperator ConditionGroupLogicalOperator `json:"logicalOperator"`
	Name            *string                       `json:"name,omitempty"`
}

// ConditionGroupLogicalOperator defines model for ConditionGroup.LogicalOperator.
type ConditionGroupLogicalOperator string

// Condition params
type ConditionParams struct {
	// Groups with conditions
	ConditionGroups *[]ConditionGroup `json:"conditionGroups,omitempty"`
}

// CountTasks defines model for CountTasks.
type CountTasks struct {
	Active      int `json:"active"`
	Approve     int `json:"approve"`
	Execute     int `json:"execute"`
	FormExecute int `json:"form_execute"`
}

// Created defines model for Created.
type Created struct {
	End   int `json:"end"`
	Start int `json:"start"`
}

// Basic date operand, can provide working compare types for this type
type DateOperand struct {
	DataType    DateOperandDataType    `json:"dataType"`
	OperandType DateOperandOperandType `json:"operandType"`
}

// DateOperandDataType defines model for DateOperand.DataType.
type DateOperandDataType string

// DateOperandOperandType defines model for DateOperand.OperandType.
type DateOperandOperandType string

// DebugResult defines model for DebugResult.
type DebugResult struct {
	BlockName   string   `json:"block_name"`
	BreakPoints []string `json:"break_points"`

	// todo define values
	Status string    `json:"status"`
	Task   EriusTask `json:"task"`
}

// DebugRunRequest defines model for DebugRunRequest.
type DebugRunRequest struct {
	Action      string   `json:"action"`
	BreakPoints []string `json:"break_points"`
	WorkNumber  string   `json:"work_number"`
}

// EriusFunc defines model for EriusFunc.
type EriusFunc struct {
	// Block type (language)
	BlockType  BlockType               `json:"block_type"`
	Input      *[]EriusFunctionValue   `json:"input,omitempty"`
	Next       EriusFunc_Next          `json:"next"`
	Output     *[]EriusFunctionValue   `json:"output,omitempty"`
	ParamType  *string                 `json:"param_type,omitempty"`
	Params     *map[string]interface{} `json:"params,omitempty"`
	ShortTitle *string                 `json:"short_title,omitempty"`
	Sockets    *[]Socket               `json:"sockets,omitempty"`
	Title      string                  `json:"title"`
	True       *int                    `json:"true,omitempty"`
	TypeId     string                  `json:"type_id"`
	X          *int                    `json:"x,omitempty"`
}

// EriusFunc_Next defines model for EriusFunc.Next.
type EriusFunc_Next struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// EriusFunctionList defines model for EriusFunctionList.
type EriusFunctionList struct {
	// Block modules
	Funcs []FunctionModel `json:"funcs"`

	// Block shapes
	Shapes []ShapeEntity `json:"shapes"`
}

// EriusFunctionValue defines model for EriusFunctionValue.
type EriusFunctionValue struct {
	Global string `json:"global"`
	Name   string `json:"name"`
	Type   string `json:"type"`
}

// A single scenario with all content
type EriusScenario struct {
	ApprovedAt      *string               `json:"approved_at,omitempty"`
	Author          string                `json:"author"`
	Comment         string                `json:"comment"`
	CommentRejected string                `json:"comment_rejected"`
	CreatedAt       *string               `json:"created_at,omitempty"`
	HasDraft        *bool                 `json:"hasDraft,omitempty"`
	Id              string                `json:"id"`
	Input           *[]EriusFunctionValue `json:"input,omitempty"`
	Name            string                `json:"name"`
	Output          *[]EriusFunctionValue `json:"output,omitempty"`
	Pipeline        Pipeline              `json:"pipeline"`

	// Настройки старта версии пайплайна(процесса)
	ProcessSettings ProcessSettings `json:"process_settings"`

	// 1 - Draft, 2 - Approved, 3 - Deleted, 4 - Rejected, 5 - On Approve
	Status    int            `json:"status"`
	Tags      []EriusTagInfo `json:"tags"`
	VersionId string         `json:"version_id"`
}

// EriusScenarioInfo defines model for EriusScenarioInfo.
type EriusScenarioInfo struct {
	ApprovedAt      *string `json:"approved_at,omitempty"`
	Approver        string  `json:"approver"`
	Author          string  `json:"author"`
	Comment         string  `json:"comment"`
	CommentRejected string  `json:"comment_rejected"`
	CreatedAt       string  `json:"created_at"`
	Id              string  `json:"id"`
	LastRun         *string `json:"last_run,omitempty"`
	LastRunStatus   *string `json:"last_run_status,omitempty"`
	Name            string  `json:"name"`

	// Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status    ScenarioStatus `json:"status"`
	Tags      []EriusTagInfo `json:"tags"`
	VersionId string         `json:"version_id"`
}

// EriusScenarioList defines model for EriusScenarioList.
type EriusScenarioList []EriusScenarioInfo

// EriusTagInfo defines model for EriusTagInfo.
type EriusTagInfo struct {
	Color    string `json:"color"`
	Id       string `json:"id"`
	IsMarker bool   `json:"isMarker"`
	Name     string `json:"name"`

	// 1 - Created, 3 - Deleted
	Status int `json:"status"`
}

// EriusTask defines model for EriusTask.
type EriusTask struct {
	AttachmentsCount *int    `json:"attachments_count,omitempty"`
	Author           string  `json:"author"`
	BlueprintId      string  `json:"blueprint_id"`
	Comment          *string `json:"comment,omitempty"`
	Debug            bool    `json:"debug"`
	Description      string  `json:"description"`

	// Task human readable status
	HumanStatus   TaskHumanStatus        `json:"human_status"`
	Id            string                 `json:"id"`
	LastChangedAt string                 `json:"last_changed_at"`
	Name          string                 `json:"name"`
	Parameters    map[string]interface{} `json:"parameters"`
	Rate          *int                   `json:"rate,omitempty"`
	StartedAt     string                 `json:"started_at"`
	Status        string                 `json:"status"`
	Steps         []Step                 `json:"steps"`
	VersionId     string                 `json:"version_id"`
	WorkNumber    string                 `json:"work_number"`
}

// EriusTasks defines model for EriusTasks.
type EriusTasks struct {
	Tasks *[]EriusTask `json:"tasks,omitempty"`
}

// EriusTasksPage defines model for EriusTasksPage.
type EriusTasksPage struct {
	Tasks []EriusTask `json:"tasks"`
	Total int         `json:"total"`
}

// EriusVersionInfo defines model for EriusVersionInfo.
type EriusVersionInfo struct {
	ApprovedAt string  `json:"approved_at"`
	Approver   *string `json:"approver,omitempty"`
	Author     string  `json:"author"`
	CreatedAt  string  `json:"created_at"`

	// If the version is currently used as an actual one
	IsActual bool `json:"is_actual"`

	// Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status    ScenarioStatus `json:"status"`
	UpdatedAt string         `json:"updated_at"`

	// How many times is the version used as a subprocess
	UsageCount int    `json:"usage_count"`
	VersionId  string `json:"version_id"`
}

// Chosen function to be executed
type ExecutableFunctionParams struct {
	Mapping MappingParam `json:"mapping"`

	// Function name
	Name string `json:"name"`

	// Used function version
	Version string `json:"version"`
}

// Execution params
type ExecutionParams struct {
	// Is rework SLA active
	CheckReworkSla bool `json:"check_rework_sla"`

	// Is active SLA
	CheckSla bool `json:"check_sla"`

	// Executor value (depends on type)
	Executors string `json:"executors"`

	// Executors group id in SD
	ExecutorsGroupId string `json:"executors_group_id"`

	// Executors group name in SD
	ExecutorsGroupName string `json:"executors_group_name"`

	// List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// Show action edit application in SD
	IsEditable bool `json:"is_editable"`

	// auto apply prev decision
	RepeatPrevDecision bool `json:"repeat_prev_decision"`

	// Execution rework SLA (in working hours)
	ReworkSla int `json:"rework_sla"`

	// Execution SLA (in working hours)
	Sla int `json:"sla"`

	// Execution type:
	//  * user - Single user
	//  * group - Execution group ID
	//  * from_schema - Selected by initiator
	Type ExecutionParamsType `json:"type"`
}

// Execution type:
//  * user - Single user
//  * group - Execution group ID
//  * from_schema - Selected by initiator
type ExecutionParamsType string

// Executor update params
type ExecutionUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// Executor decision:
	//  * executed - executor executed block
	//  * rejected - executor rejected block
	Decision ExecutionDecision `json:"decision"`
}

// Executor change params
type ExecutorChangeParams struct {
	Attachments []string `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// New executor login
	NewExecutorLogin string `json:"newExecutorLogin"`
}

// ExternalSystem defines model for ExternalSystem.
type ExternalSystem struct {
	// Id внешней системы
	Id string `json:"id"`

	// JSON-схема данных, которые отдаёт внешняя система
	InputSchema string `json:"input_schema"`

	// JSON-схема данных, которые принимает внешняя система
	OutputSchema string `json:"output_schema"`
}

// Fill form
type FillFormUpdateParams struct {
	ApplicationBody map[string]interface{} `json:"application_body"`

	// Form block id
	BlockId string `json:"block_id"`

	// form data
	Description string `json:"description"`
}

// Form accessibility preferences for certain node
type FormAccessType string

// FormChangelogItem defines model for FormChangelogItem.
type FormChangelogItem struct {
	// Filled form values
	ApplicationBody *map[string]interface{} `json:"application_body,omitempty"`

	// Date of log item creation
	CreatedAt *string `json:"created_at,omitempty"`

	// Compiled field keys and values of form used for notifications
	Description *string `json:"description,omitempty"`

	// Login of form executor
	Executor *string `json:"executor,omitempty"`

	// id of form schema id
	SchemaId *string `json:"schema_id,omitempty"`
}

// Form executor type:
//   * User - Single user
//   * Initiator - Process initiator
//   * From_schema - Selected by initiator
type FormExecutorType string

// Form params
type FormParams struct {
	// Executor value
	Executor *string `json:"executor,omitempty"`

	// Form executor type:
	//   * User - Single user
	//   * Initiator - Process initiator
	//   * From_schema - Selected by initiator
	FormExecutorType *FormExecutorType `json:"form_executor_type,omitempty"`

	// List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// form template id
	SchemaId *string `json:"schema_id,omitempty"`

	// form template id name
	SchemaName *string `json:"schema_name,omitempty"`
}

// FormsAccessibility defines model for FormsAccessibility.
type FormsAccessibility struct {
	// Form accessibility preferences for certain node
	AccessType FormAccessType `json:"accessType"`

	// Form short description
	Description *string `json:"description,omitempty"`

	// Form name
	Name string `json:"name"`

	// Form node ID
	NodeId string `json:"node_id"`
}

// Changelog of filled form data
type FormsChangelogResponse []FormChangelogItem

// FunctionModel defines model for FunctionModel.
type FunctionModel struct {
	// Block type (language)
	BlockType BlockType             `json:"block_type"`
	Id        string                `json:"id"`
	Inputs    *[]FunctionValueModel `json:"inputs,omitempty"`
	Outputs   *[]FunctionValueModel `json:"outputs,omitempty"`
	Params    *FunctionParams       `json:"params,omitempty"`
	ShapeType int                   `json:"shape_type"`
	Sockets   []Socket              `json:"sockets"`
	Title     string                `json:"title"`
}

// FunctionParams defines model for FunctionParams.
type FunctionParams struct {
	// Block constant params
	Params *Params `json:"params,omitempty"`

	// Params type
	Type FunctionParamsType `json:"type"`
}

// Params type
type FunctionParamsType string

// FunctionValueModel defines model for FunctionValueModel.
type FunctionValueModel struct {
	Comment *string `json:"comment,omitempty"`
	Name    *string `json:"name,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// Basic integer operand, can provide working compare types for this type
type IntegerOperand struct {
	DataType    IntegerOperandDataType    `json:"dataType"`
	OperandType IntegerOperandOperandType `json:"operandType"`
}

// IntegerOperandDataType defines model for IntegerOperand.DataType.
type IntegerOperandDataType string

// IntegerOperandOperandType defines model for IntegerOperand.OperandType.
type IntegerOperandOperandType string

// MappingParam defines model for MappingParam.
type MappingParam struct {
	AdditionalProperties map[string]struct {
		// Name of param
		Description string `json:"description"`

		// Format of param
		Format     *string         `json:"format,omitempty"`
		Items      *[]MappingParam `json:"items,omitempty"`
		Properties *MappingParam   `json:"properties,omitempty"`

		// Type of param
		Type string `json:"type"`

		// Global name for value
		Value *string `json:"value,omitempty"`
	} `json:"-"`
}

// Notification params
type NotificationParams struct {
	// Emails to get notifications
	Emails []string `json:"emails"`

	// People to get notifications
	People []string `json:"people"`

	// Notification subject
	Subject string `json:"subject"`

	// Notification body
	Text string `json:"text"`
}

// Basic number operand, can provide working compare types for this type
type NumberOperand struct {
	DataType    NumberOperandDataType    `json:"dataType"`
	OperandType NumberOperandOperandType `json:"operandType"`
}

// NumberOperandDataType defines model for NumberOperand.DataType.
type NumberOperandDataType string

// NumberOperandOperandType defines model for NumberOperand.OperandType.
type NumberOperandOperandType string

// Block constant params
type Params interface{}

// Настройки старта версии пайплайна(процесса)
type ProcessSettings struct {
	// JSON-схема выходных параметров пайплайна
	EndSchema string `json:"end_schema"`

	// Внешние системы, которые используют данный пайплайн
	ExternalSystems []ExternalSystem `json:"external_systems"`

	// JSON-схема входных параметров пайплайна
	StartSchema string `json:"start_schema"`
}

// RateApplicationRequest defines model for RateApplicationRequest.
type RateApplicationRequest struct {
	Comment *string `json:"comment,omitempty"`
	Rate    *int    `json:"rate,omitempty"`
}

// Type of execution info
type RequestExecutionInfoType string

// Executor request info params
type RequestInfoUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// executor login
	ExecutorLogin string `json:"executorLogin"`

	// Type of execution info
	ReqType RequestExecutionInfoType `json:"reqType"`
}

// ResponsePipelineSearch defines model for ResponsePipelineSearch.
type ResponsePipelineSearch struct {
	// list of pipelines
	Items []SearchPipelineItem `json:"items"`
	Total int                  `json:"total"`
}

// RunNewVersionByPrevVersionRequest defines model for RunNewVersionByPrevVersionRequest.
type RunNewVersionByPrevVersionRequest struct {
	ApplicationBody  map[string]interface{}                 `json:"application_body"`
	AttachmentFields []string                               `json:"attachment_fields"`
	Description      string                                 `json:"description"`
	Keys             RunNewVersionByPrevVersionRequest_Keys `json:"keys"`
	WorkNumber       string                                 `json:"work_number"`
}

// RunNewVersionByPrevVersionRequest_Keys defines model for RunNewVersionByPrevVersionRequest.Keys.
type RunNewVersionByPrevVersionRequest_Keys struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RunPipelineBody defines model for RunPipelineBody.
type RunPipelineBody map[string]interface{}

// RunResponse defines model for RunResponse.
type RunResponse struct {
	Errors     []string               `json:"errors"`
	Output     map[string]interface{} `json:"output"`
	PipelineId string                 `json:"pipeline_id"`
	Status     string                 `json:"status"`
	WorkNumber string                 `json:"work_number"`
}

// RunVersionBody defines model for RunVersionBody.
type RunVersionBody map[string]interface{}

// RunVersionsByPipelineIdRequest defines model for RunVersionsByPipelineIdRequest.
type RunVersionsByPipelineIdRequest struct {
	ApplicationBody   map[string]interface{}              `json:"application_body"`
	AttachmentFields  []string                            `json:"attachment_fields"`
	Description       string                              `json:"description"`
	IsTestApplication *bool                               `json:"is_test_application,omitempty"`
	Keys              RunVersionsByPipelineIdRequest_Keys `json:"keys"`
	PipelineId        string                              `json:"pipeline_id"`
}

// RunVersionsByPipelineIdRequest_Keys defines model for RunVersionsByPipelineIdRequest.Keys.
type RunVersionsByPipelineIdRequest_Keys struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ScenarioVersionInfoList defines model for ScenarioVersionInfoList.
type ScenarioVersionInfoList []EriusVersionInfo

// SchedulerTasksResponse defines model for SchedulerTasksResponse.
type SchedulerTasksResponse struct {
	// If active tasks exist
	Result bool `json:"result"`
}

// SD Application params
type SdApplicationParams struct {
	// Template application ID
	BlueprintId string `json:"blueprint_id"`
}

// SearchPipelineItem defines model for SearchPipelineItem.
type SearchPipelineItem struct {
	// Имя пайплайна
	Name *string `json:"name,omitempty"`

	// ID пайплайна
	PipelineId *string `json:"pipeline_id,omitempty"`
}

// ShapeEntity defines model for ShapeEntity.
type ShapeEntity struct {
	Icon  string `json:"icon"`
	Id    int    `json:"id"`
	Title string `json:"title"`
}

// Socket object
type Socket struct {
	// action type
	ActionType *SocketActionType `json:"actionType,omitempty"`

	// Id of socket
	Id string `json:"id"`

	// IDs of next blocks
	NextBlockIds *[]string `json:"nextBlockIds,omitempty"`

	// User-friendly title of socket for user
	Title *string `json:"title,omitempty"`
}

// action type
type SocketActionType string

// Step defines model for Step.
type Step struct {
	Errors   []string               `json:"errors"`
	HasError bool                   `json:"has_error"`
	Name     string                 `json:"name"`
	State    map[string]interface{} `json:"state"`

	// Task step execution status
	Status  StepStatus             `json:"status"`
	Steps   []string               `json:"steps"`
	Storage map[string]interface{} `json:"storage"`
	Time    string                 `json:"time"`
	Type    string                 `json:"type"`
}

// Task step execution status
type StepStatus string

// Basic string operand, can provide working compare types for this type
type StringOperand struct {
	DataType    StringOperandDataType    `json:"dataType"`
	OperandType StringOperandOperandType `json:"operandType"`
}

// StringOperandDataType defines model for StringOperand.DataType.
type StringOperandDataType string

// StringOperandOperandType defines model for StringOperand.OperandType.
type StringOperandOperandType string

// TaskMeanSolveTime defines model for TaskMeanSolveTime.
type TaskMeanSolveTime struct {
	WorkHours float32 `json:"workHours"`
}

// TaskUpdate defines model for TaskUpdate.
type TaskUpdate struct {
	Action TaskUpdateAction `json:"action"`

	// Task update params
	Parameters interface{} `json:"parameters"`
}

// TaskUpdateAction defines model for TaskUpdate.Action.
type TaskUpdateAction string

// UsageResponse defines model for UsageResponse.
type UsageResponse struct {
	// Имя блока
	Name      string   `json:"name"`
	Pipelines []UsedBy `json:"pipelines"`
	Used      bool     `json:"used"`
}

// UsedBy defines model for UsedBy.
type UsedBy struct {
	// ID сценария
	Id string `json:"id"`

	// Имя сценария
	Name string `json:"name"`
}

// Action defines model for action.
type Action struct {
	// enables attachment function
	AttachmentsEnabled bool `json:"attachments_enabled"`

	// type of renderable button with action (primary, secondary, other, none)
	ButtonType string `json:"button_type"`

	// enables comment function
	CommentEnabled bool `json:"comment_enabled"`

	// id of action
	Id string `json:"id"`

	// human action name
	Title *string `json:"title,omitempty"`
}

// Approver decision:
//  * approved - Согласовать
//  * rejected - Отклонить
type AdditionalApproverDecision string

// Approver decision:
//  * approve - Согласовать
//  * reject - Отклонить
//  * viewed - Ознакомлен
//  * informed - Проинформирован
//  * sign - Подписать
//  * confirm - Утвердить
type ApproverDecision string

// Block type (language)
type BlockType string

// Used operator to compare bool operands
type CompareBooleanOperator string

// Used operator to compare date operands
type CompareDateOperator string

// Used operator to compare integer operands
type CompareIntegerOperator string

// Used operator to compare number operands
type CompareNumberOperator string

// Used operator to compare string operands
type CompareStringOperator string

// EriusTaskResponse defines model for eriusTaskResponse.
type EriusTaskResponse struct {
	Author           string    `json:"author"`
	AvailableActions *[]Action `json:"available_actions,omitempty"`
	BlueprintId      string    `json:"blueprint_id"`
	Debug            bool      `json:"debug"`
	Description      string    `json:"description"`
	FinishedAt       *string   `json:"finished_at,omitempty"`

	// Task human readable status
	HumanStatus        TaskHumanStatus        `json:"human_status"`
	Id                 string                 `json:"id"`
	IsDelegateOfAuthor *bool                  `json:"is_delegate_of_author,omitempty"`
	LastChangedAt      string                 `json:"last_changed_at"`
	Name               string                 `json:"name"`
	Parameters         map[string]interface{} `json:"parameters"`
	Rate               int                    `json:"rate"`
	RateComment        string                 `json:"rate_comment"`
	StartedAt          string                 `json:"started_at"`
	Status             string                 `json:"status"`
	Steps              []Step                 `json:"steps"`
	VersionId          string                 `json:"version_id"`
	WorkNumber         string                 `json:"work_number"`
}

// Executor decision:
//  * executed - executor executed block
//  * rejected - executor rejected block
type ExecutionDecision string

// HttpError defines model for httpError.
type HttpError struct {
	Description *string `json:"description,omitempty"`
	Error       *string `json:"error,omitempty"`
	StatusCode  *int    `json:"status_code,omitempty"`
}

// HttpResponse defines model for httpResponse.
type HttpResponse struct {
	Data       *map[string]interface{} `json:"data,omitempty"`
	StatusCode int                     `json:"status_code"`
}

// Operand for comparison
type Operand interface{}

// Pipeline defines model for pipeline.
type Pipeline struct {
	Blocks     Pipeline_Blocks `json:"blocks"`
	Entrypoint string          `json:"entrypoint"`
}

// Pipeline_Blocks defines model for Pipeline.Blocks.
type Pipeline_Blocks struct {
	AdditionalProperties map[string]EriusFunc `json:"-"`
}

// PipelineRename defines model for pipelineRename.
type PipelineRename struct {
	// ID сценария для переименования
	Id string `json:"id"`

	// Новое имя сценария
	Name string `json:"name"`
}

// Tag status:
//  * 1 - Draft
//  * 2 - Approved
//  * 3 - Deleted
//  * 4 - Rejected
//  * 5 - On approve
type ScenarioStatus int

// Task human readable status
type TaskHumanStatus string

// ValueOperand defines model for valueOperand.
type ValueOperand struct {
	// Embedded fields due to inline allOf schema
	Value string `json:"value"`
	// Embedded fields due to inline allOf schema
}

// VariableOperand defines model for variableOperand.
type VariableOperand struct {
	// Embedded fields due to inline allOf schema
	VariableRef string `json:"variableRef"`
	// Embedded fields due to inline allOf schema
}

// RateApplicationJSONBody defines parameters for RateApplication.
type RateApplicationJSONBody RateApplicationRequest

// SetApplicationJSONBody defines parameters for SetApplication.
type SetApplicationJSONBody Application

// StartDebugTaskJSONBody defines parameters for StartDebugTask.
type StartDebugTaskJSONBody DebugRunRequest

// GetFormsChangelogParams defines parameters for GetFormsChangelog.
type GetFormsChangelogParams struct {
	// Work number
	WorkNumber string `json:"work_number"`

	// Id of form block (name)
	BlockId string `json:"block_id"`
}

// ListPipelinesParams defines parameters for ListPipelines.
type ListPipelinesParams struct {
	// Show my pipelines only
	My *bool `json:"my,omitempty"`
}

// CreatePipelineJSONBody defines parameters for CreatePipeline.
type CreatePipelineJSONBody EriusScenario

// CopyPipelineJSONBody defines parameters for CopyPipeline.
type CopyPipelineJSONBody EriusScenario

// RenamePipelineJSONBody defines parameters for RenamePipeline.
type RenamePipelineJSONBody PipelineRename

// SearchPipelinesParams defines parameters for SearchPipelines.
type SearchPipelinesParams struct {
	// имя пайплайна
	PipelineName *string `json:"pipelineName,omitempty"`

	// id пайплайна
	PipelineId *string `json:"pipelineId,omitempty"`

	// страница для отображения
	Page *int `json:"page,omitempty"`

	// сколько отображать на одной странице
	PerPage *int `json:"perPage,omitempty"`
}

// EditVersionJSONBody defines parameters for EditVersion.
type EditVersionJSONBody EriusScenario

// CreatePipelineVersionJSONBody defines parameters for CreatePipelineVersion.
type CreatePipelineVersionJSONBody EriusScenario

// RunNewVersionByPrevVersionJSONBody defines parameters for RunNewVersionByPrevVersion.
type RunNewVersionByPrevVersionJSONBody RunNewVersionByPrevVersionRequest

// RunVersionJSONBody defines parameters for RunVersion.
type RunVersionJSONBody RunVersionBody

// RunVersionsByPipelineIdJSONBody defines parameters for RunVersionsByPipelineId.
type RunVersionsByPipelineIdJSONBody RunVersionsByPipelineIdRequest

// RunPipelineJSONBody defines parameters for RunPipeline.
type RunPipelineJSONBody RunPipelineBody

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody EriusTagInfo

// EditTagJSONBody defines parameters for EditTag.
type EditTagJSONBody EriusTagInfo

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Pipeline name
	Name *string `json:"name,omitempty"`

	// Task IDs
	TaskIDs *[]string `json:"taskIDs,omitempty"`

	// Order
	Order *string `json:"order,omitempty"`

	// Limit
	Limit *int `json:"limit,omitempty"`

	// Offset
	Offset   *int     `json:"offset,omitempty"`
	Created  *Created `json:"created,omitempty"`
	Archived *bool    `json:"archived,omitempty"`
	SelectAs *string  `json:"selectAs,omitempty"`

	// get tasks with status wait or done
	ForCarousel *bool `json:"forCarousel,omitempty"`

	// get tasks with different statuses
	Status *[]string `json:"status,omitempty"`

	// receiver login
	Receiver *string `json:"receiver,omitempty"`

	// filter for attachments
	HasAttachments *bool `json:"hasAttachments,omitempty"`
}

// UpdateTaskJSONBody defines parameters for UpdateTask.
type UpdateTaskJSONBody TaskUpdate

// RateApplicationJSONRequestBody defines body for RateApplication for application/json ContentType.
type RateApplicationJSONRequestBody RateApplicationJSONBody

// SetApplicationJSONRequestBody defines body for SetApplication for application/json ContentType.
type SetApplicationJSONRequestBody SetApplicationJSONBody

// StartDebugTaskJSONRequestBody defines body for StartDebugTask for application/json ContentType.
type StartDebugTaskJSONRequestBody StartDebugTaskJSONBody

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody CreatePipelineJSONBody

// CopyPipelineJSONRequestBody defines body for CopyPipeline for application/json ContentType.
type CopyPipelineJSONRequestBody CopyPipelineJSONBody

// RenamePipelineJSONRequestBody defines body for RenamePipeline for application/json ContentType.
type RenamePipelineJSONRequestBody RenamePipelineJSONBody

// EditVersionJSONRequestBody defines body for EditVersion for application/json ContentType.
type EditVersionJSONRequestBody EditVersionJSONBody

// CreatePipelineVersionJSONRequestBody defines body for CreatePipelineVersion for application/json ContentType.
type CreatePipelineVersionJSONRequestBody CreatePipelineVersionJSONBody

// RunNewVersionByPrevVersionJSONRequestBody defines body for RunNewVersionByPrevVersion for application/json ContentType.
type RunNewVersionByPrevVersionJSONRequestBody RunNewVersionByPrevVersionJSONBody

// RunVersionJSONRequestBody defines body for RunVersion for application/json ContentType.
type RunVersionJSONRequestBody RunVersionJSONBody

// RunVersionsByPipelineIdJSONRequestBody defines body for RunVersionsByPipelineId for application/json ContentType.
type RunVersionsByPipelineIdJSONRequestBody RunVersionsByPipelineIdJSONBody

// RunPipelineJSONRequestBody defines body for RunPipeline for application/json ContentType.
type RunPipelineJSONRequestBody RunPipelineJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// EditTagJSONRequestBody defines body for EditTag for application/json ContentType.
type EditTagJSONRequestBody EditTagJSONBody

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody UpdateTaskJSONBody

// Getter for additional properties for AllUsageResponse_Pipelines. Returns the specified
// element and whether it was found
func (a AllUsageResponse_Pipelines) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AllUsageResponse_Pipelines
func (a *AllUsageResponse_Pipelines) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AllUsageResponse_Pipelines to handle AdditionalProperties
func (a *AllUsageResponse_Pipelines) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AllUsageResponse_Pipelines to handle AdditionalProperties
func (a AllUsageResponse_Pipelines) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Application. Returns the specified
// element and whether it was found
func (a Application) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Application
func (a *Application) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Application to handle AdditionalProperties
func (a *Application) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Application to handle AdditionalProperties
func (a Application) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EriusFunc_Next. Returns the specified
// element and whether it was found
func (a EriusFunc_Next) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EriusFunc_Next
func (a *EriusFunc_Next) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EriusFunc_Next to handle AdditionalProperties
func (a *EriusFunc_Next) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EriusFunc_Next to handle AdditionalProperties
func (a EriusFunc_Next) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MappingParam. Returns the specified
// element and whether it was found
func (a MappingParam) Get(fieldName string) (value struct {
	// Name of param
	Description string `json:"description"`

	// Format of param
	Format     *string         `json:"format,omitempty"`
	Items      *[]MappingParam `json:"items,omitempty"`
	Properties *MappingParam   `json:"properties,omitempty"`

	// Type of param
	Type string `json:"type"`

	// Global name for value
	Value *string `json:"value,omitempty"`
}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MappingParam
func (a *MappingParam) Set(fieldName string, value struct {
	// Name of param
	Description string `json:"description"`

	// Format of param
	Format     *string         `json:"format,omitempty"`
	Items      *[]MappingParam `json:"items,omitempty"`
	Properties *MappingParam   `json:"properties,omitempty"`

	// Type of param
	Type string `json:"type"`

	// Global name for value
	Value *string `json:"value,omitempty"`
}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]struct {
			// Name of param
			Description string `json:"description"`

			// Format of param
			Format     *string         `json:"format,omitempty"`
			Items      *[]MappingParam `json:"items,omitempty"`
			Properties *MappingParam   `json:"properties,omitempty"`

			// Type of param
			Type string `json:"type"`

			// Global name for value
			Value *string `json:"value,omitempty"`
		})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MappingParam to handle AdditionalProperties
func (a *MappingParam) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]struct {
			// Name of param
			Description string `json:"description"`

			// Format of param
			Format     *string         `json:"format,omitempty"`
			Items      *[]MappingParam `json:"items,omitempty"`
			Properties *MappingParam   `json:"properties,omitempty"`

			// Type of param
			Type string `json:"type"`

			// Global name for value
			Value *string `json:"value,omitempty"`
		})
		for fieldName, fieldBuf := range object {
			var fieldVal struct {
				// Name of param
				Description string `json:"description"`

				// Format of param
				Format     *string         `json:"format,omitempty"`
				Items      *[]MappingParam `json:"items,omitempty"`
				Properties *MappingParam   `json:"properties,omitempty"`

				// Type of param
				Type string `json:"type"`

				// Global name for value
				Value *string `json:"value,omitempty"`
			}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MappingParam to handle AdditionalProperties
func (a MappingParam) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunNewVersionByPrevVersionRequest_Keys. Returns the specified
// element and whether it was found
func (a RunNewVersionByPrevVersionRequest_Keys) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunNewVersionByPrevVersionRequest_Keys
func (a *RunNewVersionByPrevVersionRequest_Keys) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunNewVersionByPrevVersionRequest_Keys to handle AdditionalProperties
func (a *RunNewVersionByPrevVersionRequest_Keys) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunNewVersionByPrevVersionRequest_Keys to handle AdditionalProperties
func (a RunNewVersionByPrevVersionRequest_Keys) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunVersionsByPipelineIdRequest_Keys. Returns the specified
// element and whether it was found
func (a RunVersionsByPipelineIdRequest_Keys) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunVersionsByPipelineIdRequest_Keys
func (a *RunVersionsByPipelineIdRequest_Keys) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunVersionsByPipelineIdRequest_Keys to handle AdditionalProperties
func (a *RunVersionsByPipelineIdRequest_Keys) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunVersionsByPipelineIdRequest_Keys to handle AdditionalProperties
func (a RunVersionsByPipelineIdRequest_Keys) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Pipeline_Blocks. Returns the specified
// element and whether it was found
func (a Pipeline_Blocks) Get(fieldName string) (value EriusFunc, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Pipeline_Blocks
func (a *Pipeline_Blocks) Set(fieldName string, value EriusFunc) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EriusFunc)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Pipeline_Blocks to handle AdditionalProperties
func (a *Pipeline_Blocks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EriusFunc)
		for fieldName, fieldBuf := range object {
			var fieldVal EriusFunc
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Pipeline_Blocks to handle AdditionalProperties
func (a Pipeline_Blocks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// rate application
	// (POST /application/rate/{workNumber})
	RateApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// get application
	// (GET /application/{workNumber})
	GetApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// set application
	// (POST /application/{workNumber})
	SetApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// Check if any steps breached SLA
	// (GET /cron/sla)
	CheckBreachSLA(w http.ResponseWriter, r *http.Request)
	// Start debug task
	// (POST /debug/run)
	StartDebugTask(w http.ResponseWriter, r *http.Request)
	// Debug task
	// (GET /debug/{workNumber})
	DebugTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get approve action names dictionary
	// (GET /dictionaries/approve-action-names)
	GetApproveActionNames(w http.ResponseWriter, r *http.Request)
	// Get approve statuses dictionary
	// (GET /dictionaries/approve-statuses)
	GetApproveStatuses(w http.ResponseWriter, r *http.Request)
	// Get forms changelog
	// (GET /forms/changelog)
	GetFormsChangelog(w http.ResponseWriter, r *http.Request, params GetFormsChangelogParams)
	// Get list of modules
	// (GET /modules)
	GetModules(w http.ResponseWriter, r *http.Request)
	// Get list of modules usage
	// (GET /modules/usage)
	AllModulesUsage(w http.ResponseWriter, r *http.Request)
	// Usage of module in pipelines
	// (GET /modules/{moduleName}/usage)
	ModuleUsage(w http.ResponseWriter, r *http.Request, moduleName string)
	// Get list of pipelines
	// (GET /pipelines)
	ListPipelines(w http.ResponseWriter, r *http.Request, params ListPipelinesParams)
	// Create pipeline
	// (POST /pipelines)
	CreatePipeline(w http.ResponseWriter, r *http.Request)
	// Creates copy of pipeline
	// (POST /pipelines/copy)
	CopyPipeline(w http.ResponseWriter, r *http.Request)
	// Rename Pipeline
	// (PUT /pipelines/name)
	RenamePipeline(w http.ResponseWriter, r *http.Request)
	// search list of pipelines
	// (GET /pipelines/search)
	SearchPipelines(w http.ResponseWriter, r *http.Request, params SearchPipelinesParams)
	// Edit Draft
	// (PUT /pipelines/version)
	EditVersion(w http.ResponseWriter, r *http.Request)
	// Delete Version
	// (DELETE /pipelines/version/{ID})
	DeleteVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Get pipeline version
	// (GET /pipelines/version/{ID})
	GetPipelineVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Create pipeline version
	// (POST /pipelines/version/{ID})
	CreatePipelineVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Delete Pipeline
	// (DELETE /pipelines/{pipelineID})
	DeletePipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get pipeline
	// (GET /pipelines/{pipelineID})
	GetPipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Active scheduler tasks
	// (POST /pipelines/{pipelineID}/scheduler-tasks)
	ListSchedulerTasks(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Pipeline Tags
	// (GET /pipelines/{pipelineID}/tags)
	GetPipelineTags(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Detach Tag
	// (DELETE /pipelines/{pipelineID}/tags/{ID})
	DetachTag(w http.ResponseWriter, r *http.Request, pipelineID string, iD string)
	// Attach Tag
	// (PUT /pipelines/{pipelineID}/tags/{ID})
	AttachTag(w http.ResponseWriter, r *http.Request, pipelineID string, iD string)
	// Get pipeline versions
	// (GET /pipelines/{pipelineID}/versions)
	GetPipelineVersions(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Run Version
	// (POST /run/version/new_version)
	RunNewVersionByPrevVersion(w http.ResponseWriter, r *http.Request)
	// Run Version
	// (POST /run/version/{versionID})
	RunVersion(w http.ResponseWriter, r *http.Request, versionID string)
	// Run Version By pipeline_id
	// (POST /run/versions/pipeline_id)
	RunVersionsByPipelineId(w http.ResponseWriter, r *http.Request)
	// Run Pipeline
	// (POST /run/{pipelineID})
	RunPipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Tags
	// (GET /tags)
	GetTags(w http.ResponseWriter, r *http.Request)
	// Create Tag
	// (POST /tags)
	CreateTag(w http.ResponseWriter, r *http.Request)
	// Edit Tag
	// (PUT /tags)
	EditTag(w http.ResponseWriter, r *http.Request)
	// Remove Tag
	// (DELETE /tags/{ID})
	RemoveTag(w http.ResponseWriter, r *http.Request, iD string)
	// Get Tasks
	// (GET /tasks)
	GetTasks(w http.ResponseWriter, r *http.Request, params GetTasksParams)
	// Update tasks by mails
	// (GET /tasks/by-mails)
	UpdateTasksByMails(w http.ResponseWriter, r *http.Request)
	// Get amount of tasks
	// (GET /tasks/count)
	GetTasksCount(w http.ResponseWriter, r *http.Request)
	// Get last debug task for version
	// (GET /tasks/last-by-version/{versionID})
	LastVersionDebugTask(w http.ResponseWriter, r *http.Request, versionID string)
	// Get Task Mean Solve time
	// (GET /tasks/mean/{pipelineId})
	GetTaskMeanSolveTime(w http.ResponseWriter, r *http.Request, pipelineId string)
	// Get Pipeline Tasks
	// (GET /tasks/pipeline/{pipelineID})
	GetPipelineTasks(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Version Tasks
	// (GET /tasks/version/{versionID})
	GetVersionTasks(w http.ResponseWriter, r *http.Request, versionID string)
	// Get Task
	// (GET /tasks/{workNumber})
	GetTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Update Task
	// (POST /tasks/{workNumber})
	UpdateTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get Task form schema
	// (GET /tasks/{workNumber}/{formID}/schema)
	GetTaskFormSchema(w http.ResponseWriter, r *http.Request, workNumber string, formID string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// RateApplication operation middleware
func (siw *ServerInterfaceWrapper) RateApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RateApplication(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetApplication operation middleware
func (siw *ServerInterfaceWrapper) GetApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApplication(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetApplication operation middleware
func (siw *ServerInterfaceWrapper) SetApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetApplication(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CheckBreachSLA operation middleware
func (siw *ServerInterfaceWrapper) CheckBreachSLA(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckBreachSLA(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StartDebugTask operation middleware
func (siw *ServerInterfaceWrapper) StartDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartDebugTask(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DebugTask operation middleware
func (siw *ServerInterfaceWrapper) DebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DebugTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetApproveActionNames operation middleware
func (siw *ServerInterfaceWrapper) GetApproveActionNames(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApproveActionNames(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetApproveStatuses operation middleware
func (siw *ServerInterfaceWrapper) GetApproveStatuses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApproveStatuses(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetFormsChangelog operation middleware
func (siw *ServerInterfaceWrapper) GetFormsChangelog(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFormsChangelogParams

	// ------------- Required query parameter "work_number" -------------
	if paramValue := r.URL.Query().Get("work_number"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "work_number"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "work_number", r.URL.Query(), &params.WorkNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "work_number", Err: err})
		return
	}

	// ------------- Required query parameter "block_id" -------------
	if paramValue := r.URL.Query().Get("block_id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "block_id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "block_id", r.URL.Query(), &params.BlockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "block_id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFormsChangelog(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetModules operation middleware
func (siw *ServerInterfaceWrapper) GetModules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetModules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AllModulesUsage operation middleware
func (siw *ServerInterfaceWrapper) AllModulesUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AllModulesUsage(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ModuleUsage operation middleware
func (siw *ServerInterfaceWrapper) ModuleUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "moduleName" -------------
	var moduleName string

	err = runtime.BindStyledParameter("simple", false, "moduleName", chi.URLParam(r, "moduleName"), &moduleName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "moduleName", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModuleUsage(w, r, moduleName)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPipelines operation middleware
func (siw *ServerInterfaceWrapper) ListPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPipelinesParams

	// ------------- Optional query parameter "my" -------------
	if paramValue := r.URL.Query().Get("my"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "my", r.URL.Query(), &params.My)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "my", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPipelines(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePipeline operation middleware
func (siw *ServerInterfaceWrapper) CreatePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipeline(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CopyPipeline operation middleware
func (siw *ServerInterfaceWrapper) CopyPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyPipeline(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RenamePipeline operation middleware
func (siw *ServerInterfaceWrapper) RenamePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RenamePipeline(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SearchPipelines operation middleware
func (siw *ServerInterfaceWrapper) SearchPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchPipelinesParams

	// ------------- Optional query parameter "pipelineName" -------------
	if paramValue := r.URL.Query().Get("pipelineName"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "pipelineName", r.URL.Query(), &params.PipelineName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineName", Err: err})
		return
	}

	// ------------- Optional query parameter "pipelineId" -------------
	if paramValue := r.URL.Query().Get("pipelineId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "pipelineId", r.URL.Query(), &params.PipelineId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineId", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------
	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "perPage" -------------
	if paramValue := r.URL.Query().Get("perPage"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "perPage", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "perPage", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchPipelines(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EditVersion operation middleware
func (siw *ServerInterfaceWrapper) EditVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersion(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersion(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) CreatePipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipelineVersion(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePipeline operation middleware
func (siw *ServerInterfaceWrapper) DeletePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipeline operation middleware
func (siw *ServerInterfaceWrapper) GetPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListSchedulerTasks operation middleware
func (siw *ServerInterfaceWrapper) ListSchedulerTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSchedulerTasks(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineTags operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTags(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachTag operation middleware
func (siw *ServerInterfaceWrapper) DetachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachTag(w, r, pipelineID, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachTag operation middleware
func (siw *ServerInterfaceWrapper) AttachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachTag(w, r, pipelineID, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineVersions operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersions(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunNewVersionByPrevVersion operation middleware
func (siw *ServerInterfaceWrapper) RunNewVersionByPrevVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunNewVersionByPrevVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunVersion operation middleware
func (siw *ServerInterfaceWrapper) RunVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersion(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunVersionsByPipelineId operation middleware
func (siw *ServerInterfaceWrapper) RunVersionsByPipelineId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersionsByPipelineId(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunPipeline operation middleware
func (siw *ServerInterfaceWrapper) RunPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunPipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTags operation middleware
func (siw *ServerInterfaceWrapper) GetTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTags(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EditTag operation middleware
func (siw *ServerInterfaceWrapper) EditTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditTag(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RemoveTag operation middleware
func (siw *ServerInterfaceWrapper) RemoveTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameter("simple", false, "ID", chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveTag(w, r, iD)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasks operation middleware
func (siw *ServerInterfaceWrapper) GetTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams

	// ------------- Optional query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "taskIDs" -------------
	if paramValue := r.URL.Query().Get("taskIDs"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "taskIDs", r.URL.Query(), &params.TaskIDs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taskIDs", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------
	if paramValue := r.URL.Query().Get("order"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "created" -------------
	if paramValue := r.URL.Query().Get("created"); paramValue != "" {

		var value Created
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{ParamName: "created", Err: err})
			return
		}

		params.Created = &value

	}

	// ------------- Optional query parameter "archived" -------------
	if paramValue := r.URL.Query().Get("archived"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "archived", r.URL.Query(), &params.Archived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "archived", Err: err})
		return
	}

	// ------------- Optional query parameter "selectAs" -------------
	if paramValue := r.URL.Query().Get("selectAs"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "selectAs", r.URL.Query(), &params.SelectAs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selectAs", Err: err})
		return
	}

	// ------------- Optional query parameter "forCarousel" -------------
	if paramValue := r.URL.Query().Get("forCarousel"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "forCarousel", r.URL.Query(), &params.ForCarousel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forCarousel", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "receiver" -------------
	if paramValue := r.URL.Query().Get("receiver"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "receiver", r.URL.Query(), &params.Receiver)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "receiver", Err: err})
		return
	}

	// ------------- Optional query parameter "hasAttachments" -------------
	if paramValue := r.URL.Query().Get("hasAttachments"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hasAttachments", r.URL.Query(), &params.HasAttachments)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hasAttachments", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasks(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTasksByMails operation middleware
func (siw *ServerInterfaceWrapper) UpdateTasksByMails(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTasksByMails(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasksCount operation middleware
func (siw *ServerInterfaceWrapper) GetTasksCount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasksCount(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LastVersionDebugTask operation middleware
func (siw *ServerInterfaceWrapper) LastVersionDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LastVersionDebugTask(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskMeanSolveTime operation middleware
func (siw *ServerInterfaceWrapper) GetTaskMeanSolveTime(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineId" -------------
	var pipelineId string

	err = runtime.BindStyledParameter("simple", false, "pipelineId", chi.URLParam(r, "pipelineId"), &pipelineId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskMeanSolveTime(w, r, pipelineId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineTasks operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTasks(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetVersionTasks operation middleware
func (siw *ServerInterfaceWrapper) GetVersionTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionTasks(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTask operation middleware
func (siw *ServerInterfaceWrapper) GetTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTask operation middleware
func (siw *ServerInterfaceWrapper) UpdateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskFormSchema operation middleware
func (siw *ServerInterfaceWrapper) GetTaskFormSchema(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	// ------------- Path parameter "formID" -------------
	var formID string

	err = runtime.BindStyledParameter("simple", false, "formID", chi.URLParam(r, "formID"), &formID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "formID", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskFormSchema(w, r, workNumber, formID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/application/rate/{workNumber}", wrapper.RateApplication)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/application/{workNumber}", wrapper.GetApplication)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/application/{workNumber}", wrapper.SetApplication)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cron/sla", wrapper.CheckBreachSLA)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/debug/run", wrapper.StartDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/debug/{workNumber}", wrapper.DebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/approve-action-names", wrapper.GetApproveActionNames)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/approve-statuses", wrapper.GetApproveStatuses)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forms/changelog", wrapper.GetFormsChangelog)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules", wrapper.GetModules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/usage", wrapper.AllModulesUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/{moduleName}/usage", wrapper.ModuleUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines", wrapper.ListPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines", wrapper.CreatePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/copy", wrapper.CopyPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/name", wrapper.RenamePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/search", wrapper.SearchPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version", wrapper.EditVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{ID}", wrapper.DeleteVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{ID}", wrapper.GetPipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{ID}", wrapper.CreatePipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}", wrapper.DeletePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}", wrapper.GetPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/{pipelineID}/scheduler-tasks", wrapper.ListSchedulerTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/tags", wrapper.GetPipelineTags)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}/tags/{ID}", wrapper.DetachTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/{pipelineID}/tags/{ID}", wrapper.AttachTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/versions", wrapper.GetPipelineVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/new_version", wrapper.RunNewVersionByPrevVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/{versionID}", wrapper.RunVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/versions/pipeline_id", wrapper.RunVersionsByPipelineId)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/{pipelineID}", wrapper.RunPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/tags", wrapper.EditTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/tags/{ID}", wrapper.RemoveTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks", wrapper.GetTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/by-mails", wrapper.UpdateTasksByMails)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/count", wrapper.GetTasksCount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/last-by-version/{versionID}", wrapper.LastVersionDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/mean/{pipelineId}", wrapper.GetTaskMeanSolveTime)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/pipeline/{pipelineID}", wrapper.GetPipelineTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/version/{versionID}", wrapper.GetVersionTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}", wrapper.GetTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tasks/{workNumber}", wrapper.UpdateTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}/{formID}/schema", wrapper.GetTaskFormSchema)
	})

	return r
}
