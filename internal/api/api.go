// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/go-chi/chi/v5"
)

const (
	OAuth2Scopes = "OAuth2.Scopes"
)

// Defines values for ApproveAutoAction.
const (
	ApproveAutoActionApprove ApproveAutoAction = "approve"

	ApproveAutoActionReject ApproveAutoAction = "reject"
)

// Defines values for ApproverDecision.
const (
	ApproverDecisionApproved ApproverDecision = "approved"

	ApproverDecisionRejected ApproverDecision = "rejected"
)

// Defines values for ApproverType.
const (
	ApproverTypeВыборИзСхемы ApproverType = "Выбор из схемы"

	ApproverTypeГруппаСогласующих ApproverType = "Группа согласующих"

	ApproverTypeОдинСогласующий ApproverType = "Один согласующий"

	ApproverTypeРуководительПолучателя ApproverType = "Руководитель получателя"
)

// Defines values for BasicOperandOperandType.
const (
	BasicOperandOperandTypeValueOperand BasicOperandOperandType = "valueOperand"

	BasicOperandOperandTypeVariableOperand BasicOperandOperandType = "variableOperand"
)

// Defines values for BlockType.
const (
	BlockTypeGo BlockType = "go"

	BlockTypePython3 BlockType = "python3"

	BlockTypeScenario BlockType = "scenario"
)

// Defines values for CompareOperator.
const (
	CompareOperatorНеРавно CompareOperator = "Не равно"

	CompareOperatorРавно CompareOperator = "Равно"
)

// Defines values for ConditionGroupLogicalOperator.
const (
	ConditionGroupLogicalOperatorAnd ConditionGroupLogicalOperator = "and"

	ConditionGroupLogicalOperatorOr ConditionGroupLogicalOperator = "or"
)

// Defines values for ExecutionDecision.
const (
	ExecutionDecisionExecuted ExecutionDecision = "executed"

	ExecutionDecisionRejected ExecutionDecision = "rejected"
)

// Defines values for ExecutionType.
const (
	ExecutionTypeGroup ExecutionType = "group"

	ExecutionTypeUser ExecutionType = "user"
)

// Defines values for ParamsType.
const (
	ParamsTypeApprover ParamsType = "approver"

	ParamsTypeExecution ParamsType = "execution"

	ParamsTypeNotification ParamsType = "notification"

	ParamsTypeServicedeskApplication ParamsType = "servicedesk_application"
)

// Defines values for RequestExecutionInfoType.
const (
	RequestExecutionInfoTypeAnswer RequestExecutionInfoType = "answer"

	RequestExecutionInfoTypeQuestion RequestExecutionInfoType = "question"
)

// Defines values for ScenarioStatus.
const (
	ScenarioStatusN1 ScenarioStatus = 1

	ScenarioStatusN2 ScenarioStatus = 2

	ScenarioStatusN3 ScenarioStatus = 3

	ScenarioStatusN4 ScenarioStatus = 4

	ScenarioStatusN5 ScenarioStatus = 5
)

// Defines values for TagStatus.
const (
	TagStatusN1 TagStatus = 1

	TagStatusN3 TagStatus = 3
)

// Defines values for TaskHumanStatus.
const (
	TaskHumanStatusApproved TaskHumanStatus = "approved"

	TaskHumanStatusApprovement TaskHumanStatus = "approvement"

	TaskHumanStatusDone TaskHumanStatus = "done"

	TaskHumanStatusNew TaskHumanStatus = "new"
)

// Defines values for TaskStepStatus.
const (
	TaskStepStatusFinished TaskStepStatus = "finished"

	TaskStepStatusIdle TaskStepStatus = "idle"

	TaskStepStatusReady TaskStepStatus = "ready"

	TaskStepStatusRunning TaskStepStatus = "running"
)

// Defines values for UpdateTaskDataAction.
const (
	UpdateTaskDataActionApprovement UpdateTaskDataAction = "approvement"

	UpdateTaskDataActionChangeExecutor UpdateTaskDataAction = "change_executor"

	UpdateTaskDataActionExecution UpdateTaskDataAction = "execution"

	UpdateTaskDataActionRequestExecutionInfo UpdateTaskDataAction = "request_execution_info"
)

// Defines values for Order.
const (
	Asc Order = "asc"

	Desc Order = "desc"
)

// Defines values for SelectAs.
const (
	Approver SelectAs = "approver"

	Executor SelectAs = "executor"

	FinishedApprover SelectAs = "finished_approver"

	FinishedExecutor SelectAs = "finished_executor"
)

// Action to do automatically in case SLA is breached
type ApproveAutoAction string

// Approver decision:
//  * approved - approver approved block
//  * rejected - approver rejected block
type ApproverDecision string

// Approver params
type ApproverParams struct {
	// Apprver value (depends on type)
	Approver string `json:"approver"`

	// Action to do automatically in case SLA is breached
	AutoAction *ApproveAutoAction `json:"auto_action,omitempty"`

	// Repeat prev decision after editing application
	RepeatPrevDecision *bool `json:"repeat_prev_decision,omitempty"`

	// Approvement SLA (in working hours)
	Sla int `json:"sla"`

	// Approver type:
	//  * User - Single user
	//  * Group - Approver group ID
	//  * Head - Receiver's head
	//  * FromSchema - Selected by initiator
	Type ApproverType `json:"type"`
}

// Approver type:
//  * User - Single user
//  * Group - Approver group ID
//  * Head - Receiver's head
//  * FromSchema - Selected by initiator
type ApproverType string

// Approver update params
type ApproverUpdateParams struct {
	// Comment from approver
	Comment string `json:"comment"`

	// Approver decision:
	//  * approved - approver approved block
	//  * rejected - approver rejected block
	Decision ApproverDecision `json:"decision"`
}

// Basic operand, used for polymorphism
type BasicOperand struct {
	DataType    string                  `json:"dataType"`
	OperandType BasicOperandOperandType `json:"operandType"`
}

// BasicOperandOperandType defines model for BasicOperand.OperandType.
type BasicOperandOperandType string

// Block type (language)
type BlockType string

// Used operator to compare operands
type CompareOperator string

// Compare operands using operator
type Condition struct {
	// Operand for comparison
	LeftOperand Operand `json:"leftOperand"`

	// Used operator to compare operands
	Operator CompareOperator `json:"operator"`

	// Operand for comparison
	RightOperand Operand `json:"rightOperand"`
}

// Group with conditions
type ConditionGroup struct {
	Conditions      []Condition                   `json:"conditions"`
	Id              string                        `json:"id"`
	LogicalOperator ConditionGroupLogicalOperator `json:"logicalOperator"`
	Name            *string                       `json:"name,omitempty"`
}

// ConditionGroupLogicalOperator defines model for ConditionGroup.LogicalOperator.
type ConditionGroupLogicalOperator string

// Condition params
type ConditionParams struct {
	// Groups with conditions
	ConditionGroups *[]ConditionGroup `json:"conditionGroups,omitempty"`
}

// Data to start debugging
type DebugRunData struct {
	// Task action
	Action string `json:"action"`

	// Run breakpoints
	BreakPoints []string `json:"break_points"`

	// Work unique number
	WorkNumber string `json:"work_number"`
}

// DebugTask defines model for debugTask.
type DebugTask struct {
	// Current exec block name
	BlockName string `json:"block_name"`

	// Run breakpoints
	BreakPoints []string `json:"break_points"`

	// Current exec block status
	Status string `json:"status"`

	// Runned task
	Task Task `json:"task"`
}

// Error object
type Error struct {
	// Ru error
	Description string `json:"description"`

	// Error
	Error string `json:"error"`

	// Error internal status code
	StatusCode int `json:"status_code"`
}

// Executor decision:
//  * executed - executor executed block
//  * rejected - executor rejected block
type ExecutionDecision string

// Execution params
type ExecutionParams struct {
	// Executor value (depends on type)
	Executors string `json:"executors"`

	// Execution SLA (in working hours)
	Sla int `json:"sla"`

	// Execution type:
	//  * user - Single user
	//  * group - Execution group ID
	Type ExecutionType `json:"type"`
}

// Execution type:
//  * user - Single user
//  * group - Execution group ID
type ExecutionType string

// Executor update params
type ExecutionUpdateParams struct {
	// Comment from executor
	Comment string `json:"comment"`

	// Executor decision:
	//  * executed - executor executed block
	//  * rejected - executor rejected block
	Decision ExecutionDecision `json:"decision"`
}

// Executor change params
type ExecutorChangeParams struct {
	// Comment from executor
	Comment string `json:"comment"`

	// New executor login
	NewExecutorLogin string `json:"newExecutorLogin"`
}

// Function block
type Func struct {
	// Block type (language)
	BlockType BlockType `json:"block_type"`

	// Input vars
	Input *[]FunctionValue `json:"input,omitempty"`

	// Sockets outputs
	Next Func_Next `json:"next"`

	// Ourput vars
	Output *[]FunctionValue `json:"output,omitempty"`

	// Params type
	ParamType *ParamsType `json:"param_type,omitempty"`

	// Block constant params
	Params *Params `json:"params,omitempty"`

	// Block short title
	ShortTitle *string `json:"short_title,omitempty"`

	// Block title
	Title string `json:"title"`

	// Y coord
	True *int `json:"true,omitempty"`

	// Function type id
	TypeId string `json:"type_id"`

	// X coord
	X *int `json:"x,omitempty"`
}

// Sockets outputs
type Func_Next struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// Existing modules
type FunctionList struct {
	// Block modules
	Funcs []FunctionModel `json:"funcs"`

	// Block shapes
	Shapes []ShapeEntity `json:"shapes"`
}

// Function block model
type FunctionModel struct {
	// Block type (language)
	BlockType BlockType `json:"block_type"`

	// Block unique ID
	Id string `json:"id"`

	// Input vars
	Inputs *[]FunctionValue `json:"inputs,omitempty"`

	// Ourput vars
	Outputs *[]FunctionValue `json:"outputs,omitempty"`

	// Block params description
	Params *FunctionsParams `json:"params,omitempty"`

	// Block shape type
	ShapeType int `json:"shape_type"`

	// Output sockets
	Sockets []string `json:"sockets"`

	// Block title
	Title string `json:"title"`
}

// Variable
type FunctionValue struct {
	// Variable global identifier
	Global string `json:"global"`

	// Variable name
	Name string `json:"name"`

	// Variable type
	Type string `json:"type"`
}

// Block params description
type FunctionsParams struct {
	// Block constant params
	Params *Params `json:"params,omitempty"`

	// Params type
	Type ParamsType `json:"type"`
}

// Module usage
type ModuleUsage struct {
	// Module name
	Name string `json:"name"`

	// Which pipelines use module
	Pipelines []UsedBy `json:"pipelines"`

	// If module is used
	Used bool `json:"used"`
}

// Modules usage
type ModulesUsage struct {
	// Pipelines lists
	Pipelines ModulesUsage_Pipelines `json:"pipelines"`
}

// Pipelines lists
type ModulesUsage_Pipelines struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// Notification params
type NotificationParams struct {
	// People to get notifications
	People []string `json:"people"`

	// Notification subject
	Subject string `json:"subject"`

	// Notification body
	Text string `json:"text"`
}

// Operand for comparison
type Operand interface{}

// Block constant params
type Params interface{}

// Params type
type ParamsType string

// Chain of blocks
type Pipeline struct {
	Blocks Pipeline_Blocks `json:"blocks"`

	// Entrypoint block name
	Entrypoint string `json:"entrypoint"`
}

// Pipeline_Blocks defines model for Pipeline.Blocks.
type Pipeline_Blocks struct {
	AdditionalProperties map[string]Func `json:"-"`
}

// Type of execution info
type RequestExecutionInfoType string

// Executor request info params
type RequestInfoUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment from executor
	Comment string `json:"comment"`

	// Type of execution info
	ReqType RequestExecutionInfoType `json:"reqType"`
}

// Pipeleine run info
type RunInfo struct {
	// Run errors
	Errors []string `json:"errors"`

	// Run output
	Output map[string]interface{} `json:"output"`

	// Pipeline UUID
	PipelineId string `json:"pipeline_id"`

	// Task status
	Status string `json:"status"`

	// Spawned work number
	WorkNumber string `json:"work_number"`
}

// Data for run versions by blueprint_id
type RunVersionsByBlueprintIdRequest struct {
	// template fields with values. map key - value
	ApplicationBody map[string]interface{} `json:"application_body"`

	// servicedesk template id
	BlueprintId string `json:"blueprint_id"`

	// template description
	Description string `json:"description"`
}

// A single scenario with all content
type Scenario struct {
	// Version approvement time
	ApprovedAt *time.Time `json:"approved_at,omitempty"`

	// Author login
	Author string `json:"author"`

	// Scenario comment
	Comment string `json:"comment"`

	// Scenario comment (if it was rejected)
	CommentRejected string `json:"comment_rejected"`

	// Version creation time
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// If scenario has draft
	HasDraft *bool `json:"has_draft,omitempty"`

	// Scenario UUID
	Id string `json:"id"`

	// Input vars
	Input *[]FunctionValue `json:"input,omitempty"`

	// Name
	Name string `json:"name"`

	// Ourput vars
	Output *[]FunctionValue `json:"output,omitempty"`

	// Chain of blocks
	Pipeline Pipeline `json:"pipeline"`

	// Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status ScenarioStatus `json:"status"`

	// Scenario tags
	Tags []TagInfo `json:"tags"`

	// Version UUID
	VersionId string `json:"version_id"`
}

// Scenario info
type ScenarioInfo struct {
	// Version approvement time
	ApprovedAt *time.Time `json:"approved_at,omitempty"`

	// Approver login
	Approver string `json:"approver"`

	// Author login
	Author string `json:"author"`

	// Scenario comment
	Comment string `json:"comment"`

	// Scenario comment (if it was rejected)
	CommentRejected string `json:"comment_rejected"`

	// Version creation time
	CreatedAt time.Time `json:"created_at"`

	// Scenario versions history
	History *[]VersionInfo `json:"history,omitempty"`

	// Scenario UUID
	Id string `json:"id"`

	// Version last run time
	LastRun *time.Time `json:"last_run,omitempty"`

	// Version last run status
	LastRunStatus *string `json:"last_run_status,omitempty"`

	// Name
	Name string `json:"name"`

	// Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status ScenarioStatus `json:"status"`

	// Scenario tags
	Tags []TagInfo `json:"tags"`

	// Version UUID
	VersionId string `json:"version_id"`
}

// Tag status:
//  * 1 - Draft
//  * 2 - Approved
//  * 3 - Deleted
//  * 4 - Rejected
//  * 5 - On approve
type ScenarioStatus int

// List of scenarios
type Scenarios struct {
	// Scenario drafts
	Drafts []ScenarioInfo `json:"drafts"`

	// Scenarios on approve
	OnApprove []ScenarioInfo `json:"on_approve"`

	// Approved scenarios
	Pipelines []ScenarioInfo `json:"pipelines"`

	// Scenario tags
	Tags []TagInfo `json:"tags"`
}

// SchedulerTasks defines model for schedulerTasks.
type SchedulerTasks struct {
	// If active tasks exist
	Result bool `json:"result"`
}

// SD Application params
type SdApplicationParams struct {
	// Template application ID
	BlueprintId string `json:"blueprint_id"`
}

// Entity shape
type ShapeEntity struct {
	// Shape icon
	Icon string `json:"icon"`

	// Shape unique ID
	Id int `json:"id"`

	// Block name
	Title string `json:"title"`
}

// Scenario tag
type TagInfo struct {
	// Tag color
	Color string `json:"color"`

	// Tag UUID
	Id string `json:"id"`

	// If tag is a marker
	IsMarker bool `json:"isMarker"`

	// Tag name
	Name string `json:"name"`

	// Tag status:
	//  * 1 - Created
	//  * 3 - Deleted
	Status TagStatus `json:"status"`
}

// Tag status:
//  * 1 - Created
//  * 3 - Deleted
type TagStatus int

// Runned task
type Task struct {
	// Author login
	Author string `json:"author"`

	// service_desk template id
	BlueprintId string `json:"blueprint_id"`

	// If task is run in debug mode
	Debug bool `json:"debug"`

	// Task description
	Description string `json:"description"`

	// Task human readable status
	HumanStatus TaskHumanStatus `json:"human_status"`

	// Task UUID
	Id string `json:"id"`

	// Task last update time
	LastChangedAt time.Time `json:"last_changed_at"`

	// Task name
	Name string `json:"name"`

	// Task start params
	Parameters Task_Parameters `json:"parameters"`

	// Task start time
	StartedAt time.Time `json:"started_at"`

	// Task status
	Status string `json:"status"`

	// Task current steps
	Steps []TaskStep `json:"steps"`

	// Version UUID
	VersionId string `json:"version_id"`

	// Work unique number
	WorkNumber string `json:"work_number"`
}

// Task start params
type Task_Parameters struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Task human readable status
type TaskHumanStatus string

// Task step
type TaskStep struct {
	// Current errors
	Errors []string `json:"errors"`

	// If step has error
	HasError bool `json:"has_error"`

	// Step name
	Name string `json:"name"`

	// Step state
	State TaskStep_State `json:"state"`

	// Task step execution status
	Status TaskStepStatus `json:"status"`

	// Current steps
	Steps []string `json:"steps"`

	// Step variable storage
	Storage TaskStep_Storage `json:"storage"`

	// Task step time
	Time time.Time `json:"time"`

	// Step type
	Type string `json:"type"`
}

// Step state
type TaskStep_State struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Step variable storage
type TaskStep_Storage struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Task step execution status
type TaskStepStatus string

// Tasks ammount
type TasksCount struct {
	// Amount of active tasks
	Active int `json:"active"`

	// Amount of tasks to approve
	Approve int `json:"approve"`

	// Amount of tasks to execute
	Execute int `json:"execute"`
}

// Tasks page
type TasksPage struct {
	// Tasks on page
	Tasks []Task `json:"tasks"`

	// Total number of tasks
	Total int `json:"total"`
}

// A certain time period
type TimePeriod struct {
	// Timestamp (in seconds)
	End int `json:"end"`

	// Timestamp (in seconds)
	Start int `json:"start"`
}

// UpdateTaskData defines model for updateTaskData.
type UpdateTaskData struct {
	Action UpdateTaskDataAction `json:"action"`

	// Task update params
	Parameters interface{} `json:"parameters"`
}

// UpdateTaskDataAction defines model for UpdateTaskData.Action.
type UpdateTaskDataAction string

// Module usage
type UsedBy struct {
	// Scenario UUID
	Id string `json:"id"`

	// Scenario name
	Name string `json:"name"`
}

// ValueOperand defines model for valueOperand.
type ValueOperand struct {
	// Embedded struct due to allOf(#/components/schemas/basicOperand)
	BasicOperand `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Value string `json:"value"`
}

// VariableOperand defines model for variableOperand.
type VariableOperand struct {
	// Embedded struct due to allOf(#/components/schemas/basicOperand)
	BasicOperand `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	VariableRef string `json:"variableRef"`
}

// Version info
type VersionInfo struct {
	// Version approvement time
	ApprovedAt *time.Time `json:"approved_at,omitempty"`

	// Approver login
	Approver string `json:"approver"`

	// Author login
	Author string `json:"author"`

	// Version creation time
	CreatedAt time.Time `json:"created_at"`

	// Version UUID
	VersionId string `json:"version_id"`
}

// Archived defines model for archived.
type Archived bool

// A certain time period
type Created TimePeriod

// Limit defines model for limit.
type Limit int

// ModuleName defines model for moduleName.
type ModuleName string

// Name defines model for name.
type Name string

// Offset defines model for offset.
type Offset int

// Order defines model for order.
type Order string

// PipelineID defines model for pipelineID.
type PipelineID string

// SelectAs defines model for selectAs.
type SelectAs string

// TagID defines model for tagID.
type TagID string

// TaskIDs defines model for taskIDs.
type TaskIDs []string

// VersionID defines model for versionID.
type VersionID string

// WorkNumber defines model for workNumber.
type WorkNumber string

// Error object
type AccessTokenError Error

// Error object
type BadRequestError Error

// DebugTaskResp defines model for DebugTaskResp.
type DebugTaskResp struct {
	Data *DebugTask `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// ListPipelinesResp defines model for ListPipelinesResp.
type ListPipelinesResp struct {
	// List of scenarios
	Data *Scenarios `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// ModuleUsageResp defines model for ModuleUsageResp.
type ModuleUsageResp struct {
	// Module usage
	Data *ModuleUsage `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// ModulesResp defines model for ModulesResp.
type ModulesResp struct {
	// Existing modules
	Data *FunctionList `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// ModulesUsageResp defines model for ModulesUsageResp.
type ModulesUsageResp struct {
	// Modules usage
	Data *ModulesUsage `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// OKResp defines model for OKResp.
type OKResp struct {
	// Internal status code
	StatusCode int `json:"status_code"`
}

// PipelineTagResp defines model for PipelineTagResp.
type PipelineTagResp struct {
	// Scenario tag
	Data *TagInfo `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// PipelineTagsResp defines model for PipelineTagsResp.
type PipelineTagsResp struct {
	// Pipeline tags
	Data *[]TagInfo `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// RunResp defines model for RunResp.
type RunResp struct {
	// Pipeleine run info
	Data *RunInfo `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// RunVersionsByBlueprintIdResponse defines model for RunVersionsByBlueprintIdResponse.
type RunVersionsByBlueprintIdResponse struct {
	// started versions
	Data *[]RunInfo `json:"data,omitempty"`
}

// ScenarioResp defines model for ScenarioResp.
type ScenarioResp struct {
	// A single scenario with all content
	Data *Scenario `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// SchedulerTasksResp defines model for SchedulerTasksResp.
type SchedulerTasksResp struct {
	Data *SchedulerTasks `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// TaskResp defines model for TaskResp.
type TaskResp struct {
	// Runned task
	Data *Task `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// TasksCountResp defines model for TasksCountResp.
type TasksCountResp struct {
	// Tasks ammount
	Data *TasksCount `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// TasksPageResp defines model for TasksPageResp.
type TasksPageResp struct {
	// Tasks page
	Data *TasksPage `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// TasksResp defines model for TasksResp.
type TasksResp struct {
	// Tasks
	Data *[]Task `json:"data,omitempty"`

	// Internal status code
	StatusCode int `json:"status_code"`
}

// Error object
type WentWrongError Error

// CreateDebugTaskJSONBody defines parameters for CreateDebugTask.
type CreateDebugTaskJSONBody DebugRunData

// StartDebugTaskJSONBody defines parameters for StartDebugTask.
type StartDebugTaskJSONBody DebugRunData

// CreatePipelineJSONBody defines parameters for CreatePipeline.
type CreatePipelineJSONBody Scenario

// EditVersionJSONBody defines parameters for EditVersion.
type EditVersionJSONBody Scenario

// CreatePipelineVersionJSONBody defines parameters for CreatePipelineVersion.
type CreatePipelineVersionJSONBody Scenario

// RunVersionJSONBody defines parameters for RunVersion.
type RunVersionJSONBody struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RunVersionsByBlueprintIDJSONBody defines parameters for RunVersionsByBlueprintID.
type RunVersionsByBlueprintIDJSONBody RunVersionsByBlueprintIdRequest

// RunPipelineJSONBody defines parameters for RunPipeline.
type RunPipelineJSONBody struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody TagInfo

// EditTagJSONBody defines parameters for EditTag.
type EditTagJSONBody TagInfo

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Task name
	Name *Name `json:"name,omitempty"`

	// Task IDs
	TaskIDs *TaskIDs `json:"taskIDs,omitempty"`

	// Task creation date
	Created *Created `json:"created,omitempty"`

	// Sort order
	Order *Order `json:"order,omitempty"`

	// Select as
	SelectAs *SelectAs `json:"selectAs,omitempty"`

	// Archived tasks
	Archived *Archived `json:"archived,omitempty"`

	// Res limit
	Limit *Limit `json:"limit,omitempty"`

	// Res offset
	Offset *Offset `json:"offset,omitempty"`
}

// UpdateTaskJSONBody defines parameters for UpdateTask.
type UpdateTaskJSONBody UpdateTaskData

// CreateDebugTaskJSONRequestBody defines body for CreateDebugTask for application/json ContentType.
type CreateDebugTaskJSONRequestBody CreateDebugTaskJSONBody

// StartDebugTaskJSONRequestBody defines body for StartDebugTask for application/json ContentType.
type StartDebugTaskJSONRequestBody StartDebugTaskJSONBody

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody CreatePipelineJSONBody

// EditVersionJSONRequestBody defines body for EditVersion for application/json ContentType.
type EditVersionJSONRequestBody EditVersionJSONBody

// CreatePipelineVersionJSONRequestBody defines body for CreatePipelineVersion for application/json ContentType.
type CreatePipelineVersionJSONRequestBody CreatePipelineVersionJSONBody

// RunVersionJSONRequestBody defines body for RunVersion for application/json ContentType.
type RunVersionJSONRequestBody RunVersionJSONBody

// RunVersionsByBlueprintIDJSONRequestBody defines body for RunVersionsByBlueprintID for application/json ContentType.
type RunVersionsByBlueprintIDJSONRequestBody RunVersionsByBlueprintIDJSONBody

// RunPipelineJSONRequestBody defines body for RunPipeline for application/json ContentType.
type RunPipelineJSONRequestBody RunPipelineJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// EditTagJSONRequestBody defines body for EditTag for application/json ContentType.
type EditTagJSONRequestBody EditTagJSONBody

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody UpdateTaskJSONBody

// Getter for additional properties for RunVersionJSONBody. Returns the specified
// element and whether it was found
func (a RunVersionJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunVersionJSONBody
func (a *RunVersionJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunVersionJSONBody to handle AdditionalProperties
func (a *RunVersionJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunVersionJSONBody to handle AdditionalProperties
func (a RunVersionJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunPipelineJSONBody. Returns the specified
// element and whether it was found
func (a RunPipelineJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunPipelineJSONBody
func (a *RunPipelineJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunPipelineJSONBody to handle AdditionalProperties
func (a *RunPipelineJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunPipelineJSONBody to handle AdditionalProperties
func (a RunPipelineJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Func_Next. Returns the specified
// element and whether it was found
func (a Func_Next) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Func_Next
func (a *Func_Next) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Func_Next to handle AdditionalProperties
func (a *Func_Next) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Func_Next to handle AdditionalProperties
func (a Func_Next) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ModulesUsage_Pipelines. Returns the specified
// element and whether it was found
func (a ModulesUsage_Pipelines) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ModulesUsage_Pipelines
func (a *ModulesUsage_Pipelines) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ModulesUsage_Pipelines to handle AdditionalProperties
func (a *ModulesUsage_Pipelines) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ModulesUsage_Pipelines to handle AdditionalProperties
func (a ModulesUsage_Pipelines) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Pipeline_Blocks. Returns the specified
// element and whether it was found
func (a Pipeline_Blocks) Get(fieldName string) (value Func, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Pipeline_Blocks
func (a *Pipeline_Blocks) Set(fieldName string, value Func) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Func)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Pipeline_Blocks to handle AdditionalProperties
func (a *Pipeline_Blocks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Func)
		for fieldName, fieldBuf := range object {
			var fieldVal Func
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Pipeline_Blocks to handle AdditionalProperties
func (a Pipeline_Blocks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Task_Parameters. Returns the specified
// element and whether it was found
func (a Task_Parameters) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Task_Parameters
func (a *Task_Parameters) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Task_Parameters to handle AdditionalProperties
func (a *Task_Parameters) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Task_Parameters to handle AdditionalProperties
func (a Task_Parameters) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskStep_State. Returns the specified
// element and whether it was found
func (a TaskStep_State) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskStep_State
func (a *TaskStep_State) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskStep_State to handle AdditionalProperties
func (a *TaskStep_State) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskStep_State to handle AdditionalProperties
func (a TaskStep_State) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskStep_Storage. Returns the specified
// element and whether it was found
func (a TaskStep_Storage) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskStep_Storage
func (a *TaskStep_Storage) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskStep_Storage to handle AdditionalProperties
func (a *TaskStep_Storage) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskStep_Storage to handle AdditionalProperties
func (a TaskStep_Storage) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create debug task
	// (POST /debug/)
	CreateDebugTask(w http.ResponseWriter, r *http.Request)
	// Start debug task
	// (POST /debug/run)
	StartDebugTask(w http.ResponseWriter, r *http.Request)
	// Get debug task
	// (POST /debug/{workNumber})
	DebugTask(w http.ResponseWriter, r *http.Request, workNumber WorkNumber)
	// Get modules
	// (GET /modules)
	GetModules(w http.ResponseWriter, r *http.Request)
	// Get all modules usage
	// (GET /modules/usage)
	AllModulesUsage(w http.ResponseWriter, r *http.Request)
	// Run a module
	// (POST /modules/{moduleName})
	ModuleRun(w http.ResponseWriter, r *http.Request, moduleName ModuleName)
	// Get module usage
	// (GET /modules/{moduleName}/usage)
	ModuleUsage(w http.ResponseWriter, r *http.Request, moduleName ModuleName)
	// List existing pipelines
	// (GET /pipelines)
	ListPipelines(w http.ResponseWriter, r *http.Request)
	// Create new pipeline
	// (POST /pipelines)
	CreatePipeline(w http.ResponseWriter, r *http.Request)
	// Edit pipeline version
	// (PUT /pipelines/version)
	EditVersion(w http.ResponseWriter, r *http.Request)
	// Create pipeline version
	// (POST /pipelines/version/{pipelineID})
	CreatePipelineVersion(w http.ResponseWriter, r *http.Request, pipelineID PipelineID)
	// Delete pipeline version
	// (DELETE /pipelines/version/{versionID})
	DeleteVersion(w http.ResponseWriter, r *http.Request, versionID VersionID)
	// Get pipeline version
	// (GET /pipelines/version/{versionID})
	GetPipelineVersion(w http.ResponseWriter, r *http.Request, versionID VersionID)
	// Delete a pipeline
	// (DELETE /pipelines/{pipelineID})
	DeletePipeline(w http.ResponseWriter, r *http.Request, pipelineID PipelineID)
	// Get a pipeline
	// (GET /pipelines/{pipelineID})
	GetPipeline(w http.ResponseWriter, r *http.Request, pipelineID PipelineID)
	// Checks active tasks existance
	// (GET /pipelines/{pipelineID}/scheduler-tasks)
	ListSchedulerTasks(w http.ResponseWriter, r *http.Request, pipelineID PipelineID)
	// Delete pipeline tag
	// (DELETE /pipelines/{pipelineID}/tags/{tagID})
	DetachTag(w http.ResponseWriter, r *http.Request, pipelineID PipelineID, tagID TagID)
	// Get pipeline tags
	// (GET /pipelines/{pipelineID}/tags/{tagID})
	GetPipelineTag(w http.ResponseWriter, r *http.Request, pipelineID PipelineID, tagID TagID)
	// Add a tag
	// (PUT /pipelines/{pipelineID}/tags/{tagID})
	AttachTag(w http.ResponseWriter, r *http.Request, pipelineID PipelineID, tagID TagID)
	// Run pipeline version
	// (POST /run/version/{versionID})
	RunVersion(w http.ResponseWriter, r *http.Request, versionID VersionID)
	// Run Versions by blueprint_id
	// (POST /run/versions/blueprint_id)
	RunVersionsByBlueprintID(w http.ResponseWriter, r *http.Request)
	// Run pipeline
	// (POST /run/{pipelineID})
	RunPipeline(w http.ResponseWriter, r *http.Request, pipelineID PipelineID)
	// Get tags
	// (GET /tags)
	GetTags(w http.ResponseWriter, r *http.Request)
	// Create a tag
	// (POST /tags)
	CreateTag(w http.ResponseWriter, r *http.Request)
	// Edit a tag
	// (PUT /tags)
	EditTag(w http.ResponseWriter, r *http.Request)
	// Delete a tag
	// (GET /tags/{tagID})
	RemoveTag(w http.ResponseWriter, r *http.Request, tagID TagID)
	// Get tasks
	// (GET /tasks)
	GetTasks(w http.ResponseWriter, r *http.Request, params GetTasksParams)
	// Get tasks amount
	// (GET /tasks/count)
	GetTasksCount(w http.ResponseWriter, r *http.Request)
	// Get last debug task by version
	// (GET /tasks/last-by-version/{versionID})
	LastVersionDebugTask(w http.ResponseWriter, r *http.Request, versionID VersionID)
	// Get tasks by pipeline ID
	// (GET /tasks/pipeline/{pipelineID})
	GetPipelineTasks(w http.ResponseWriter, r *http.Request, pipelineID PipelineID)
	// Get tasks by version ID
	// (GET /tasks/version/{versionID})
	GetVersionTasks(w http.ResponseWriter, r *http.Request, versionID VersionID)
	// Get task
	// (GET /tasks/{workNumber})
	GetTask(w http.ResponseWriter, r *http.Request, workNumber WorkNumber)
	// Update task
	// (POST /tasks/{workNumber})
	UpdateTask(w http.ResponseWriter, r *http.Request, workNumber WorkNumber)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// CreateDebugTask operation middleware
func (siw *ServerInterfaceWrapper) CreateDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDebugTask(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StartDebugTask operation middleware
func (siw *ServerInterfaceWrapper) StartDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartDebugTask(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DebugTask operation middleware
func (siw *ServerInterfaceWrapper) DebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber WorkNumber

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DebugTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetModules operation middleware
func (siw *ServerInterfaceWrapper) GetModules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetModules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AllModulesUsage operation middleware
func (siw *ServerInterfaceWrapper) AllModulesUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AllModulesUsage(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ModuleRun operation middleware
func (siw *ServerInterfaceWrapper) ModuleRun(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "moduleName" -------------
	var moduleName ModuleName

	err = runtime.BindStyledParameter("simple", false, "moduleName", chi.URLParam(r, "moduleName"), &moduleName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "moduleName", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModuleRun(w, r, moduleName)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ModuleUsage operation middleware
func (siw *ServerInterfaceWrapper) ModuleUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "moduleName" -------------
	var moduleName ModuleName

	err = runtime.BindStyledParameter("simple", false, "moduleName", chi.URLParam(r, "moduleName"), &moduleName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "moduleName", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModuleUsage(w, r, moduleName)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPipelines operation middleware
func (siw *ServerInterfaceWrapper) ListPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPipelines(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePipeline operation middleware
func (siw *ServerInterfaceWrapper) CreatePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipeline(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EditVersion operation middleware
func (siw *ServerInterfaceWrapper) EditVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) CreatePipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipelineVersion(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID VersionID

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersion(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID VersionID

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersion(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePipeline operation middleware
func (siw *ServerInterfaceWrapper) DeletePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipeline operation middleware
func (siw *ServerInterfaceWrapper) GetPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListSchedulerTasks operation middleware
func (siw *ServerInterfaceWrapper) ListSchedulerTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSchedulerTasks(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachTag operation middleware
func (siw *ServerInterfaceWrapper) DetachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "tagID" -------------
	var tagID TagID

	err = runtime.BindStyledParameter("simple", false, "tagID", chi.URLParam(r, "tagID"), &tagID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tagID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachTag(w, r, pipelineID, tagID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineTag operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "tagID" -------------
	var tagID TagID

	err = runtime.BindStyledParameter("simple", false, "tagID", chi.URLParam(r, "tagID"), &tagID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tagID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTag(w, r, pipelineID, tagID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachTag operation middleware
func (siw *ServerInterfaceWrapper) AttachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "tagID" -------------
	var tagID TagID

	err = runtime.BindStyledParameter("simple", false, "tagID", chi.URLParam(r, "tagID"), &tagID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tagID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachTag(w, r, pipelineID, tagID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunVersion operation middleware
func (siw *ServerInterfaceWrapper) RunVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID VersionID

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersion(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunVersionsByBlueprintID operation middleware
func (siw *ServerInterfaceWrapper) RunVersionsByBlueprintID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersionsByBlueprintID(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RunPipeline operation middleware
func (siw *ServerInterfaceWrapper) RunPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunPipeline(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTags operation middleware
func (siw *ServerInterfaceWrapper) GetTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTags(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EditTag operation middleware
func (siw *ServerInterfaceWrapper) EditTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditTag(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RemoveTag operation middleware
func (siw *ServerInterfaceWrapper) RemoveTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tagID" -------------
	var tagID TagID

	err = runtime.BindStyledParameter("simple", false, "tagID", chi.URLParam(r, "tagID"), &tagID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tagID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveTag(w, r, tagID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasks operation middleware
func (siw *ServerInterfaceWrapper) GetTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams

	// ------------- Optional query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "taskIDs" -------------
	if paramValue := r.URL.Query().Get("taskIDs"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "taskIDs", r.URL.Query(), &params.TaskIDs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taskIDs", Err: err})
		return
	}

	// ------------- Optional query parameter "created" -------------
	if paramValue := r.URL.Query().Get("created"); paramValue != "" {

		var value Created
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{ParamName: "created", Err: err})
			return
		}

		params.Created = &value

	}

	// ------------- Optional query parameter "order" -------------
	if paramValue := r.URL.Query().Get("order"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "selectAs" -------------
	if paramValue := r.URL.Query().Get("selectAs"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "selectAs", r.URL.Query(), &params.SelectAs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selectAs", Err: err})
		return
	}

	// ------------- Optional query parameter "archived" -------------
	if paramValue := r.URL.Query().Get("archived"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "archived", r.URL.Query(), &params.Archived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "archived", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasks(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTasksCount operation middleware
func (siw *ServerInterfaceWrapper) GetTasksCount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasksCount(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LastVersionDebugTask operation middleware
func (siw *ServerInterfaceWrapper) LastVersionDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID VersionID

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LastVersionDebugTask(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPipelineTasks operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID PipelineID

	err = runtime.BindStyledParameter("simple", false, "pipelineID", chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTasks(w, r, pipelineID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetVersionTasks operation middleware
func (siw *ServerInterfaceWrapper) GetVersionTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID VersionID

	err = runtime.BindStyledParameter("simple", false, "versionID", chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionTasks(w, r, versionID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTask operation middleware
func (siw *ServerInterfaceWrapper) GetTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber WorkNumber

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTask operation middleware
func (siw *ServerInterfaceWrapper) UpdateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber WorkNumber

	err = runtime.BindStyledParameter("simple", false, "workNumber", chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"openid"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTask(w, r, workNumber)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/debug/", wrapper.CreateDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/debug/run", wrapper.StartDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/debug/{workNumber}", wrapper.DebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules", wrapper.GetModules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/usage", wrapper.AllModulesUsage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/modules/{moduleName}", wrapper.ModuleRun)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/{moduleName}/usage", wrapper.ModuleUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines", wrapper.ListPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines", wrapper.CreatePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version", wrapper.EditVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{pipelineID}", wrapper.CreatePipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{versionID}", wrapper.DeleteVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{versionID}", wrapper.GetPipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}", wrapper.DeletePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}", wrapper.GetPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/scheduler-tasks", wrapper.ListSchedulerTasks)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}/tags/{tagID}", wrapper.DetachTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/tags/{tagID}", wrapper.GetPipelineTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/{pipelineID}/tags/{tagID}", wrapper.AttachTag)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/{versionID}", wrapper.RunVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/versions/blueprint_id", wrapper.RunVersionsByBlueprintID)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/{pipelineID}", wrapper.RunPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/tags", wrapper.EditTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags/{tagID}", wrapper.RemoveTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks", wrapper.GetTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/count", wrapper.GetTasksCount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/last-by-version/{versionID}", wrapper.LastVersionDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/pipeline/{pipelineID}", wrapper.GetPipelineTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/version/{versionID}", wrapper.GetVersionTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}", wrapper.GetTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tasks/{workNumber}", wrapper.UpdateTask)
	})

	return r
}
