// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/go-chi/chi/v5"
)

// Defines values for ApprovementRule.
const (
	AllOf ApprovementRule = "AllOf"
	AnyOf ApprovementRule = "AnyOf"
)

// Defines values for ApproverType.
const (
	ApproverTypeFromSchema ApproverType = "fromSchema"
	ApproverTypeGroup      ApproverType = "group"
	ApproverTypeHead       ApproverType = "head"
	ApproverTypeUser       ApproverType = "user"
)

// Defines values for BooleanOperandDataType.
const (
	BooleanOperandDataTypeBoolean BooleanOperandDataType = "boolean"
	BooleanOperandDataTypeInteger BooleanOperandDataType = "integer"
	BooleanOperandDataTypeString  BooleanOperandDataType = "string"
)

// Defines values for BooleanOperandOperandType.
const (
	BooleanOperandOperandTypeValueOperand    BooleanOperandOperandType = "valueOperand"
	BooleanOperandOperandTypeVariableOperand BooleanOperandOperandType = "variableOperand"
)

// Defines values for ConditionGroupLogicalOperator.
const (
	And ConditionGroupLogicalOperator = "and"
	Or  ConditionGroupLogicalOperator = "or"
)

// Defines values for DateOperandDataType.
const (
	DateOperandDataTypeDate   DateOperandDataType = "date"
	DateOperandDataTypeString DateOperandDataType = "string"
)

// Defines values for DateOperandOperandType.
const (
	DateOperandOperandTypeValueOperand    DateOperandOperandType = "valueOperand"
	DateOperandOperandTypeVariableOperand DateOperandOperandType = "variableOperand"
)

// Defines values for ExecutionParamsType.
const (
	ExecutionParamsTypeFromSchema ExecutionParamsType = "from_schema"
	ExecutionParamsTypeGroup      ExecutionParamsType = "group"
	ExecutionParamsTypeUser       ExecutionParamsType = "user"
)

// Defines values for FormAccessType.
const (
	None      FormAccessType = "None"
	Read      FormAccessType = "Read"
	ReadWrite FormAccessType = "ReadWrite"
)

// Defines values for FormExecutorType.
const (
	FormExecutorTypeFromSchema FormExecutorType = "from_schema"
	FormExecutorTypeInitiator  FormExecutorType = "initiator"
	FormExecutorTypeUser       FormExecutorType = "user"
)

// Defines values for FunctionParamsType.
const (
	FunctionParamsTypeApprover               FunctionParamsType = "approver"
	FunctionParamsTypeExecutableFunction     FunctionParamsType = "executable_function"
	FunctionParamsTypeExecution              FunctionParamsType = "execution"
	FunctionParamsTypeForm                   FunctionParamsType = "form"
	FunctionParamsTypeIf                     FunctionParamsType = "if"
	FunctionParamsTypeNotification           FunctionParamsType = "notification"
	FunctionParamsTypeServicedeskApplication FunctionParamsType = "servicedesk_application"
)

// Defines values for IntegerOperandDataType.
const (
	IntegerOperandDataTypeBoolean IntegerOperandDataType = "boolean"
	IntegerOperandDataTypeInteger IntegerOperandDataType = "integer"
	IntegerOperandDataTypeNumber  IntegerOperandDataType = "number"
)

// Defines values for IntegerOperandOperandType.
const (
	IntegerOperandOperandTypeValueOperand    IntegerOperandOperandType = "valueOperand"
	IntegerOperandOperandTypeVariableOperand IntegerOperandOperandType = "variableOperand"
)

// Defines values for MonitoringHistoryStatus.
const (
	MonitoringHistoryStatusFinished MonitoringHistoryStatus = "finished"
	MonitoringHistoryStatusRunning  MonitoringHistoryStatus = "running"
)

// Defines values for MonitoringTableTaskStatus.
const (
	MonitoringTableTaskStatusВРаботе           MonitoringTableTaskStatus = "В работе"
	MonitoringTableTaskStatusЗавершен          MonitoringTableTaskStatus = "Завершен"
	MonitoringTableTaskStatusНеизвестныйСтатус MonitoringTableTaskStatus = "Неизвестный статус"
	MonitoringTableTaskStatusОстановлен        MonitoringTableTaskStatus = "Остановлен"
)

// Defines values for NumberOperandDataType.
const (
	NumberOperandDataTypeInteger NumberOperandDataType = "integer"
	NumberOperandDataTypeNumber  NumberOperandDataType = "number"
	NumberOperandDataTypeString  NumberOperandDataType = "string"
)

// Defines values for NumberOperandOperandType.
const (
	NumberOperandOperandTypeValueOperand    NumberOperandOperandType = "valueOperand"
	NumberOperandOperandTypeVariableOperand NumberOperandOperandType = "variableOperand"
)

// Defines values for RequestExecutionInfoType.
const (
	Answer   RequestExecutionInfoType = "answer"
	Question RequestExecutionInfoType = "question"
)

// Defines values for SocketActionType.
const (
	Other     SocketActionType = "other"
	Primary   SocketActionType = "primary"
	Secondary SocketActionType = "secondary"
)

// Defines values for StepStatus.
const (
	StepStatusFinished StepStatus = "finished"
	StepStatusIdle     StepStatus = "idle"
	StepStatusReady    StepStatus = "ready"
	StepStatusRunning  StepStatus = "running"
)

// Defines values for StringOperandDataType.
const (
	Boolean StringOperandDataType = "boolean"
	Date    StringOperandDataType = "date"
	Integer StringOperandDataType = "integer"
	Number  StringOperandDataType = "number"
	String  StringOperandDataType = "string"
)

// Defines values for StringOperandOperandType.
const (
	StringOperandOperandTypeValueOperand    StringOperandOperandType = "valueOperand"
	StringOperandOperandTypeVariableOperand StringOperandOperandType = "variableOperand"
)

// Defines values for TaskUpdateAction.
const (
	TaskUpdateActionAddApprovers          TaskUpdateAction = "add_approvers"
	TaskUpdateActionAdditionalApprovement TaskUpdateAction = "additional_approvement"
	TaskUpdateActionApprovement           TaskUpdateAction = "approvement"
	TaskUpdateActionApproverSendEditApp   TaskUpdateAction = "approver_send_edit_app"
	TaskUpdateActionCancelApp             TaskUpdateAction = "cancel_app"
	TaskUpdateActionChangeExecutor        TaskUpdateAction = "change_executor"
	TaskUpdateActionExecution             TaskUpdateAction = "execution"
	TaskUpdateActionExecutorSendEditApp   TaskUpdateAction = "executor_send_edit_app"
	TaskUpdateActionExecutorStartWork     TaskUpdateAction = "executor_start_work"
	TaskUpdateActionFillForm              TaskUpdateAction = "fill_form"
	TaskUpdateActionRequestAddInfo        TaskUpdateAction = "request_add_info"
	TaskUpdateActionRequestExecutionInfo  TaskUpdateAction = "request_execution_info"
)

// Defines values for AdditionalApproverDecision.
const (
	AdditionalApproverDecisionApproved AdditionalApproverDecision = "approved"
	AdditionalApproverDecisionRejected AdditionalApproverDecision = "rejected"
)

// Defines values for ApproverDecision.
const (
	Approve  ApproverDecision = "approve"
	Confirm  ApproverDecision = "confirm"
	Informed ApproverDecision = "informed"
	Reject   ApproverDecision = "reject"
	Sign     ApproverDecision = "sign"
	Viewed   ApproverDecision = "viewed"
)

// Defines values for BlockType.
const (
	Go       BlockType = "go"
	Python3  BlockType = "python3"
	Scenario BlockType = "scenario"
)

// Defines values for CompareBooleanOperator.
const (
	CompareBooleanOperatorНеРавно CompareBooleanOperator = "Не равно"
	CompareBooleanOperatorРавно   CompareBooleanOperator = "Равно"
)

// Defines values for CompareDateOperator.
const (
	CompareDateOperatorБольше         CompareDateOperator = "Больше"
	CompareDateOperatorБольшеИлиРавно CompareDateOperator = "Больше или равно"
	CompareDateOperatorМеньше         CompareDateOperator = "Меньше"
	CompareDateOperatorМеньшеИлиРавно CompareDateOperator = "Меньше или равно"
	CompareDateOperatorНеРавно        CompareDateOperator = "Не равно"
	CompareDateOperatorРавно          CompareDateOperator = "Равно"
)

// Defines values for CompareIntegerOperator.
const (
	CompareIntegerOperatorБольше         CompareIntegerOperator = "Больше"
	CompareIntegerOperatorБольшеИлиРавно CompareIntegerOperator = "Больше или равно"
	CompareIntegerOperatorМеньше         CompareIntegerOperator = "Меньше"
	CompareIntegerOperatorМеньшеИлиРавно CompareIntegerOperator = "Меньше или равно"
	CompareIntegerOperatorНеРавно        CompareIntegerOperator = "Не равно"
	CompareIntegerOperatorРавно          CompareIntegerOperator = "Равно"
)

// Defines values for CompareNumberOperator.
const (
	CompareNumberOperatorБольше         CompareNumberOperator = "Больше"
	CompareNumberOperatorБольшеИлиРавно CompareNumberOperator = "Больше или равно"
	CompareNumberOperatorМеньше         CompareNumberOperator = "Меньше"
	CompareNumberOperatorМеньшеИлиРавно CompareNumberOperator = "Меньше или равно"
	CompareNumberOperatorНеРавно        CompareNumberOperator = "Не равно"
	CompareNumberOperatorРавно          CompareNumberOperator = "Равно"
)

// Defines values for CompareStringOperator.
const (
	НеРавно    CompareStringOperator = "Не равно"
	НеСодержит CompareStringOperator = "Не Содержит"
	Равно      CompareStringOperator = "Равно"
	Содержит   CompareStringOperator = "Содержит"
)

// Defines values for EriusTaskResponseStatus.
const (
	EriusTaskResponseStatusCreated  EriusTaskResponseStatus = "created"
	EriusTaskResponseStatusError    EriusTaskResponseStatus = "error"
	EriusTaskResponseStatusFinished EriusTaskResponseStatus = "finished"
	EriusTaskResponseStatusRun      EriusTaskResponseStatus = "run"
	EriusTaskResponseStatusStopped  EriusTaskResponseStatus = "stopped"
)

// Defines values for ExecutionDecision.
const (
	ExecutionDecisionExecuted ExecutionDecision = "executed"
	ExecutionDecisionRejected ExecutionDecision = "rejected"
)

// Defines values for ScenarioStatus.
const (
	N1 ScenarioStatus = 1
	N2 ScenarioStatus = 2
	N3 ScenarioStatus = 3
	N4 ScenarioStatus = 4
	N5 ScenarioStatus = 5
)

// Defines values for TaskHumanStatus.
const (
	Approved    TaskHumanStatus = "approved"
	Approvement TaskHumanStatus = "approvement"
	Done        TaskHumanStatus = "done"
	New         TaskHumanStatus = "new"
)

// Defines values for GetTasksForMonitoringParamsSortColumn.
const (
	GetTasksForMonitoringParamsSortColumnFinishedAt  GetTasksForMonitoringParamsSortColumn = "finished_at"
	GetTasksForMonitoringParamsSortColumnId          GetTasksForMonitoringParamsSortColumn = "id"
	GetTasksForMonitoringParamsSortColumnInitiator   GetTasksForMonitoringParamsSortColumn = "initiator"
	GetTasksForMonitoringParamsSortColumnProcessName GetTasksForMonitoringParamsSortColumn = "process_name"
	GetTasksForMonitoringParamsSortColumnStartedAt   GetTasksForMonitoringParamsSortColumn = "started_at"
	GetTasksForMonitoringParamsSortColumnStatus      GetTasksForMonitoringParamsSortColumn = "status"
	GetTasksForMonitoringParamsSortColumnWorkNumber  GetTasksForMonitoringParamsSortColumn = "work_number"
)

// Defines values for GetTasksForMonitoringParamsSortOrder.
const (
	ASC  GetTasksForMonitoringParamsSortOrder = "ASC"
	DESC GetTasksForMonitoringParamsSortOrder = "DESC"
)

// Defines values for GetTasksForMonitoringParamsStatus.
const (
	GetTasksForMonitoringParamsStatusВРаботе    GetTasksForMonitoringParamsStatus = "В работе"
	GetTasksForMonitoringParamsStatusЗавершен   GetTasksForMonitoringParamsStatus = "Завершен"
	GetTasksForMonitoringParamsStatusОстановлен GetTasksForMonitoringParamsStatus = "Остановлен"
)

// Defines values for SaveVersionSettingsParamsSchemaFlag.
const (
	EndSchema   SaveVersionSettingsParamsSchemaFlag = "end_schema"
	StartSchema SaveVersionSettingsParamsSchemaFlag = "start_schema"
)

// Defines values for SaveExternalSystemSettingsParamsSchemaFlag.
const (
	InputMapping  SaveExternalSystemSettingsParamsSchemaFlag = "input_mapping"
	InputSchema   SaveExternalSystemSettingsParamsSchemaFlag = "input_schema"
	OutputMapping SaveExternalSystemSettingsParamsSchemaFlag = "output_mapping"
	OutputSchema  SaveExternalSystemSettingsParamsSchemaFlag = "output_schema"
)

// AddApproversParams Add Approver params
type AddApproversParams struct {
	// AdditionalApprovers logins of additional approvers
	AdditionalApprovers []string `json:"additionalApprovers"`
	Attachments         []string `json:"attachments"`

	// Question Question from approver
	Question string `json:"question"`
}

// AdditionalApproverUpdateParams Approver update params
type AdditionalApproverUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment Comment from approver
	Comment string `json:"comment"`

	// Decision Approver decision:
	//  * approved - Согласовать
	//  * rejected - Отклонить
	Decision AdditionalApproverDecision `json:"decision"`
}

// AllUsageResponse defines model for AllUsageResponse.
type AllUsageResponse struct {
	Pipelines map[string][]string `json:"pipelines"`
}

// Application defines model for Application.
type Application map[string]interface{}

// ApproveActionNamesResponse defines model for ApproveActionNamesResponse.
type ApproveActionNamesResponse struct {
	// Id approve action id
	Id string `json:"id"`

	// Title approve action title
	Title string `json:"title"`
}

// ApproveStatusesResponse defines model for ApproveStatusesResponse.
type ApproveStatusesResponse struct {
	// Id approve status id
	Id string `json:"id"`

	// Title approve status title
	Title string `json:"title"`
}

// ApprovementRule Count of approvers which will participate in approvement will depends of approvement type. 'Any of' will check only first approvement action, when 'all of' will be waiting for all approvers or auto actions.
type ApprovementRule string

// ApproverParams Approver params
type ApproverParams struct {
	// ApproveStatusName Approvement status
	ApproveStatusName string `json:"approve_status_name"`

	// ApprovementRule Count of approvers which will participate in approvement will depends of approvement type. 'Any of' will check only first approvement action, when 'all of' will be waiting for all approvers or auto actions.
	ApprovementRule *ApprovementRule `json:"approvementRule,omitempty"`

	// Approver Approver value (depends on type)
	Approver string `json:"approver"`

	// ApproversGroupId Approvers group id in SD
	ApproversGroupId string `json:"approvers_group_id"`

	// ApproversGroupName Approvers group name in SD
	ApproversGroupName string `json:"approvers_group_name"`

	// AutoAction Auto action to do (from action list)
	AutoAction *string `json:"auto_action,omitempty"`

	// CheckReworkSla Is rework SLA active
	CheckReworkSla bool `json:"check_rework_sla"`

	// CheckSla Is active SLA
	CheckSla bool `json:"check_sla"`

	// FormsAccessibility List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// IsEditable Show action edit application in SD
	IsEditable         bool `json:"is_editable"`
	RepeatPrevDecision bool `json:"repeat_prev_decision"`

	// ReworkSla Approvement rework SLA (in working hours)
	ReworkSla int `json:"rework_sla"`

	// Sla Approvement SLA (in working hours)
	Sla int `json:"sla"`

	// Type Approver type:
	//   * user - Single user
	//   * group - Approver group ID
	//   * head - Receiver's head
	//   * FromSchema - Selected by initiator
	Type ApproverType `json:"type"`
}

// ApproverType Approver type:
//   - user - Single user
//   - group - Approver group ID
//   - head - Receiver's head
//   - FromSchema - Selected by initiator
type ApproverType string

// ApproverUpdateParams Approver update params
type ApproverUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment Comment from approver
	Comment string `json:"comment"`

	// Decision Approver decision:
	//  * approve - Согласовать
	//  * reject - Отклонить
	//  * viewed - Ознакомлен
	//  * informed - Проинформирован
	//  * sign - Подписать
	//  * confirm - Утвердить
	Decision ApproverDecision `json:"decision"`
}

// BlockContextResponse defines model for BlockContextResponse.
type BlockContextResponse struct {
	// Blocks Ноды
	Blocks *map[string]MonitoringBlockOutput `json:"blocks,omitempty"`
}

// BooleanOperand Basic boolean operand, can provide working compare types for this type
type BooleanOperand struct {
	DataType    BooleanOperandDataType    `json:"dataType"`
	OperandType BooleanOperandOperandType `json:"operandType"`
}

// BooleanOperandDataType defines model for BooleanOperand.DataType.
type BooleanOperandDataType string

// BooleanOperandOperandType defines model for BooleanOperand.OperandType.
type BooleanOperandOperandType string

// Condition Compare operands using operator
type Condition struct {
	// LeftOperand Operand for comparison
	LeftOperand Operand            `json:"leftOperand"`
	Operator    Condition_Operator `json:"operator"`

	// RightOperand Operand for comparison
	RightOperand Operand `json:"rightOperand"`
}

// Condition_Operator defines model for Condition.Operator.
type Condition_Operator struct {
	union json.RawMessage
}

// ConditionGroup Group with conditions
type ConditionGroup struct {
	Conditions      []Condition                   `json:"conditions"`
	Id              string                        `json:"id"`
	LogicalOperator ConditionGroupLogicalOperator `json:"logicalOperator"`
	Name            *string                       `json:"name,omitempty"`
}

// ConditionGroupLogicalOperator defines model for ConditionGroup.LogicalOperator.
type ConditionGroupLogicalOperator string

// ConditionParams Condition params
type ConditionParams struct {
	// ConditionGroups Groups with conditions
	ConditionGroups *[]ConditionGroup `json:"conditionGroups,omitempty"`
}

// CountTasks defines model for CountTasks.
type CountTasks struct {
	Active      int `json:"active"`
	Approve     int `json:"approve"`
	Execute     int `json:"execute"`
	FormExecute int `json:"form_execute"`
}

// Created defines model for Created.
type Created struct {
	End   int `json:"end"`
	Start int `json:"start"`
}

// DateOperand Basic date operand, can provide working compare types for this type
type DateOperand struct {
	DataType    DateOperandDataType    `json:"dataType"`
	OperandType DateOperandOperandType `json:"operandType"`
}

// DateOperandDataType defines model for DateOperand.DataType.
type DateOperandDataType string

// DateOperandOperandType defines model for DateOperand.OperandType.
type DateOperandOperandType string

// DebugResult defines model for DebugResult.
type DebugResult struct {
	BlockName   string   `json:"block_name"`
	BreakPoints []string `json:"break_points"`

	// Status todo define values
	Status string    `json:"status"`
	Task   EriusTask `json:"task"`
}

// DebugRunRequest defines model for DebugRunRequest.
type DebugRunRequest struct {
	Action      string   `json:"action"`
	BreakPoints []string `json:"break_points"`
	WorkNumber  string   `json:"work_number"`
}

// EriusFunc defines model for EriusFunc.
type EriusFunc struct {
	// BlockType Block type (language)
	BlockType  BlockType               `json:"block_type"`
	Input      *[]EriusFunctionValue   `json:"input,omitempty"`
	Next       map[string][]string     `json:"next"`
	Output     *[]EriusFunctionValue   `json:"output,omitempty"`
	ParamType  *string                 `json:"param_type,omitempty"`
	Params     *map[string]interface{} `json:"params,omitempty"`
	ShortTitle *string                 `json:"short_title,omitempty"`
	Sockets    *[]Socket               `json:"sockets,omitempty"`
	Title      string                  `json:"title"`
	TypeId     string                  `json:"type_id"`
	X          *int                    `json:"x,omitempty"`
	Y          *int                    `json:"y,omitempty"`
}

// EriusFunctionList defines model for EriusFunctionList.
type EriusFunctionList struct {
	// Funcs Block modules
	Funcs []FunctionModel `json:"funcs"`

	// Shapes Block shapes
	Shapes []ShapeEntity `json:"shapes"`
}

// EriusFunctionValue defines model for EriusFunctionValue.
type EriusFunctionValue struct {
	Global string `json:"global"`
	Name   string `json:"name"`
	Type   string `json:"type"`
}

// EriusScenario A single scenario with all content
type EriusScenario struct {
	ApprovedAt      *string               `json:"approved_at,omitempty"`
	Author          string                `json:"author"`
	Comment         string                `json:"comment"`
	CommentRejected string                `json:"comment_rejected"`
	CreatedAt       *string               `json:"created_at,omitempty"`
	HasDraft        *bool                 `json:"hasDraft,omitempty"`
	Id              openapi_types.UUID    `json:"id"`
	Input           *[]EriusFunctionValue `json:"input,omitempty"`
	Name            string                `json:"name"`
	Output          *[]EriusFunctionValue `json:"output,omitempty"`
	Pipeline        Pipeline              `json:"pipeline"`

	// Status 1 - Draft, 2 - Approved, 3 - Deleted, 4 - Rejected, 5 - On Approve
	Status    int                `json:"status"`
	Tags      []EriusTagInfo     `json:"tags"`
	VersionId openapi_types.UUID `json:"version_id"`
}

// EriusScenarioInfo defines model for EriusScenarioInfo.
type EriusScenarioInfo struct {
	ApprovedAt      *string            `json:"approved_at,omitempty"`
	Approver        string             `json:"approver"`
	Author          string             `json:"author"`
	Comment         string             `json:"comment"`
	CommentRejected string             `json:"comment_rejected"`
	CreatedAt       string             `json:"created_at"`
	Id              openapi_types.UUID `json:"id"`
	LastRun         *string            `json:"last_run,omitempty"`
	LastRunStatus   *string            `json:"last_run_status,omitempty"`
	Name            string             `json:"name"`

	// Status Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status    ScenarioStatus     `json:"status"`
	Tags      []EriusTagInfo     `json:"tags"`
	VersionId openapi_types.UUID `json:"version_id"`
}

// EriusScenarioList defines model for EriusScenarioList.
type EriusScenarioList = []EriusScenarioInfo

// EriusTagInfo defines model for EriusTagInfo.
type EriusTagInfo struct {
	Color    string             `json:"color"`
	Id       openapi_types.UUID `json:"id"`
	IsMarker bool               `json:"isMarker"`
	Name     string             `json:"name"`

	// Status 1 - Created, 3 - Deleted
	Status int `json:"status"`
}

// EriusTask defines model for EriusTask.
type EriusTask struct {
	AttachmentsCount *int    `json:"attachments_count,omitempty"`
	Author           string  `json:"author"`
	BlueprintId      string  `json:"blueprint_id"`
	Comment          *string `json:"comment,omitempty"`
	Debug            bool    `json:"debug"`
	Description      string  `json:"description"`

	// HumanStatus Task human readable status
	HumanStatus   TaskHumanStatus        `json:"human_status"`
	Id            string                 `json:"id"`
	LastChangedAt string                 `json:"last_changed_at"`
	Name          string                 `json:"name"`
	Parameters    map[string]interface{} `json:"parameters"`
	Rate          *int                   `json:"rate,omitempty"`
	StartedAt     string                 `json:"started_at"`
	Status        string                 `json:"status"`
	Steps         []Step                 `json:"steps"`
	VersionId     string                 `json:"version_id"`
	WorkNumber    string                 `json:"work_number"`
}

// EriusTasks defines model for EriusTasks.
type EriusTasks struct {
	Tasks *[]EriusTask `json:"tasks,omitempty"`
}

// EriusTasksPage defines model for EriusTasksPage.
type EriusTasksPage struct {
	Tasks []EriusTask `json:"tasks"`
	Total int         `json:"total"`
}

// EriusVersionInfo defines model for EriusVersionInfo.
type EriusVersionInfo struct {
	ApprovedAt string  `json:"approved_at"`
	Approver   *string `json:"approver,omitempty"`
	Author     string  `json:"author"`
	CreatedAt  string  `json:"created_at"`

	// IsActual If the version is currently used as an actual one
	IsActual bool `json:"is_actual"`

	// Status Tag status:
	//  * 1 - Draft
	//  * 2 - Approved
	//  * 3 - Deleted
	//  * 4 - Rejected
	//  * 5 - On approve
	Status    ScenarioStatus `json:"status"`
	UpdatedAt string         `json:"updated_at"`

	// UsageCount How many times is the version used as a subprocess
	UsageCount int                `json:"usage_count"`
	VersionId  openapi_types.UUID `json:"version_id"`
}

// ExecutableFunctionParams Chosen function to be executed
type ExecutableFunctionParams struct {
	// Mapping Маппинг переменных. Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Mapping MappingParam `json:"mapping"`

	// Name Function name
	Name string `json:"name"`

	// Version Used function version
	Version string `json:"version"`

	// WaitCorrectRes Days to wait correct answer
	WaitCorrectRes int `json:"waitCorrectRes"`
}

// ExecutionParams Execution params
type ExecutionParams struct {
	// CheckReworkSla Is rework SLA active
	CheckReworkSla bool `json:"check_rework_sla"`

	// CheckSla Is active SLA
	CheckSla bool `json:"check_sla"`

	// Executors Executor value (depends on type)
	Executors string `json:"executors"`

	// ExecutorsGroupId Executors group id in SD
	ExecutorsGroupId string `json:"executors_group_id"`

	// ExecutorsGroupName Executors group name in SD
	ExecutorsGroupName string `json:"executors_group_name"`

	// FormsAccessibility List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// IsEditable Show action edit application in SD
	IsEditable bool `json:"is_editable"`

	// RepeatPrevDecision auto apply prev decision
	RepeatPrevDecision bool `json:"repeat_prev_decision"`

	// ReworkSla Execution rework SLA (in working hours)
	ReworkSla int `json:"rework_sla"`

	// Sla Execution SLA (in working hours)
	Sla int `json:"sla"`

	// Type Execution type:
	//  * user - Single user
	//  * group - Execution group ID
	//  * from_schema - Selected by initiator
	Type ExecutionParamsType `json:"type"`
}

// ExecutionParamsType Execution type:
//   - user - Single user
//   - group - Execution group ID
//   - from_schema - Selected by initiator
type ExecutionParamsType string

// ExecutionUpdateParams Executor update params
type ExecutionUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment Comment from executor
	Comment string `json:"comment"`

	// Decision Executor decision:
	//  * executed - executor executed block
	//  * rejected - executor rejected block
	Decision ExecutionDecision `json:"decision"`
}

// ExecutorChangeParams Executor change params
type ExecutorChangeParams struct {
	Attachments []string `json:"attachments"`

	// Comment Comment from executor
	Comment string `json:"comment"`

	// NewExecutorLogin New executor login
	NewExecutorLogin string `json:"newExecutorLogin"`
}

// ExternalSystem defines model for ExternalSystem.
type ExternalSystem struct {
	// InputMapping Маппинг переменных. Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	InputMapping *MappingParam `json:"input_mapping,omitempty"`

	// InputSchema JSON-схема данных, которые отдаёт внешняя система
	InputSchema *string `json:"input_schema,omitempty"`

	// Name Название системы
	Name string `json:"name"`

	// OutputMapping Маппинг переменных. Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	OutputMapping *MappingParam `json:"output_mapping,omitempty"`

	// OutputSchema JSON-схема данных, которые принимает внешняя система
	OutputSchema *string `json:"output_schema,omitempty"`

	// SystemId Id внешней системы
	SystemId openapi_types.UUID `json:"system_id"`
}

// ExternalSystemId Id внешней системы
type ExternalSystemId = openapi_types.UUID

// FillFormUpdateParams Fill form
type FillFormUpdateParams struct {
	ApplicationBody map[string]interface{} `json:"application_body"`

	// BlockId Form block id
	BlockId string `json:"block_id"`

	// Description form data
	Description string `json:"description"`
}

// FormAccessType Form accessibility preferences for certain node
type FormAccessType string

// FormChangelogItem defines model for FormChangelogItem.
type FormChangelogItem struct {
	// ApplicationBody Filled form values
	ApplicationBody *map[string]interface{} `json:"application_body,omitempty"`

	// CreatedAt Date of log item creation
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Compiled field keys and values of form used for notifications
	Description *string `json:"description,omitempty"`

	// Executor Login of form executor
	Executor *string `json:"executor,omitempty"`

	// SchemaId id of form schema id
	SchemaId *string `json:"schema_id,omitempty"`
}

// FormExecutorType Form executor type:
//   - User - Single user
//   - Initiator - Process initiator
//   - From_schema - Selected by initiator
type FormExecutorType string

// FormParams Form params
type FormParams struct {
	// CheckSla Is active SLA
	CheckSla bool `json:"check_sla"`

	// Executor Executor value
	Executor *string `json:"executor,omitempty"`

	// FormExecutorType Form executor type:
	//   * User - Single user
	//   * Initiator - Process initiator
	//   * From_schema - Selected by initiator
	FormExecutorType *FormExecutorType `json:"form_executor_type,omitempty"`

	// FormsAccessibility List of accessibility properties for forms
	FormsAccessibility *[]FormsAccessibility `json:"forms_accessibility,omitempty"`

	// SchemaId form template id
	SchemaId *string `json:"schema_id,omitempty"`

	// SchemaName form template id name
	SchemaName *string `json:"schema_name,omitempty"`

	// Sla form sla
	Sla int `json:"sla"`
}

// FormsAccessibility defines model for FormsAccessibility.
type FormsAccessibility struct {
	// AccessType Form accessibility preferences for certain node
	AccessType FormAccessType `json:"accessType"`

	// Description Form short description
	Description *string `json:"description,omitempty"`

	// Name Form name
	Name string `json:"name"`

	// NodeId Form node ID
	NodeId string `json:"node_id"`
}

// FormsChangelogResponse Changelog of filled form data
type FormsChangelogResponse = []FormChangelogItem

// FunctionModel defines model for FunctionModel.
type FunctionModel struct {
	// BlockType Block type (language)
	BlockType BlockType             `json:"block_type"`
	Id        string                `json:"id"`
	Inputs    *[]FunctionValueModel `json:"inputs,omitempty"`
	Outputs   *[]FunctionValueModel `json:"outputs,omitempty"`
	Params    *FunctionParams       `json:"params,omitempty"`
	ShapeType int                   `json:"shape_type"`
	Sockets   []Socket              `json:"sockets"`
	Title     string                `json:"title"`
}

// FunctionParams defines model for FunctionParams.
type FunctionParams struct {
	// Params Block constant params
	Params *Params `json:"params,omitempty"`

	// Type Params type
	Type FunctionParamsType `json:"type"`
}

// FunctionParamsType Params type
type FunctionParamsType string

// FunctionValueModel defines model for FunctionValueModel.
type FunctionValueModel struct {
	Comment *string `json:"comment,omitempty"`
	Name    *string `json:"name,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// IntegerOperand Basic integer operand, can provide working compare types for this type
type IntegerOperand struct {
	DataType    IntegerOperandDataType    `json:"dataType"`
	OperandType IntegerOperandOperandType `json:"operandType"`
}

// IntegerOperandDataType defines model for IntegerOperand.DataType.
type IntegerOperandDataType string

// IntegerOperandOperandType defines model for IntegerOperand.OperandType.
type IntegerOperandOperandType string

// MappingParam Маппинг переменных. Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
type MappingParam map[string]struct {
	// Default Default value
	Default *MappingParam_Default `json:"default,omitempty"`

	// Description Description of param
	Description *string `json:"description,omitempty"`

	// Format Format of param
	Format *string `json:"format,omitempty"`

	// Items Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
	Items *MappingParamItems `json:"items,omitempty"`

	// Properties Маппинг переменных. Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Properties *MappingParam `json:"properties,omitempty"`

	// Required Is param required?
	Required *bool `json:"required,omitempty"`

	// Title Title of param
	Title string `json:"title"`

	// Type Type of param
	Type string `json:"type"`

	// Value Здесь хранится маппинг переменной, то место, откуда нужно взять значение переменной
	Value *string `json:"value,omitempty"`
}

// MappingParamItems Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
type MappingParamItems struct {
	// Items Описание типа, который хранится в массиве. Если type = object, тогда поле properties обязательное. Оно нужно для описание конкретного типа объектов, которые хранятся в массиве. Если type = array(многомерный массив у нас то есть), тогда поле items обязательное. Оно описывает тип массивов.
	Items *MappingParamItems `json:"items,omitempty"`

	// Properties Маппинг переменных. Представляет из себя набор ключ-значение, где ключ - это название переменной/поля объекта, а значение - это структура, которая описывает переменную(или поле объекта). Причём, если переменная - это объект, тогда должно быть заполнено поле propeties(описание полей). Если переменная - массив, тогда должно быть заполнено поле items(описание типа, который хранится в массиве).
	Properties *MappingParam `json:"properties,omitempty"`

	// Type Тип элементов массива
	Type string `json:"type"`
}

// MonitoringBlockOutput defines model for MonitoringBlockOutput.
type MonitoringBlockOutput struct {
	// Description Описание поля
	Description string `json:"description"`

	// Name Имя поля
	Name string `json:"name"`

	// Type Тип поля
	Type string `json:"type"`

	// Value Значение поля
	Value MonitoringBlockOutput_Value `json:"value"`
}

// MonitoringBlockOutputValue0 defines model for .
type MonitoringBlockOutputValue0 = string

// MonitoringBlockOutputValue1 defines model for .
type MonitoringBlockOutputValue1 = float32

// MonitoringBlockOutputValue2 defines model for .
type MonitoringBlockOutputValue2 = int

// MonitoringBlockOutputValue3 defines model for .
type MonitoringBlockOutputValue3 = []interface{}

// MonitoringBlockOutputValue4 defines model for .
type MonitoringBlockOutputValue4 = map[string]interface{}

// MonitoringBlockOutputValue5 defines model for .
type MonitoringBlockOutputValue5 = bool

// MonitoringBlockOutput_Value Значение поля
type MonitoringBlockOutput_Value struct {
	union json.RawMessage
}

// MonitoringBlockParam defines model for MonitoringBlockParam.
type MonitoringBlockParam struct {
	// Description Описание поля
	Description string `json:"description"`

	// Name Имя поля
	Name string `json:"name"`

	// Type Тип поля
	Type string `json:"type"`

	// Value Значение поля
	Value MonitoringBlockParam_Value `json:"value"`
}

// MonitoringBlockParamValue0 defines model for .
type MonitoringBlockParamValue0 = string

// MonitoringBlockParamValue1 defines model for .
type MonitoringBlockParamValue1 = float32

// MonitoringBlockParamValue2 defines model for .
type MonitoringBlockParamValue2 = int

// MonitoringBlockParamValue3 defines model for .
type MonitoringBlockParamValue3 = []interface{}

// MonitoringBlockParamValue4 defines model for .
type MonitoringBlockParamValue4 = map[string]interface{}

// MonitoringBlockParamValue5 defines model for .
type MonitoringBlockParamValue5 = bool

// MonitoringBlockParam_Value Значение поля
type MonitoringBlockParam_Value struct {
	union json.RawMessage
}

// MonitoringHistory defines model for MonitoringHistory.
type MonitoringHistory struct {
	// BlockDateInit Время перехода на конкретный блок
	BlockDateInit *string `json:"block_date_init,omitempty"`

	// BlockId Айди ноды в variable_storage
	BlockId openapi_types.UUID `json:"block_id"`

	// NodeId id ноды в заявке
	NodeId string `json:"node_id"`

	// RealName читаемое имя ноды
	RealName string `json:"real_name"`

	// Status Статус ноды
	Status MonitoringHistoryStatus `json:"status"`
}

// MonitoringHistoryStatus Статус ноды
type MonitoringHistoryStatus string

// MonitoringParamsResponse defines model for MonitoringParamsResponse.
type MonitoringParamsResponse struct {
	FinishedAt *string `json:"finished_at,omitempty"`

	// Inputs Входные параметы
	Inputs *map[string]MonitoringBlockParam `json:"inputs,omitempty"`

	// Outputs Выходные параметы
	Outputs   *map[string]MonitoringBlockParam `json:"outputs,omitempty"`
	StartedAt *string                          `json:"started_at,omitempty"`
}

// MonitoringScenarioInfo defines model for MonitoringScenarioInfo.
type MonitoringScenarioInfo struct {
	// Author Автор сценария
	Author string `json:"author"`

	// CreationTime Время создания сценария
	CreationTime string `json:"creation_time"`

	// ScenarioName Имя сценария
	ScenarioName string `json:"scenario_name"`
}

// MonitoringTableTask defines model for MonitoringTableTask.
type MonitoringTableTask struct {
	FinishedAt string `json:"finished_at"`

	// Initiator login of initiator
	Initiator string `json:"initiator"`

	// InitiatorFullname fullname of the initiator
	InitiatorFullname string `json:"initiator_fullname"`

	// ProcessName name of the process
	ProcessName string `json:"process_name"`
	StartedAt   string `json:"started_at"`

	// Status task status
	Status     MonitoringTableTaskStatus `json:"status"`
	WorkNumber string                    `json:"work_number"`
}

// MonitoringTableTaskStatus task status
type MonitoringTableTaskStatus string

// MonitoringTask defines model for MonitoringTask.
type MonitoringTask struct {
	History      []MonitoringHistory    `json:"history"`
	ScenarioInfo MonitoringScenarioInfo `json:"scenario_info"`

	// VersionId Айди версии сценария для мониторинга
	VersionId openapi_types.UUID `json:"version_id"`

	// WorkNumber Номер заявки для мониторинга
	WorkNumber string `json:"work_number"`
}

// MonitoringTasksPage defines model for MonitoringTasksPage.
type MonitoringTasksPage struct {
	Tasks []MonitoringTableTask `json:"tasks"`

	// Total total number of tasks
	Total int `json:"total"`
}

// NotificationParams Notification params
type NotificationParams struct {
	// Emails Emails to get notifications
	Emails []string `json:"emails"`

	// People People to get notifications
	People []string `json:"people"`

	// Subject Notification subject
	Subject string `json:"subject"`

	// Text Notification body
	Text string `json:"text"`
}

// NumberOperand Basic number operand, can provide working compare types for this type
type NumberOperand struct {
	DataType    NumberOperandDataType    `json:"dataType"`
	OperandType NumberOperandOperandType `json:"operandType"`
}

// NumberOperandDataType defines model for NumberOperand.DataType.
type NumberOperandDataType string

// NumberOperandOperandType defines model for NumberOperand.OperandType.
type NumberOperandOperandType string

// Params Block constant params
type Params struct {
	union json.RawMessage
}

// ProcessSettings Настройки старта версии пайплайна(процесса)
type ProcessSettings struct {
	// EndSchema JSON-схема выходных параметров пайплайна
	EndSchema string `json:"end_schema"`

	// StartSchema JSON-схема входных параметров пайплайна
	StartSchema string `json:"start_schema"`

	// VersionId Id версии процесса
	VersionId *openapi_types.UUID `json:"version_id,omitempty"`
}

// ProcessSettingsWithExternalSystems Настройки старта версии пайплайна(процесса)
type ProcessSettingsWithExternalSystems struct {
	// ExternalSystems Внешние системы, которые используют данный пайплайн
	ExternalSystems []ExternalSystem `json:"external_systems"`

	// ProcessSettings Настройки старта версии пайплайна(процесса)
	ProcessSettings ProcessSettings `json:"process_settings"`
}

// RateApplicationRequest defines model for RateApplicationRequest.
type RateApplicationRequest struct {
	Comment *string `json:"comment,omitempty"`
	Rate    *int    `json:"rate,omitempty"`
}

// RequestExecutionInfoType Type of execution info
type RequestExecutionInfoType string

// RequestInfoUpdateParams Executor request info params
type RequestInfoUpdateParams struct {
	Attachments []string `json:"attachments"`

	// Comment Comment from executor
	Comment string `json:"comment"`

	// ExecutorLogin executor login
	ExecutorLogin string `json:"executorLogin"`

	// ReqType Type of execution info
	ReqType RequestExecutionInfoType `json:"reqType"`
}

// ResponsePipelineSearch defines model for ResponsePipelineSearch.
type ResponsePipelineSearch struct {
	// Items list of pipelines
	Items []SearchPipelineItem `json:"items"`
	Total int                  `json:"total"`
}

// RunNewVersionByPrevVersionRequest defines model for RunNewVersionByPrevVersionRequest.
type RunNewVersionByPrevVersionRequest struct {
	ApplicationBody  map[string]interface{} `json:"application_body"`
	AttachmentFields []string               `json:"attachment_fields"`
	Description      string                 `json:"description"`
	Keys             map[string]string      `json:"keys"`
	WorkNumber       string                 `json:"work_number"`
}

// RunPipelineBody defines model for RunPipelineBody.
type RunPipelineBody = map[string]interface{}

// RunResponse defines model for RunResponse.
type RunResponse struct {
	Errors     []string               `json:"errors"`
	Output     map[string]interface{} `json:"output"`
	PipelineId openapi_types.UUID     `json:"pipeline_id"`
	Status     string                 `json:"status"`
	WorkNumber string                 `json:"work_number"`
}

// RunVersionBody defines model for RunVersionBody.
type RunVersionBody = map[string]interface{}

// RunVersionsByPipelineIdRequest defines model for RunVersionsByPipelineIdRequest.
type RunVersionsByPipelineIdRequest struct {
	ApplicationBody   map[string]interface{} `json:"application_body"`
	AttachmentFields  []string               `json:"attachment_fields"`
	Description       string                 `json:"description"`
	IsTestApplication *bool                  `json:"is_test_application,omitempty"`
	Keys              map[string]string      `json:"keys"`
	PipelineId        string                 `json:"pipeline_id"`
}

// ScenarioVersionInfoList defines model for ScenarioVersionInfoList.
type ScenarioVersionInfoList = []EriusVersionInfo

// SchedulerTasksResponse defines model for SchedulerTasksResponse.
type SchedulerTasksResponse struct {
	// Result If active tasks exist
	Result bool `json:"result"`
}

// SdApplicationParams SD Application params
type SdApplicationParams struct {
	// BlueprintId Template application ID
	BlueprintId string `json:"blueprint_id"`
}

// SearchPipelineItem defines model for SearchPipelineItem.
type SearchPipelineItem struct {
	// Name Имя пайплайна
	Name *string `json:"name,omitempty"`

	// PipelineId ID пайплайна
	PipelineId *openapi_types.UUID `json:"pipeline_id,omitempty"`
}

// ShapeEntity defines model for ShapeEntity.
type ShapeEntity struct {
	Icon  string `json:"icon"`
	Id    int    `json:"id"`
	Title string `json:"title"`
}

// Socket Socket object
type Socket struct {
	// ActionType action type
	ActionType *SocketActionType `json:"actionType,omitempty"`

	// Id Id of socket
	Id string `json:"id"`

	// NextBlockIds IDs of next blocks
	NextBlockIds *[]string `json:"nextBlockIds,omitempty"`

	// Title User-friendly title of socket for user
	Title *string `json:"title,omitempty"`
}

// SocketActionType action type
type SocketActionType string

// Step defines model for Step.
type Step struct {
	Errors   []string               `json:"errors"`
	HasError bool                   `json:"has_error"`
	Name     string                 `json:"name"`
	State    map[string]interface{} `json:"state"`

	// Status Task step execution status
	Status  StepStatus             `json:"status"`
	Steps   []string               `json:"steps"`
	Storage map[string]interface{} `json:"storage"`
	Time    string                 `json:"time"`
	Type    string                 `json:"type"`
}

// StepStatus Task step execution status
type StepStatus string

// StringOperand Basic string operand, can provide working compare types for this type
type StringOperand struct {
	DataType    StringOperandDataType    `json:"dataType"`
	OperandType StringOperandOperandType `json:"operandType"`
}

// StringOperandDataType defines model for StringOperand.DataType.
type StringOperandDataType string

// StringOperandOperandType defines model for StringOperand.OperandType.
type StringOperandOperandType string

// TaskMeanSolveTime defines model for TaskMeanSolveTime.
type TaskMeanSolveTime struct {
	MeanWorkHours float32 `json:"meanWorkHours"`
}

// TaskUpdate defines model for TaskUpdate.
type TaskUpdate struct {
	Action TaskUpdateAction `json:"action"`

	// Parameters Task update params
	Parameters TaskUpdate_Parameters `json:"parameters"`
}

// TaskUpdateAction defines model for TaskUpdate.Action.
type TaskUpdateAction string

// TaskUpdate_Parameters Task update params
type TaskUpdate_Parameters struct {
	union json.RawMessage
}

// UsageResponse defines model for UsageResponse.
type UsageResponse struct {
	// Name Имя блока
	Name      string   `json:"name"`
	Pipelines []UsedBy `json:"pipelines"`
	Used      bool     `json:"used"`
}

// UsedBy defines model for UsedBy.
type UsedBy struct {
	// Id ID сценария
	Id string `json:"id"`

	// Name Имя сценария
	Name string `json:"name"`
}

// Action defines model for action.
type Action struct {
	// AttachmentsEnabled Возможность прикреплять вложение к действию
	AttachmentsEnabled bool `json:"attachments_enabled"`

	// ButtonType Тип отображаемой кнопки (primary, secondary, other, none)
	ButtonType string `json:"button_type"`

	// CommentEnabled Возможность прикреплять комментарий к действию
	CommentEnabled bool `json:"comment_enabled"`

	// Id UUID действия
	Id string `json:"id"`

	// Title Человекочитаемое наименование действия
	Title *string `json:"title,omitempty"`
}

// AdditionalApproverDecision Approver decision:
//   - approved - Согласовать
//   - rejected - Отклонить
type AdditionalApproverDecision string

// ApproverDecision Approver decision:
//   - approve - Согласовать
//   - reject - Отклонить
//   - viewed - Ознакомлен
//   - informed - Проинформирован
//   - sign - Подписать
//   - confirm - Утвердить
type ApproverDecision string

// BlockType Block type (language)
type BlockType string

// CompareBooleanOperator Used operator to compare bool operands
type CompareBooleanOperator string

// CompareDateOperator Used operator to compare date operands
type CompareDateOperator string

// CompareIntegerOperator Used operator to compare integer operands
type CompareIntegerOperator string

// CompareNumberOperator Used operator to compare number operands
type CompareNumberOperator string

// CompareStringOperator Used operator to compare string operands
type CompareStringOperator string

// EriusTaskResponse defines model for eriusTaskResponse.
type EriusTaskResponse struct {
	// Author Логин инициатора
	Author string `json:"author"`

	// AvailableActions Доступные действия
	AvailableActions *[]Action `json:"available_actions,omitempty"`

	// BlueprintId ID шаблона SD, на основании которого запускалась заявка
	BlueprintId string `json:"blueprint_id"`

	// Debug Запускалась ли заявка в режиме отладки
	Debug bool `json:"debug"`

	// Description Описание заявки (основной текст)
	Description string `json:"description"`

	// FinishedAt Время окончания заявки
	FinishedAt *string `json:"finished_at,omitempty"`

	// HumanStatus Task human readable status
	HumanStatus TaskHumanStatus `json:"human_status"`

	// Id ID заявки
	Id string `json:"id"`

	// LastChangedAt Время последнего изменения
	LastChangedAt string `json:"last_changed_at"`

	// Name Название заявки
	Name string `json:"name"`

	// Parameters Параметры заявки
	Parameters map[string]interface{} `json:"parameters"`

	// Rate Оценка для выполненной заявки
	Rate int `json:"rate"`

	// RateComment Комментарий к оценке
	RateComment string `json:"rate_comment"`

	// StartedAt Время начала исполнения заявки
	StartedAt string `json:"started_at"`

	// Status Технический статус заявки
	Status EriusTaskResponseStatus `json:"status"`
	Steps  []TaskResponseStep      `json:"steps"`

	// VersionId Версия процесса заявки
	VersionId string `json:"version_id"`

	// WorkNumber Номер заявки
	WorkNumber string `json:"work_number"`
}

// EriusTaskResponseStatus Технический статус заявки
type EriusTaskResponseStatus string

// ExecutionDecision Executor decision:
//   - executed - executor executed block
//   - rejected - executor rejected block
type ExecutionDecision string

// HttpError defines model for httpError.
type HttpError struct {
	Description *string `json:"description,omitempty"`
	Error       *string `json:"error,omitempty"`
	StatusCode  *int    `json:"status_code,omitempty"`
}

// HttpResponse defines model for httpResponse.
type HttpResponse struct {
	Data       *map[string]interface{} `json:"data,omitempty"`
	StatusCode int                     `json:"status_code"`
}

// Operand Operand for comparison
type Operand struct {
	union json.RawMessage
}

// Pipeline defines model for pipeline.
type Pipeline struct {
	Blocks     map[string]EriusFunc `json:"blocks"`
	Entrypoint string               `json:"entrypoint"`
}

// PipelineRename defines model for pipelineRename.
type PipelineRename struct {
	// Id ID сценария для переименования
	Id openapi_types.UUID `json:"id"`

	// Name Новое имя сценария
	Name string `json:"name"`
}

// ScenarioStatus Tag status:
//   - 1 - Draft
//   - 2 - Approved
//   - 3 - Deleted
//   - 4 - Rejected
//   - 5 - On approve
type ScenarioStatus int

// TaskHumanStatus Task human readable status
type TaskHumanStatus string

// TaskResponseStep defines model for taskResponseStep.
type TaskResponseStep struct {
	// Errors Массив ошибок
	Errors *[]string `json:"errors,omitempty"`

	// HasError Была ли ошибка
	HasError *bool `json:"has_error,omitempty"`

	// IsDelegateOfAnyStepMember Является ли пользователь, запрашивающий заявку, делегатом кого-либо на этом шаге
	IsDelegateOfAnyStepMember *bool `json:"is_delegate_of_any_step_member,omitempty"`

	// Name Наименование шага
	Name *string `json:"name,omitempty"`

	// State Объект состояния
	State *map[string]interface{} `json:"state,omitempty"`

	// Status Статус шага
	Status  *string                 `json:"status,omitempty"`
	Steps   *[]string               `json:"steps,omitempty"`
	Storage *map[string]interface{} `json:"storage,omitempty"`
	Time    *string                 `json:"time,omitempty"`
	Type    *string                 `json:"type,omitempty"`
}

// ValueOperand defines model for valueOperand.
type ValueOperand struct {
	Value string `json:"value"`
	union json.RawMessage
}

// VariableOperand defines model for variableOperand.
type VariableOperand struct {
	VariableRef string `json:"variableRef"`
	union       json.RawMessage
}

// GetFormsChangelogParams defines parameters for GetFormsChangelog.
type GetFormsChangelogParams struct {
	// WorkNumber Work number
	WorkNumber string `form:"work_number" json:"work_number"`

	// BlockId Id of form block (name)
	BlockId string `form:"block_id" json:"block_id"`
}

// GetTasksForMonitoringParams defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParams struct {
	PerPage    *int                                   `form:"per_page,omitempty" json:"per_page,omitempty"`
	Page       *int                                   `form:"page,omitempty" json:"page,omitempty"`
	SortColumn *GetTasksForMonitoringParamsSortColumn `form:"sort.column,omitempty" json:"sort.column,omitempty"`
	SortOrder  *GetTasksForMonitoringParamsSortOrder  `form:"sort.order,omitempty" json:"sort.order,omitempty"`

	// Filter Фильтр по work_number, наименованию процесса, логину инициатора
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// FromDate Фильтровать по дате, начало периода
	FromDate *string `form:"from_date,omitempty" json:"from_date,omitempty"`

	// ToDate Фильтровать по дате, конец периода
	ToDate *string `form:"to_date,omitempty" json:"to_date,omitempty"`

	// Status Фильтровать по статусу заявки
	Status *[]GetTasksForMonitoringParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetTasksForMonitoringParamsSortColumn defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParamsSortColumn string

// GetTasksForMonitoringParamsSortOrder defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParamsSortOrder string

// GetTasksForMonitoringParamsStatus defines parameters for GetTasksForMonitoring.
type GetTasksForMonitoringParamsStatus string

// ListPipelinesParams defines parameters for ListPipelines.
type ListPipelinesParams struct {
	// My Show my pipelines only
	My *bool `form:"my,omitempty" json:"my,omitempty"`
}

// SearchPipelinesParams defines parameters for SearchPipelines.
type SearchPipelinesParams struct {
	// PipelineName имя пайплайна
	PipelineName *string `form:"pipelineName,omitempty" json:"pipelineName,omitempty"`

	// PipelineId id пайплайна
	PipelineId *openapi_types.UUID `form:"pipelineId,omitempty" json:"pipelineId,omitempty"`

	// Page страница для отображения
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage сколько отображать на одной странице
	PerPage *int `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// SaveVersionSettingsParams defines parameters for SaveVersionSettings.
type SaveVersionSettingsParams struct {
	// SchemaFlag Флаг JSON-схемы, которую нужно сохранить
	SchemaFlag *SaveVersionSettingsParamsSchemaFlag `form:"schema_flag,omitempty" json:"schema_flag,omitempty"`
}

// SaveVersionSettingsParamsSchemaFlag defines parameters for SaveVersionSettings.
type SaveVersionSettingsParamsSchemaFlag string

// SaveExternalSystemSettingsParams defines parameters for SaveExternalSystemSettings.
type SaveExternalSystemSettingsParams struct {
	// SchemaFlag Флаг JSON-схемы, которую нужно сохранить
	SchemaFlag *SaveExternalSystemSettingsParamsSchemaFlag `form:"schema_flag,omitempty" json:"schema_flag,omitempty"`
}

// SaveExternalSystemSettingsParamsSchemaFlag defines parameters for SaveExternalSystemSettings.
type SaveExternalSystemSettingsParamsSchemaFlag string

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Name Pipeline name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// TaskIDs Task IDs
	TaskIDs *[]string `form:"taskIDs,omitempty" json:"taskIDs,omitempty"`

	// Order Order
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset
	Offset   *int     `form:"offset,omitempty" json:"offset,omitempty"`
	Created  *Created `form:"created,omitempty" json:"created,omitempty"`
	Archived *bool    `form:"archived,omitempty" json:"archived,omitempty"`
	SelectAs *string  `form:"selectAs,omitempty" json:"selectAs,omitempty"`

	// ForCarousel get tasks with status wait or done
	ForCarousel *bool `form:"forCarousel,omitempty" json:"forCarousel,omitempty"`

	// Status get tasks with different statuses
	Status *[]string `form:"status,omitempty" json:"status,omitempty"`

	// Receiver receiver login
	Receiver *string `form:"receiver,omitempty" json:"receiver,omitempty"`

	// HasAttachments filter for attachments
	HasAttachments *bool `form:"hasAttachments,omitempty" json:"hasAttachments,omitempty"`
}

// RateApplicationJSONRequestBody defines body for RateApplication for application/json ContentType.
type RateApplicationJSONRequestBody = RateApplicationRequest

// SetApplicationJSONRequestBody defines body for SetApplication for application/json ContentType.
type SetApplicationJSONRequestBody = Application

// StartDebugTaskJSONRequestBody defines body for StartDebugTask for application/json ContentType.
type StartDebugTaskJSONRequestBody = DebugRunRequest

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody = EriusScenario

// CopyPipelineJSONRequestBody defines body for CopyPipeline for application/json ContentType.
type CopyPipelineJSONRequestBody = EriusScenario

// RenamePipelineJSONRequestBody defines body for RenamePipeline for application/json ContentType.
type RenamePipelineJSONRequestBody = PipelineRename

// EditVersionJSONRequestBody defines body for EditVersion for application/json ContentType.
type EditVersionJSONRequestBody = EriusScenario

// CreatePipelineVersionJSONRequestBody defines body for CreatePipelineVersion for application/json ContentType.
type CreatePipelineVersionJSONRequestBody = EriusScenario

// SaveVersionSettingsJSONRequestBody defines body for SaveVersionSettings for application/json ContentType.
type SaveVersionSettingsJSONRequestBody = ProcessSettings

// AddExternalSystemToVersionJSONRequestBody defines body for AddExternalSystemToVersion for application/json ContentType.
type AddExternalSystemToVersionJSONRequestBody = ExternalSystemId

// SaveExternalSystemSettingsJSONRequestBody defines body for SaveExternalSystemSettings for application/json ContentType.
type SaveExternalSystemSettingsJSONRequestBody = ExternalSystem

// RunNewVersionByPrevVersionJSONRequestBody defines body for RunNewVersionByPrevVersion for application/json ContentType.
type RunNewVersionByPrevVersionJSONRequestBody = RunNewVersionByPrevVersionRequest

// RunVersionJSONRequestBody defines body for RunVersion for application/json ContentType.
type RunVersionJSONRequestBody = RunVersionBody

// RunVersionsByPipelineIdJSONRequestBody defines body for RunVersionsByPipelineId for application/json ContentType.
type RunVersionsByPipelineIdJSONRequestBody = RunVersionsByPipelineIdRequest

// RunPipelineJSONRequestBody defines body for RunPipeline for application/json ContentType.
type RunPipelineJSONRequestBody = RunPipelineBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = EriusTagInfo

// EditTagJSONRequestBody defines body for EditTag for application/json ContentType.
type EditTagJSONRequestBody = EriusTagInfo

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody = TaskUpdate

// AsCompareStringOperator returns the union data inside the Condition_Operator as a CompareStringOperator
func (t Condition_Operator) AsCompareStringOperator() (CompareStringOperator, error) {
	var body CompareStringOperator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompareStringOperator overwrites any union data inside the Condition_Operator as the provided CompareStringOperator
func (t *Condition_Operator) FromCompareStringOperator(v CompareStringOperator) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompareStringOperator performs a merge with any union data inside the Condition_Operator, using the provided CompareStringOperator
func (t *Condition_Operator) MergeCompareStringOperator(v CompareStringOperator) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCompareIntegerOperator returns the union data inside the Condition_Operator as a CompareIntegerOperator
func (t Condition_Operator) AsCompareIntegerOperator() (CompareIntegerOperator, error) {
	var body CompareIntegerOperator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompareIntegerOperator overwrites any union data inside the Condition_Operator as the provided CompareIntegerOperator
func (t *Condition_Operator) FromCompareIntegerOperator(v CompareIntegerOperator) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompareIntegerOperator performs a merge with any union data inside the Condition_Operator, using the provided CompareIntegerOperator
func (t *Condition_Operator) MergeCompareIntegerOperator(v CompareIntegerOperator) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCompareNumberOperator returns the union data inside the Condition_Operator as a CompareNumberOperator
func (t Condition_Operator) AsCompareNumberOperator() (CompareNumberOperator, error) {
	var body CompareNumberOperator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompareNumberOperator overwrites any union data inside the Condition_Operator as the provided CompareNumberOperator
func (t *Condition_Operator) FromCompareNumberOperator(v CompareNumberOperator) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompareNumberOperator performs a merge with any union data inside the Condition_Operator, using the provided CompareNumberOperator
func (t *Condition_Operator) MergeCompareNumberOperator(v CompareNumberOperator) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCompareBooleanOperator returns the union data inside the Condition_Operator as a CompareBooleanOperator
func (t Condition_Operator) AsCompareBooleanOperator() (CompareBooleanOperator, error) {
	var body CompareBooleanOperator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompareBooleanOperator overwrites any union data inside the Condition_Operator as the provided CompareBooleanOperator
func (t *Condition_Operator) FromCompareBooleanOperator(v CompareBooleanOperator) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompareBooleanOperator performs a merge with any union data inside the Condition_Operator, using the provided CompareBooleanOperator
func (t *Condition_Operator) MergeCompareBooleanOperator(v CompareBooleanOperator) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCompareDateOperator returns the union data inside the Condition_Operator as a CompareDateOperator
func (t Condition_Operator) AsCompareDateOperator() (CompareDateOperator, error) {
	var body CompareDateOperator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompareDateOperator overwrites any union data inside the Condition_Operator as the provided CompareDateOperator
func (t *Condition_Operator) FromCompareDateOperator(v CompareDateOperator) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompareDateOperator performs a merge with any union data inside the Condition_Operator, using the provided CompareDateOperator
func (t *Condition_Operator) MergeCompareDateOperator(v CompareDateOperator) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Condition_Operator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Condition_Operator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMonitoringBlockOutputValue0 returns the union data inside the MonitoringBlockOutput_Value as a MonitoringBlockOutputValue0
func (t MonitoringBlockOutput_Value) AsMonitoringBlockOutputValue0() (MonitoringBlockOutputValue0, error) {
	var body MonitoringBlockOutputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockOutputValue0 overwrites any union data inside the MonitoringBlockOutput_Value as the provided MonitoringBlockOutputValue0
func (t *MonitoringBlockOutput_Value) FromMonitoringBlockOutputValue0(v MonitoringBlockOutputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockOutputValue0 performs a merge with any union data inside the MonitoringBlockOutput_Value, using the provided MonitoringBlockOutputValue0
func (t *MonitoringBlockOutput_Value) MergeMonitoringBlockOutputValue0(v MonitoringBlockOutputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockOutputValue1 returns the union data inside the MonitoringBlockOutput_Value as a MonitoringBlockOutputValue1
func (t MonitoringBlockOutput_Value) AsMonitoringBlockOutputValue1() (MonitoringBlockOutputValue1, error) {
	var body MonitoringBlockOutputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockOutputValue1 overwrites any union data inside the MonitoringBlockOutput_Value as the provided MonitoringBlockOutputValue1
func (t *MonitoringBlockOutput_Value) FromMonitoringBlockOutputValue1(v MonitoringBlockOutputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockOutputValue1 performs a merge with any union data inside the MonitoringBlockOutput_Value, using the provided MonitoringBlockOutputValue1
func (t *MonitoringBlockOutput_Value) MergeMonitoringBlockOutputValue1(v MonitoringBlockOutputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockOutputValue2 returns the union data inside the MonitoringBlockOutput_Value as a MonitoringBlockOutputValue2
func (t MonitoringBlockOutput_Value) AsMonitoringBlockOutputValue2() (MonitoringBlockOutputValue2, error) {
	var body MonitoringBlockOutputValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockOutputValue2 overwrites any union data inside the MonitoringBlockOutput_Value as the provided MonitoringBlockOutputValue2
func (t *MonitoringBlockOutput_Value) FromMonitoringBlockOutputValue2(v MonitoringBlockOutputValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockOutputValue2 performs a merge with any union data inside the MonitoringBlockOutput_Value, using the provided MonitoringBlockOutputValue2
func (t *MonitoringBlockOutput_Value) MergeMonitoringBlockOutputValue2(v MonitoringBlockOutputValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockOutputValue3 returns the union data inside the MonitoringBlockOutput_Value as a MonitoringBlockOutputValue3
func (t MonitoringBlockOutput_Value) AsMonitoringBlockOutputValue3() (MonitoringBlockOutputValue3, error) {
	var body MonitoringBlockOutputValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockOutputValue3 overwrites any union data inside the MonitoringBlockOutput_Value as the provided MonitoringBlockOutputValue3
func (t *MonitoringBlockOutput_Value) FromMonitoringBlockOutputValue3(v MonitoringBlockOutputValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockOutputValue3 performs a merge with any union data inside the MonitoringBlockOutput_Value, using the provided MonitoringBlockOutputValue3
func (t *MonitoringBlockOutput_Value) MergeMonitoringBlockOutputValue3(v MonitoringBlockOutputValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockOutputValue4 returns the union data inside the MonitoringBlockOutput_Value as a MonitoringBlockOutputValue4
func (t MonitoringBlockOutput_Value) AsMonitoringBlockOutputValue4() (MonitoringBlockOutputValue4, error) {
	var body MonitoringBlockOutputValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockOutputValue4 overwrites any union data inside the MonitoringBlockOutput_Value as the provided MonitoringBlockOutputValue4
func (t *MonitoringBlockOutput_Value) FromMonitoringBlockOutputValue4(v MonitoringBlockOutputValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockOutputValue4 performs a merge with any union data inside the MonitoringBlockOutput_Value, using the provided MonitoringBlockOutputValue4
func (t *MonitoringBlockOutput_Value) MergeMonitoringBlockOutputValue4(v MonitoringBlockOutputValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockOutputValue5 returns the union data inside the MonitoringBlockOutput_Value as a MonitoringBlockOutputValue5
func (t MonitoringBlockOutput_Value) AsMonitoringBlockOutputValue5() (MonitoringBlockOutputValue5, error) {
	var body MonitoringBlockOutputValue5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockOutputValue5 overwrites any union data inside the MonitoringBlockOutput_Value as the provided MonitoringBlockOutputValue5
func (t *MonitoringBlockOutput_Value) FromMonitoringBlockOutputValue5(v MonitoringBlockOutputValue5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockOutputValue5 performs a merge with any union data inside the MonitoringBlockOutput_Value, using the provided MonitoringBlockOutputValue5
func (t *MonitoringBlockOutput_Value) MergeMonitoringBlockOutputValue5(v MonitoringBlockOutputValue5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t MonitoringBlockOutput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitoringBlockOutput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMonitoringBlockParamValue0 returns the union data inside the MonitoringBlockParam_Value as a MonitoringBlockParamValue0
func (t MonitoringBlockParam_Value) AsMonitoringBlockParamValue0() (MonitoringBlockParamValue0, error) {
	var body MonitoringBlockParamValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockParamValue0 overwrites any union data inside the MonitoringBlockParam_Value as the provided MonitoringBlockParamValue0
func (t *MonitoringBlockParam_Value) FromMonitoringBlockParamValue0(v MonitoringBlockParamValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockParamValue0 performs a merge with any union data inside the MonitoringBlockParam_Value, using the provided MonitoringBlockParamValue0
func (t *MonitoringBlockParam_Value) MergeMonitoringBlockParamValue0(v MonitoringBlockParamValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockParamValue1 returns the union data inside the MonitoringBlockParam_Value as a MonitoringBlockParamValue1
func (t MonitoringBlockParam_Value) AsMonitoringBlockParamValue1() (MonitoringBlockParamValue1, error) {
	var body MonitoringBlockParamValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockParamValue1 overwrites any union data inside the MonitoringBlockParam_Value as the provided MonitoringBlockParamValue1
func (t *MonitoringBlockParam_Value) FromMonitoringBlockParamValue1(v MonitoringBlockParamValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockParamValue1 performs a merge with any union data inside the MonitoringBlockParam_Value, using the provided MonitoringBlockParamValue1
func (t *MonitoringBlockParam_Value) MergeMonitoringBlockParamValue1(v MonitoringBlockParamValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockParamValue2 returns the union data inside the MonitoringBlockParam_Value as a MonitoringBlockParamValue2
func (t MonitoringBlockParam_Value) AsMonitoringBlockParamValue2() (MonitoringBlockParamValue2, error) {
	var body MonitoringBlockParamValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockParamValue2 overwrites any union data inside the MonitoringBlockParam_Value as the provided MonitoringBlockParamValue2
func (t *MonitoringBlockParam_Value) FromMonitoringBlockParamValue2(v MonitoringBlockParamValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockParamValue2 performs a merge with any union data inside the MonitoringBlockParam_Value, using the provided MonitoringBlockParamValue2
func (t *MonitoringBlockParam_Value) MergeMonitoringBlockParamValue2(v MonitoringBlockParamValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockParamValue3 returns the union data inside the MonitoringBlockParam_Value as a MonitoringBlockParamValue3
func (t MonitoringBlockParam_Value) AsMonitoringBlockParamValue3() (MonitoringBlockParamValue3, error) {
	var body MonitoringBlockParamValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockParamValue3 overwrites any union data inside the MonitoringBlockParam_Value as the provided MonitoringBlockParamValue3
func (t *MonitoringBlockParam_Value) FromMonitoringBlockParamValue3(v MonitoringBlockParamValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockParamValue3 performs a merge with any union data inside the MonitoringBlockParam_Value, using the provided MonitoringBlockParamValue3
func (t *MonitoringBlockParam_Value) MergeMonitoringBlockParamValue3(v MonitoringBlockParamValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockParamValue4 returns the union data inside the MonitoringBlockParam_Value as a MonitoringBlockParamValue4
func (t MonitoringBlockParam_Value) AsMonitoringBlockParamValue4() (MonitoringBlockParamValue4, error) {
	var body MonitoringBlockParamValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockParamValue4 overwrites any union data inside the MonitoringBlockParam_Value as the provided MonitoringBlockParamValue4
func (t *MonitoringBlockParam_Value) FromMonitoringBlockParamValue4(v MonitoringBlockParamValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockParamValue4 performs a merge with any union data inside the MonitoringBlockParam_Value, using the provided MonitoringBlockParamValue4
func (t *MonitoringBlockParam_Value) MergeMonitoringBlockParamValue4(v MonitoringBlockParamValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMonitoringBlockParamValue5 returns the union data inside the MonitoringBlockParam_Value as a MonitoringBlockParamValue5
func (t MonitoringBlockParam_Value) AsMonitoringBlockParamValue5() (MonitoringBlockParamValue5, error) {
	var body MonitoringBlockParamValue5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitoringBlockParamValue5 overwrites any union data inside the MonitoringBlockParam_Value as the provided MonitoringBlockParamValue5
func (t *MonitoringBlockParam_Value) FromMonitoringBlockParamValue5(v MonitoringBlockParamValue5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitoringBlockParamValue5 performs a merge with any union data inside the MonitoringBlockParam_Value, using the provided MonitoringBlockParamValue5
func (t *MonitoringBlockParam_Value) MergeMonitoringBlockParamValue5(v MonitoringBlockParamValue5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t MonitoringBlockParam_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitoringBlockParam_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApproverParams returns the union data inside the Params as a ApproverParams
func (t Params) AsApproverParams() (ApproverParams, error) {
	var body ApproverParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApproverParams overwrites any union data inside the Params as the provided ApproverParams
func (t *Params) FromApproverParams(v ApproverParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApproverParams performs a merge with any union data inside the Params, using the provided ApproverParams
func (t *Params) MergeApproverParams(v ApproverParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExecutionParams returns the union data inside the Params as a ExecutionParams
func (t Params) AsExecutionParams() (ExecutionParams, error) {
	var body ExecutionParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecutionParams overwrites any union data inside the Params as the provided ExecutionParams
func (t *Params) FromExecutionParams(v ExecutionParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExecutionParams performs a merge with any union data inside the Params, using the provided ExecutionParams
func (t *Params) MergeExecutionParams(v ExecutionParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExecutableFunctionParams returns the union data inside the Params as a ExecutableFunctionParams
func (t Params) AsExecutableFunctionParams() (ExecutableFunctionParams, error) {
	var body ExecutableFunctionParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecutableFunctionParams overwrites any union data inside the Params as the provided ExecutableFunctionParams
func (t *Params) FromExecutableFunctionParams(v ExecutableFunctionParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExecutableFunctionParams performs a merge with any union data inside the Params, using the provided ExecutableFunctionParams
func (t *Params) MergeExecutableFunctionParams(v ExecutableFunctionParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSdApplicationParams returns the union data inside the Params as a SdApplicationParams
func (t Params) AsSdApplicationParams() (SdApplicationParams, error) {
	var body SdApplicationParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSdApplicationParams overwrites any union data inside the Params as the provided SdApplicationParams
func (t *Params) FromSdApplicationParams(v SdApplicationParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSdApplicationParams performs a merge with any union data inside the Params, using the provided SdApplicationParams
func (t *Params) MergeSdApplicationParams(v SdApplicationParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNotificationParams returns the union data inside the Params as a NotificationParams
func (t Params) AsNotificationParams() (NotificationParams, error) {
	var body NotificationParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationParams overwrites any union data inside the Params as the provided NotificationParams
func (t *Params) FromNotificationParams(v NotificationParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationParams performs a merge with any union data inside the Params, using the provided NotificationParams
func (t *Params) MergeNotificationParams(v NotificationParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsConditionParams returns the union data inside the Params as a ConditionParams
func (t Params) AsConditionParams() (ConditionParams, error) {
	var body ConditionParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConditionParams overwrites any union data inside the Params as the provided ConditionParams
func (t *Params) FromConditionParams(v ConditionParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConditionParams performs a merge with any union data inside the Params, using the provided ConditionParams
func (t *Params) MergeConditionParams(v ConditionParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFormParams returns the union data inside the Params as a FormParams
func (t Params) AsFormParams() (FormParams, error) {
	var body FormParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormParams overwrites any union data inside the Params as the provided FormParams
func (t *Params) FromFormParams(v FormParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormParams performs a merge with any union data inside the Params, using the provided FormParams
func (t *Params) MergeFormParams(v FormParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApproverUpdateParams returns the union data inside the TaskUpdate_Parameters as a ApproverUpdateParams
func (t TaskUpdate_Parameters) AsApproverUpdateParams() (ApproverUpdateParams, error) {
	var body ApproverUpdateParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApproverUpdateParams overwrites any union data inside the TaskUpdate_Parameters as the provided ApproverUpdateParams
func (t *TaskUpdate_Parameters) FromApproverUpdateParams(v ApproverUpdateParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApproverUpdateParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided ApproverUpdateParams
func (t *TaskUpdate_Parameters) MergeApproverUpdateParams(v ApproverUpdateParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAdditionalApproverUpdateParams returns the union data inside the TaskUpdate_Parameters as a AdditionalApproverUpdateParams
func (t TaskUpdate_Parameters) AsAdditionalApproverUpdateParams() (AdditionalApproverUpdateParams, error) {
	var body AdditionalApproverUpdateParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdditionalApproverUpdateParams overwrites any union data inside the TaskUpdate_Parameters as the provided AdditionalApproverUpdateParams
func (t *TaskUpdate_Parameters) FromAdditionalApproverUpdateParams(v AdditionalApproverUpdateParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdditionalApproverUpdateParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided AdditionalApproverUpdateParams
func (t *TaskUpdate_Parameters) MergeAdditionalApproverUpdateParams(v AdditionalApproverUpdateParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExecutionUpdateParams returns the union data inside the TaskUpdate_Parameters as a ExecutionUpdateParams
func (t TaskUpdate_Parameters) AsExecutionUpdateParams() (ExecutionUpdateParams, error) {
	var body ExecutionUpdateParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecutionUpdateParams overwrites any union data inside the TaskUpdate_Parameters as the provided ExecutionUpdateParams
func (t *TaskUpdate_Parameters) FromExecutionUpdateParams(v ExecutionUpdateParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExecutionUpdateParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided ExecutionUpdateParams
func (t *TaskUpdate_Parameters) MergeExecutionUpdateParams(v ExecutionUpdateParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExecutorChangeParams returns the union data inside the TaskUpdate_Parameters as a ExecutorChangeParams
func (t TaskUpdate_Parameters) AsExecutorChangeParams() (ExecutorChangeParams, error) {
	var body ExecutorChangeParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecutorChangeParams overwrites any union data inside the TaskUpdate_Parameters as the provided ExecutorChangeParams
func (t *TaskUpdate_Parameters) FromExecutorChangeParams(v ExecutorChangeParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExecutorChangeParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided ExecutorChangeParams
func (t *TaskUpdate_Parameters) MergeExecutorChangeParams(v ExecutorChangeParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRequestInfoUpdateParams returns the union data inside the TaskUpdate_Parameters as a RequestInfoUpdateParams
func (t TaskUpdate_Parameters) AsRequestInfoUpdateParams() (RequestInfoUpdateParams, error) {
	var body RequestInfoUpdateParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestInfoUpdateParams overwrites any union data inside the TaskUpdate_Parameters as the provided RequestInfoUpdateParams
func (t *TaskUpdate_Parameters) FromRequestInfoUpdateParams(v RequestInfoUpdateParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestInfoUpdateParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided RequestInfoUpdateParams
func (t *TaskUpdate_Parameters) MergeRequestInfoUpdateParams(v RequestInfoUpdateParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExecutableFunctionParams returns the union data inside the TaskUpdate_Parameters as a ExecutableFunctionParams
func (t TaskUpdate_Parameters) AsExecutableFunctionParams() (ExecutableFunctionParams, error) {
	var body ExecutableFunctionParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecutableFunctionParams overwrites any union data inside the TaskUpdate_Parameters as the provided ExecutableFunctionParams
func (t *TaskUpdate_Parameters) FromExecutableFunctionParams(v ExecutableFunctionParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExecutableFunctionParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided ExecutableFunctionParams
func (t *TaskUpdate_Parameters) MergeExecutableFunctionParams(v ExecutableFunctionParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFillFormUpdateParams returns the union data inside the TaskUpdate_Parameters as a FillFormUpdateParams
func (t TaskUpdate_Parameters) AsFillFormUpdateParams() (FillFormUpdateParams, error) {
	var body FillFormUpdateParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillFormUpdateParams overwrites any union data inside the TaskUpdate_Parameters as the provided FillFormUpdateParams
func (t *TaskUpdate_Parameters) FromFillFormUpdateParams(v FillFormUpdateParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillFormUpdateParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided FillFormUpdateParams
func (t *TaskUpdate_Parameters) MergeFillFormUpdateParams(v FillFormUpdateParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAddApproversParams returns the union data inside the TaskUpdate_Parameters as a AddApproversParams
func (t TaskUpdate_Parameters) AsAddApproversParams() (AddApproversParams, error) {
	var body AddApproversParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddApproversParams overwrites any union data inside the TaskUpdate_Parameters as the provided AddApproversParams
func (t *TaskUpdate_Parameters) FromAddApproversParams(v AddApproversParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddApproversParams performs a merge with any union data inside the TaskUpdate_Parameters, using the provided AddApproversParams
func (t *TaskUpdate_Parameters) MergeAddApproversParams(v AddApproversParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TaskUpdate_Parameters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TaskUpdate_Parameters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVariableOperand returns the union data inside the Operand as a VariableOperand
func (t Operand) AsVariableOperand() (VariableOperand, error) {
	var body VariableOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVariableOperand overwrites any union data inside the Operand as the provided VariableOperand
func (t *Operand) FromVariableOperand(v VariableOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVariableOperand performs a merge with any union data inside the Operand, using the provided VariableOperand
func (t *Operand) MergeVariableOperand(v VariableOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsValueOperand returns the union data inside the Operand as a ValueOperand
func (t Operand) AsValueOperand() (ValueOperand, error) {
	var body ValueOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValueOperand overwrites any union data inside the Operand as the provided ValueOperand
func (t *Operand) FromValueOperand(v ValueOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValueOperand performs a merge with any union data inside the Operand, using the provided ValueOperand
func (t *Operand) MergeValueOperand(v ValueOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Operand) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"operandType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Operand) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operand) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringOperand returns the union data inside the ValueOperand as a StringOperand
func (t ValueOperand) AsStringOperand() (StringOperand, error) {
	var body StringOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringOperand overwrites any union data inside the ValueOperand as the provided StringOperand
func (t *ValueOperand) FromStringOperand(v StringOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringOperand performs a merge with any union data inside the ValueOperand, using the provided StringOperand
func (t *ValueOperand) MergeStringOperand(v StringOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsIntegerOperand returns the union data inside the ValueOperand as a IntegerOperand
func (t ValueOperand) AsIntegerOperand() (IntegerOperand, error) {
	var body IntegerOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerOperand overwrites any union data inside the ValueOperand as the provided IntegerOperand
func (t *ValueOperand) FromIntegerOperand(v IntegerOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerOperand performs a merge with any union data inside the ValueOperand, using the provided IntegerOperand
func (t *ValueOperand) MergeIntegerOperand(v IntegerOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNumberOperand returns the union data inside the ValueOperand as a NumberOperand
func (t ValueOperand) AsNumberOperand() (NumberOperand, error) {
	var body NumberOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNumberOperand overwrites any union data inside the ValueOperand as the provided NumberOperand
func (t *ValueOperand) FromNumberOperand(v NumberOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNumberOperand performs a merge with any union data inside the ValueOperand, using the provided NumberOperand
func (t *ValueOperand) MergeNumberOperand(v NumberOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsBooleanOperand returns the union data inside the ValueOperand as a BooleanOperand
func (t ValueOperand) AsBooleanOperand() (BooleanOperand, error) {
	var body BooleanOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanOperand overwrites any union data inside the ValueOperand as the provided BooleanOperand
func (t *ValueOperand) FromBooleanOperand(v BooleanOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanOperand performs a merge with any union data inside the ValueOperand, using the provided BooleanOperand
func (t *ValueOperand) MergeBooleanOperand(v BooleanOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDateOperand returns the union data inside the ValueOperand as a DateOperand
func (t ValueOperand) AsDateOperand() (DateOperand, error) {
	var body DateOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateOperand overwrites any union data inside the ValueOperand as the provided DateOperand
func (t *ValueOperand) FromDateOperand(v DateOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateOperand performs a merge with any union data inside the ValueOperand, using the provided DateOperand
func (t *ValueOperand) MergeDateOperand(v DateOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ValueOperand) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["value"], err = json.Marshal(t.Value)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'value': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ValueOperand) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &t.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
	}

	return err
}

// AsStringOperand returns the union data inside the VariableOperand as a StringOperand
func (t VariableOperand) AsStringOperand() (StringOperand, error) {
	var body StringOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringOperand overwrites any union data inside the VariableOperand as the provided StringOperand
func (t *VariableOperand) FromStringOperand(v StringOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringOperand performs a merge with any union data inside the VariableOperand, using the provided StringOperand
func (t *VariableOperand) MergeStringOperand(v StringOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsIntegerOperand returns the union data inside the VariableOperand as a IntegerOperand
func (t VariableOperand) AsIntegerOperand() (IntegerOperand, error) {
	var body IntegerOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerOperand overwrites any union data inside the VariableOperand as the provided IntegerOperand
func (t *VariableOperand) FromIntegerOperand(v IntegerOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerOperand performs a merge with any union data inside the VariableOperand, using the provided IntegerOperand
func (t *VariableOperand) MergeIntegerOperand(v IntegerOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNumberOperand returns the union data inside the VariableOperand as a NumberOperand
func (t VariableOperand) AsNumberOperand() (NumberOperand, error) {
	var body NumberOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNumberOperand overwrites any union data inside the VariableOperand as the provided NumberOperand
func (t *VariableOperand) FromNumberOperand(v NumberOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNumberOperand performs a merge with any union data inside the VariableOperand, using the provided NumberOperand
func (t *VariableOperand) MergeNumberOperand(v NumberOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsBooleanOperand returns the union data inside the VariableOperand as a BooleanOperand
func (t VariableOperand) AsBooleanOperand() (BooleanOperand, error) {
	var body BooleanOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanOperand overwrites any union data inside the VariableOperand as the provided BooleanOperand
func (t *VariableOperand) FromBooleanOperand(v BooleanOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanOperand performs a merge with any union data inside the VariableOperand, using the provided BooleanOperand
func (t *VariableOperand) MergeBooleanOperand(v BooleanOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDateOperand returns the union data inside the VariableOperand as a DateOperand
func (t VariableOperand) AsDateOperand() (DateOperand, error) {
	var body DateOperand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateOperand overwrites any union data inside the VariableOperand as the provided DateOperand
func (t *VariableOperand) FromDateOperand(v DateOperand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateOperand performs a merge with any union data inside the VariableOperand, using the provided DateOperand
func (t *VariableOperand) MergeDateOperand(v DateOperand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t VariableOperand) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["variableRef"], err = json.Marshal(t.VariableRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'variableRef': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *VariableOperand) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["variableRef"]; found {
		err = json.Unmarshal(raw, &t.VariableRef)
		if err != nil {
			return fmt.Errorf("error reading 'variableRef': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// rate application
	// (POST /application/rate/{workNumber})
	RateApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// get application
	// (GET /application/{workNumber})
	GetApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// set application
	// (POST /application/{workNumber})
	SetApplication(w http.ResponseWriter, r *http.Request, workNumber string)
	// Check if any steps breached SLA
	// (GET /cron/sla)
	CheckBreachSLA(w http.ResponseWriter, r *http.Request)
	// Start debug task
	// (POST /debug/run)
	StartDebugTask(w http.ResponseWriter, r *http.Request)
	// Debug task
	// (GET /debug/{workNumber})
	DebugTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get approve action names dictionary
	// (GET /dictionaries/approve-action-names)
	GetApproveActionNames(w http.ResponseWriter, r *http.Request)
	// Get approve statuses dictionary
	// (GET /dictionaries/approve-statuses)
	GetApproveStatuses(w http.ResponseWriter, r *http.Request)
	// Get forms changelog
	// (GET /forms/changelog)
	GetFormsChangelog(w http.ResponseWriter, r *http.Request, params GetFormsChangelogParams)
	// Get list of modules
	// (GET /modules)
	GetModules(w http.ResponseWriter, r *http.Request)
	// Get list of modules usage
	// (GET /modules/usage)
	AllModulesUsage(w http.ResponseWriter, r *http.Request)
	// Usage of module in pipelines
	// (GET /modules/{moduleName}/usage)
	ModuleUsage(w http.ResponseWriter, r *http.Request, moduleName string)
	// Get tasks for monitoring
	// (GET /monitoring/tasks)
	GetTasksForMonitoring(w http.ResponseWriter, r *http.Request, params GetTasksForMonitoringParams)
	// Получение контекста блоков
	// (GET /monitoring/tasks/block/{blockId}/context)
	GetBlockContext(w http.ResponseWriter, r *http.Request, blockId string)
	// Get inputs and outputs of block
	// (GET /monitoring/tasks/block/{blockId}/params)
	GetMonitoringTasksBlockBlockIdParams(w http.ResponseWriter, r *http.Request, blockId string)
	// Get task for monitoring
	// (GET /monitoring/tasks/{workNumber})
	GetMonitoringTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get list of pipelines
	// (GET /pipelines)
	ListPipelines(w http.ResponseWriter, r *http.Request, params ListPipelinesParams)
	// Create pipeline
	// (POST /pipelines)
	CreatePipeline(w http.ResponseWriter, r *http.Request)
	// Creates copy of pipeline
	// (POST /pipelines/copy)
	CopyPipeline(w http.ResponseWriter, r *http.Request)
	// Rename Pipeline
	// (PUT /pipelines/name)
	RenamePipeline(w http.ResponseWriter, r *http.Request)
	// search list of pipelines
	// (GET /pipelines/search)
	SearchPipelines(w http.ResponseWriter, r *http.Request, params SearchPipelinesParams)
	// Edit Draft
	// (PUT /pipelines/version)
	EditVersion(w http.ResponseWriter, r *http.Request)
	// Delete Version
	// (DELETE /pipelines/version/{ID})
	DeleteVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Get pipeline version
	// (GET /pipelines/version/{ID})
	GetPipelineVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Create pipeline version
	// (POST /pipelines/version/{ID})
	CreatePipelineVersion(w http.ResponseWriter, r *http.Request, iD string)
	// Get process settings with a list of external systems
	// (GET /pipelines/version/{versionID}/settings)
	GetVersionSettings(w http.ResponseWriter, r *http.Request, versionID string)
	// Save process settings(start and end schemas)
	// (POST /pipelines/version/{versionID}/settings)
	SaveVersionSettings(w http.ResponseWriter, r *http.Request, versionID string, params SaveVersionSettingsParams)
	// Add external system to version
	// (POST /pipelines/version/{versionID}/system)
	AddExternalSystemToVersion(w http.ResponseWriter, r *http.Request, versionID string)
	// Remove external system from list
	// (DELETE /pipelines/version/{versionID}/system/{systemID})
	RemoveExternalSystem(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Get external system settings
	// (GET /pipelines/version/{versionID}/system/{systemID})
	GetExternalSystemSettings(w http.ResponseWriter, r *http.Request, versionID string, systemID string)
	// Save external system settings
	// (PUT /pipelines/version/{versionID}/system/{systemID})
	SaveExternalSystemSettings(w http.ResponseWriter, r *http.Request, versionID string, systemID string, params SaveExternalSystemSettingsParams)
	// Delete Pipeline
	// (DELETE /pipelines/{pipelineID})
	DeletePipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get pipeline
	// (GET /pipelines/{pipelineID})
	GetPipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Active scheduler tasks
	// (POST /pipelines/{pipelineID}/scheduler-tasks)
	ListSchedulerTasks(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Pipeline Tags
	// (GET /pipelines/{pipelineID}/tags)
	GetPipelineTags(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Detach Tag
	// (DELETE /pipelines/{pipelineID}/tags/{ID})
	DetachTag(w http.ResponseWriter, r *http.Request, pipelineID string, iD string)
	// Attach Tag
	// (PUT /pipelines/{pipelineID}/tags/{ID})
	AttachTag(w http.ResponseWriter, r *http.Request, pipelineID string, iD string)
	// Get pipeline versions
	// (GET /pipelines/{pipelineID}/versions)
	GetPipelineVersions(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Run Version
	// (POST /run/version/new_version)
	RunNewVersionByPrevVersion(w http.ResponseWriter, r *http.Request)
	// Run Version
	// (POST /run/version/{versionID})
	RunVersion(w http.ResponseWriter, r *http.Request, versionID string)
	// Run Version By pipeline_id
	// (POST /run/versions/pipeline_id)
	RunVersionsByPipelineId(w http.ResponseWriter, r *http.Request)
	// Run Pipeline
	// (POST /run/{pipelineID})
	RunPipeline(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Tags
	// (GET /tags)
	GetTags(w http.ResponseWriter, r *http.Request)
	// Create Tag
	// (POST /tags)
	CreateTag(w http.ResponseWriter, r *http.Request)
	// Edit Tag
	// (PUT /tags)
	EditTag(w http.ResponseWriter, r *http.Request)
	// Remove Tag
	// (DELETE /tags/{ID})
	RemoveTag(w http.ResponseWriter, r *http.Request, iD string)
	// Get Tasks
	// (GET /tasks)
	GetTasks(w http.ResponseWriter, r *http.Request, params GetTasksParams)
	// Update tasks by mails
	// (GET /tasks/by-mails)
	UpdateTasksByMails(w http.ResponseWriter, r *http.Request)
	// Get amount of tasks
	// (GET /tasks/count)
	GetTasksCount(w http.ResponseWriter, r *http.Request)
	// Get last debug task for version
	// (GET /tasks/last-by-version/{versionID})
	LastVersionDebugTask(w http.ResponseWriter, r *http.Request, versionID string)
	// Get Task Mean Solve time
	// (GET /tasks/mean/{pipelineId})
	GetTaskMeanSolveTime(w http.ResponseWriter, r *http.Request, pipelineId string)
	// Get Pipeline Tasks
	// (GET /tasks/pipeline/{pipelineID})
	GetPipelineTasks(w http.ResponseWriter, r *http.Request, pipelineID string)
	// Get Version Tasks
	// (GET /tasks/version/{versionID})
	GetVersionTasks(w http.ResponseWriter, r *http.Request, versionID string)
	// Get Task
	// (GET /tasks/{workNumber})
	GetTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Update Task
	// (POST /tasks/{workNumber})
	UpdateTask(w http.ResponseWriter, r *http.Request, workNumber string)
	// Get Task form schema
	// (GET /tasks/{workNumber}/{formID}/schema)
	GetTaskFormSchema(w http.ResponseWriter, r *http.Request, workNumber string, formID string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// RateApplication operation middleware
func (siw *ServerInterfaceWrapper) RateApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RateApplication(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetApplication operation middleware
func (siw *ServerInterfaceWrapper) GetApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApplication(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SetApplication operation middleware
func (siw *ServerInterfaceWrapper) SetApplication(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetApplication(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CheckBreachSLA operation middleware
func (siw *ServerInterfaceWrapper) CheckBreachSLA(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckBreachSLA(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// StartDebugTask operation middleware
func (siw *ServerInterfaceWrapper) StartDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartDebugTask(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DebugTask operation middleware
func (siw *ServerInterfaceWrapper) DebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DebugTask(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetApproveActionNames operation middleware
func (siw *ServerInterfaceWrapper) GetApproveActionNames(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApproveActionNames(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetApproveStatuses operation middleware
func (siw *ServerInterfaceWrapper) GetApproveStatuses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApproveStatuses(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFormsChangelog operation middleware
func (siw *ServerInterfaceWrapper) GetFormsChangelog(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFormsChangelogParams

	// ------------- Required query parameter "work_number" -------------

	if paramValue := r.URL.Query().Get("work_number"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "work_number"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "work_number", r.URL.Query(), &params.WorkNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "work_number", Err: err})
		return
	}

	// ------------- Required query parameter "block_id" -------------

	if paramValue := r.URL.Query().Get("block_id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "block_id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "block_id", r.URL.Query(), &params.BlockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "block_id", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFormsChangelog(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetModules operation middleware
func (siw *ServerInterfaceWrapper) GetModules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetModules(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AllModulesUsage operation middleware
func (siw *ServerInterfaceWrapper) AllModulesUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AllModulesUsage(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ModuleUsage operation middleware
func (siw *ServerInterfaceWrapper) ModuleUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "moduleName" -------------
	var moduleName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "moduleName", runtime.ParamLocationPath, chi.URLParam(r, "moduleName"), &moduleName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "moduleName", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModuleUsage(w, r, moduleName)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTasksForMonitoring operation middleware
func (siw *ServerInterfaceWrapper) GetTasksForMonitoring(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksForMonitoringParams

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "per_page", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.column" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.column", r.URL.Query(), &params.SortColumn)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.column", Err: err})
		return
	}

	// ------------- Optional query parameter "sort.order" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort.order", r.URL.Query(), &params.SortOrder)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort.order", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	// ------------- Optional query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_date", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from_date", Err: err})
		return
	}

	// ------------- Optional query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_date", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to_date", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasksForMonitoring(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetBlockContext operation middleware
func (siw *ServerInterfaceWrapper) GetBlockContext(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "blockId" -------------
	var blockId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blockId", runtime.ParamLocationPath, chi.URLParam(r, "blockId"), &blockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "blockId", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBlockContext(w, r, blockId)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetMonitoringTasksBlockBlockIdParams operation middleware
func (siw *ServerInterfaceWrapper) GetMonitoringTasksBlockBlockIdParams(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "blockId" -------------
	var blockId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blockId", runtime.ParamLocationPath, chi.URLParam(r, "blockId"), &blockId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "blockId", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMonitoringTasksBlockBlockIdParams(w, r, blockId)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetMonitoringTask operation middleware
func (siw *ServerInterfaceWrapper) GetMonitoringTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMonitoringTask(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListPipelines operation middleware
func (siw *ServerInterfaceWrapper) ListPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPipelinesParams

	// ------------- Optional query parameter "my" -------------

	err = runtime.BindQueryParameter("form", true, false, "my", r.URL.Query(), &params.My)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "my", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPipelines(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreatePipeline operation middleware
func (siw *ServerInterfaceWrapper) CreatePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipeline(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CopyPipeline operation middleware
func (siw *ServerInterfaceWrapper) CopyPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyPipeline(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RenamePipeline operation middleware
func (siw *ServerInterfaceWrapper) RenamePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RenamePipeline(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SearchPipelines operation middleware
func (siw *ServerInterfaceWrapper) SearchPipelines(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchPipelinesParams

	// ------------- Optional query parameter "pipelineName" -------------

	err = runtime.BindQueryParameter("form", true, false, "pipelineName", r.URL.Query(), &params.PipelineName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineName", Err: err})
		return
	}

	// ------------- Optional query parameter "pipelineId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pipelineId", r.URL.Query(), &params.PipelineId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineId", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "perPage", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchPipelines(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// EditVersion operation middleware
func (siw *ServerInterfaceWrapper) EditVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditVersion(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ID", runtime.ParamLocationPath, chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersion(w, r, iD)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ID", runtime.ParamLocationPath, chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersion(w, r, iD)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreatePipelineVersion operation middleware
func (siw *ServerInterfaceWrapper) CreatePipelineVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ID", runtime.ParamLocationPath, chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePipelineVersion(w, r, iD)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetVersionSettings operation middleware
func (siw *ServerInterfaceWrapper) GetVersionSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionSettings(w, r, versionID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SaveVersionSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveVersionSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SaveVersionSettingsParams

	// ------------- Optional query parameter "schema_flag" -------------

	err = runtime.BindQueryParameter("form", true, false, "schema_flag", r.URL.Query(), &params.SchemaFlag)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schema_flag", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveVersionSettings(w, r, versionID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddExternalSystemToVersion operation middleware
func (siw *ServerInterfaceWrapper) AddExternalSystemToVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddExternalSystemToVersion(w, r, versionID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RemoveExternalSystem operation middleware
func (siw *ServerInterfaceWrapper) RemoveExternalSystem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "systemID", runtime.ParamLocationPath, chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveExternalSystem(w, r, versionID, systemID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetExternalSystemSettings operation middleware
func (siw *ServerInterfaceWrapper) GetExternalSystemSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "systemID", runtime.ParamLocationPath, chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExternalSystemSettings(w, r, versionID, systemID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SaveExternalSystemSettings operation middleware
func (siw *ServerInterfaceWrapper) SaveExternalSystemSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	// ------------- Path parameter "systemID" -------------
	var systemID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "systemID", runtime.ParamLocationPath, chi.URLParam(r, "systemID"), &systemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SaveExternalSystemSettingsParams

	// ------------- Optional query parameter "schema_flag" -------------

	err = runtime.BindQueryParameter("form", true, false, "schema_flag", r.URL.Query(), &params.SchemaFlag)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schema_flag", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveExternalSystemSettings(w, r, versionID, systemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeletePipeline operation middleware
func (siw *ServerInterfaceWrapper) DeletePipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePipeline(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPipeline operation middleware
func (siw *ServerInterfaceWrapper) GetPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipeline(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSchedulerTasks operation middleware
func (siw *ServerInterfaceWrapper) ListSchedulerTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSchedulerTasks(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPipelineTags operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTags(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DetachTag operation middleware
func (siw *ServerInterfaceWrapper) DetachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ID", runtime.ParamLocationPath, chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachTag(w, r, pipelineID, iD)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AttachTag operation middleware
func (siw *ServerInterfaceWrapper) AttachTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ID", runtime.ParamLocationPath, chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachTag(w, r, pipelineID, iD)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPipelineVersions operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineVersions(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RunNewVersionByPrevVersion operation middleware
func (siw *ServerInterfaceWrapper) RunNewVersionByPrevVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunNewVersionByPrevVersion(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RunVersion operation middleware
func (siw *ServerInterfaceWrapper) RunVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersion(w, r, versionID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RunVersionsByPipelineId operation middleware
func (siw *ServerInterfaceWrapper) RunVersionsByPipelineId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunVersionsByPipelineId(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RunPipeline operation middleware
func (siw *ServerInterfaceWrapper) RunPipeline(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunPipeline(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTags operation middleware
func (siw *ServerInterfaceWrapper) GetTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTags(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// EditTag operation middleware
func (siw *ServerInterfaceWrapper) EditTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditTag(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RemoveTag operation middleware
func (siw *ServerInterfaceWrapper) RemoveTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ID" -------------
	var iD string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ID", runtime.ParamLocationPath, chi.URLParam(r, "ID"), &iD)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveTag(w, r, iD)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTasks operation middleware
func (siw *ServerInterfaceWrapper) GetTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "taskIDs" -------------

	err = runtime.BindQueryParameter("form", false, false, "taskIDs", r.URL.Query(), &params.TaskIDs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "taskIDs", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "created" -------------

	if paramValue := r.URL.Query().Get("created"); paramValue != "" {

		var value Created
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &UnmarshallingParamError{ParamName: "created", Err: err})
			return
		}

		params.Created = &value

	}

	// ------------- Optional query parameter "archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "archived", r.URL.Query(), &params.Archived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "archived", Err: err})
		return
	}

	// ------------- Optional query parameter "selectAs" -------------

	err = runtime.BindQueryParameter("form", true, false, "selectAs", r.URL.Query(), &params.SelectAs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selectAs", Err: err})
		return
	}

	// ------------- Optional query parameter "forCarousel" -------------

	err = runtime.BindQueryParameter("form", true, false, "forCarousel", r.URL.Query(), &params.ForCarousel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forCarousel", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "receiver" -------------

	err = runtime.BindQueryParameter("form", true, false, "receiver", r.URL.Query(), &params.Receiver)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "receiver", Err: err})
		return
	}

	// ------------- Optional query parameter "hasAttachments" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasAttachments", r.URL.Query(), &params.HasAttachments)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hasAttachments", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasks(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateTasksByMails operation middleware
func (siw *ServerInterfaceWrapper) UpdateTasksByMails(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTasksByMails(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTasksCount operation middleware
func (siw *ServerInterfaceWrapper) GetTasksCount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasksCount(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// LastVersionDebugTask operation middleware
func (siw *ServerInterfaceWrapper) LastVersionDebugTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LastVersionDebugTask(w, r, versionID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTaskMeanSolveTime operation middleware
func (siw *ServerInterfaceWrapper) GetTaskMeanSolveTime(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineId" -------------
	var pipelineId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, chi.URLParam(r, "pipelineId"), &pipelineId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineId", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskMeanSolveTime(w, r, pipelineId)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPipelineTasks operation middleware
func (siw *ServerInterfaceWrapper) GetPipelineTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "pipelineID" -------------
	var pipelineID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipelineID", runtime.ParamLocationPath, chi.URLParam(r, "pipelineID"), &pipelineID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pipelineID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPipelineTasks(w, r, pipelineID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetVersionTasks operation middleware
func (siw *ServerInterfaceWrapper) GetVersionTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "versionID" -------------
	var versionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "versionID", runtime.ParamLocationPath, chi.URLParam(r, "versionID"), &versionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "versionID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionTasks(w, r, versionID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTask operation middleware
func (siw *ServerInterfaceWrapper) GetTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTask(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateTask operation middleware
func (siw *ServerInterfaceWrapper) UpdateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTask(w, r, workNumber)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTaskFormSchema operation middleware
func (siw *ServerInterfaceWrapper) GetTaskFormSchema(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "workNumber" -------------
	var workNumber string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workNumber", runtime.ParamLocationPath, chi.URLParam(r, "workNumber"), &workNumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workNumber", Err: err})
		return
	}

	// ------------- Path parameter "formID" -------------
	var formID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "formID", runtime.ParamLocationPath, chi.URLParam(r, "formID"), &formID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "formID", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskFormSchema(w, r, workNumber, formID)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/application/rate/{workNumber}", wrapper.RateApplication)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/application/{workNumber}", wrapper.GetApplication)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/application/{workNumber}", wrapper.SetApplication)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cron/sla", wrapper.CheckBreachSLA)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/debug/run", wrapper.StartDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/debug/{workNumber}", wrapper.DebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/approve-action-names", wrapper.GetApproveActionNames)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dictionaries/approve-statuses", wrapper.GetApproveStatuses)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forms/changelog", wrapper.GetFormsChangelog)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules", wrapper.GetModules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/usage", wrapper.AllModulesUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/modules/{moduleName}/usage", wrapper.ModuleUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks", wrapper.GetTasksForMonitoring)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks/block/{blockId}/context", wrapper.GetBlockContext)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks/block/{blockId}/params", wrapper.GetMonitoringTasksBlockBlockIdParams)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/monitoring/tasks/{workNumber}", wrapper.GetMonitoringTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines", wrapper.ListPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines", wrapper.CreatePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/copy", wrapper.CopyPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/name", wrapper.RenamePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/search", wrapper.SearchPipelines)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version", wrapper.EditVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{ID}", wrapper.DeleteVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{ID}", wrapper.GetPipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{ID}", wrapper.CreatePipelineVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{versionID}/settings", wrapper.GetVersionSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{versionID}/settings", wrapper.SaveVersionSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/version/{versionID}/system", wrapper.AddExternalSystemToVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}", wrapper.RemoveExternalSystem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}", wrapper.GetExternalSystemSettings)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/version/{versionID}/system/{systemID}", wrapper.SaveExternalSystemSettings)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}", wrapper.DeletePipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}", wrapper.GetPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/pipelines/{pipelineID}/scheduler-tasks", wrapper.ListSchedulerTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/tags", wrapper.GetPipelineTags)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/pipelines/{pipelineID}/tags/{ID}", wrapper.DetachTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/pipelines/{pipelineID}/tags/{ID}", wrapper.AttachTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pipelines/{pipelineID}/versions", wrapper.GetPipelineVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/new_version", wrapper.RunNewVersionByPrevVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/version/{versionID}", wrapper.RunVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/versions/pipeline_id", wrapper.RunVersionsByPipelineId)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/run/{pipelineID}", wrapper.RunPipeline)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/tags", wrapper.EditTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/tags/{ID}", wrapper.RemoveTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks", wrapper.GetTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/by-mails", wrapper.UpdateTasksByMails)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/count", wrapper.GetTasksCount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/last-by-version/{versionID}", wrapper.LastVersionDebugTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/mean/{pipelineId}", wrapper.GetTaskMeanSolveTime)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/pipeline/{pipelineID}", wrapper.GetPipelineTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/version/{versionID}", wrapper.GetVersionTasks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}", wrapper.GetTask)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tasks/{workNumber}", wrapper.UpdateTask)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks/{workNumber}/{formID}/schema", wrapper.GetTaskFormSchema)
	})

	return r
}
